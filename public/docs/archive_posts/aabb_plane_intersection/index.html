<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="起因是我在学习 runtime 的 mesh 切割算法,需要判断目标 mesh 是否和切面相交(不相交的话我就不需要去处理了)
前提知识#Unity 的 mesh 和 collider 都使用 AABB 包围盒
什么是 AABB 包围盒?#AABB ==&gt; Axis Aligned Bounding Box (轴对齐边界框)
AABB(轴对齐边界框)是一个 3D 框。它的宽度/高度/深度不必相等,但宽度始终与 X 轴对齐,高度与 Y 轴对齐,深度与 Z 轴对齐。也就是说,这个盒子是不能旋转的。
旧博客归档,图片已失效
如何表示 AABB?#有两种常见的方法,存储最左边和最右边的角,或者存储中心点和盒子在每侧延伸多远的向量。
第一种:
public struct AABB { public Vector3 min; public Vector3 max; }第二种:
public struct AABB { public Vector3 center; public Vector3 extents; }算法#为了测试 AABB 和平面是否相交,我们首先必须将 AABB 的每个顶点投影到平面的法线上。这使我们 AABB 的所有顶点都在一条线上。
然后,我们检查离平面最远的顶点。如果与顶点对角线相对的顶点位于平面的另一侧,则我们有一个交点。
通用的 C# 代码如下,无论你的 AABB 是如何表示的(max/min 或 center/extents),只需要稍作修改:
">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="http://localhost:1313/docs/archive_posts/aabb_plane_intersection/">
  <meta property="og:site_name" content="rdququ&#39;s Blog">
  <meta property="og:title" content="AABB Plane Intersection">
  <meta property="og:description" content="起因是我在学习 runtime 的 mesh 切割算法,需要判断目标 mesh 是否和切面相交(不相交的话我就不需要去处理了)
前提知识#Unity 的 mesh 和 collider 都使用 AABB 包围盒
什么是 AABB 包围盒?#AABB ==&gt; Axis Aligned Bounding Box (轴对齐边界框)
AABB(轴对齐边界框)是一个 3D 框。它的宽度/高度/深度不必相等,但宽度始终与 X 轴对齐,高度与 Y 轴对齐,深度与 Z 轴对齐。也就是说,这个盒子是不能旋转的。
旧博客归档,图片已失效
如何表示 AABB?#有两种常见的方法,存储最左边和最右边的角,或者存储中心点和盒子在每侧延伸多远的向量。
第一种:
public struct AABB { public Vector3 min; public Vector3 max; }第二种:
public struct AABB { public Vector3 center; public Vector3 extents; }算法#为了测试 AABB 和平面是否相交,我们首先必须将 AABB 的每个顶点投影到平面的法线上。这使我们 AABB 的所有顶点都在一条线上。
然后,我们检查离平面最远的顶点。如果与顶点对角线相对的顶点位于平面的另一侧,则我们有一个交点。
通用的 C# 代码如下,无论你的 AABB 是如何表示的(max/min 或 center/extents),只需要稍作修改:">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="docs">
    <meta property="article:published_time" content="2023-12-05T00:00:00+00:00">
    <meta property="article:modified_time" content="2023-12-05T00:00:00+00:00">


  <meta itemprop="name" content="AABB Plane Intersection">
  <meta itemprop="description" content="起因是我在学习 runtime 的 mesh 切割算法,需要判断目标 mesh 是否和切面相交(不相交的话我就不需要去处理了)
前提知识#Unity 的 mesh 和 collider 都使用 AABB 包围盒
什么是 AABB 包围盒?#AABB ==&gt; Axis Aligned Bounding Box (轴对齐边界框)
AABB(轴对齐边界框)是一个 3D 框。它的宽度/高度/深度不必相等,但宽度始终与 X 轴对齐,高度与 Y 轴对齐,深度与 Z 轴对齐。也就是说,这个盒子是不能旋转的。
旧博客归档,图片已失效
如何表示 AABB?#有两种常见的方法,存储最左边和最右边的角,或者存储中心点和盒子在每侧延伸多远的向量。
第一种:
public struct AABB { public Vector3 min; public Vector3 max; }第二种:
public struct AABB { public Vector3 center; public Vector3 extents; }算法#为了测试 AABB 和平面是否相交,我们首先必须将 AABB 的每个顶点投影到平面的法线上。这使我们 AABB 的所有顶点都在一条线上。
然后,我们检查离平面最远的顶点。如果与顶点对角线相对的顶点位于平面的另一侧,则我们有一个交点。
通用的 C# 代码如下,无论你的 AABB 是如何表示的(max/min 或 center/extents),只需要稍作修改:">
  <meta itemprop="datePublished" content="2023-12-05T00:00:00+00:00">
  <meta itemprop="dateModified" content="2023-12-05T00:00:00+00:00">
  <meta itemprop="wordCount" content="294">

<title>AABB Plane Intersection | rdququ&#39;s Blog</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="http://localhost:1313/docs/archive_posts/aabb_plane_intersection/">
<link rel="stylesheet" href="/book.min.cc2c524ed250aac81b23d1f4af87344917b325208841feca0968fe450f570575.css" integrity="sha256-zCxSTtJQqsgbI9H0r4c0SRezJSCIQf7KCWj&#43;RQ9XBXU=" crossorigin="anonymous">


  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.1cdae00495bbcc99219040905466ac17fee903495acba54776df72d26fbf3f62.js" integrity="sha256-HNrgBJW7zJkhkECQVGasF/7pA0lay6VHdt9y0m&#43;/P2I=" crossorigin="anonymous"></script>



  
</head>
<body dir="ltr" class="book-kind-page book-type-docs">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    
<aside class="book-menu">
  <div class="book-menu-content">
    
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>rdququ&#39;s Blog</span>
  </a>
</h2>


<div class="book-search hidden">
  <input id="book-search-input" type="text" 
    placeholder="Search"
    aria-label="Search"
    maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>













  
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/blog/" class="">
      Blog</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/links/" class="">
      Links</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/archive/" class="">
      Archive</a>
  

        </li>
      
    
  </ul>













</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>



  </div>
</aside>
 

    <div class="book-page">
      <header class="book-header hidden">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/icons/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>AABB Plane Intersection</h3>

  <label for="toc-control">
    
    <img src="/icons/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#前提知识">前提知识</a>
      <ul>
        <li><a href="#什么是-aabb-包围盒">什么是 AABB 包围盒?</a></li>
        <li><a href="#如何表示-aabb">如何表示 AABB?</a></li>
      </ul>
    </li>
    <li><a href="#算法">算法</a>
      <ul>
        <li><a href="#让我们来解析这段代码">让我们来解析这段代码</a></li>
      </ul>
    </li>
    <li><a href="#unity-实现">Unity 实现</a></li>
    <li><a href="#参考资料">参考资料</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><p>起因是我在学习 runtime 的 mesh 切割算法,需要判断目标 mesh 是否和切面相交(不相交的话我就不需要去处理了)</p>
<h2 id="前提知识">前提知识<a class="anchor" href="#%e5%89%8d%e6%8f%90%e7%9f%a5%e8%af%86">#</a></h2>
<p>Unity 的 mesh 和 collider 都使用 AABB 包围盒</p>
<h3 id="什么是-aabb-包围盒">什么是 AABB 包围盒?<a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af-aabb-%e5%8c%85%e5%9b%b4%e7%9b%92">#</a></h3>
<p>AABB ==&gt; Axis Aligned Bounding Box (轴对齐边界框)</p>
<p>AABB(轴对齐边界框)是一个 3D 框。它的宽度/高度/深度不必相等,但宽度始终与 X 轴对齐,高度与 Y 轴对齐,深度与 Z 轴对齐。也就是说,这个盒子是不能旋转的。</p>
<blockquote class='book-hint '>
<p>旧博客归档,图片已失效</p>
</blockquote><h3 id="如何表示-aabb">如何表示 AABB?<a class="anchor" href="#%e5%a6%82%e4%bd%95%e8%a1%a8%e7%a4%ba-aabb">#</a></h3>
<p>有两种常见的方法,存储最左边和最右边的角,或者存储中心点和盒子在每侧延伸多远的向量。</p>
<p>第一种:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">AABB</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Vector3 min;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Vector3 max;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>第二种:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">AABB</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Vector3 center;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Vector3 extents;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><h2 id="算法">算法<a class="anchor" href="#%e7%ae%97%e6%b3%95">#</a></h2>
<p>为了测试 AABB 和平面是否相交,我们首先必须将 AABB 的每个顶点投影到平面的法线上。这使我们 AABB 的所有顶点都在一条线上。</p>
<p>然后,我们检查离平面最远的顶点。如果与顶点对角线相对的顶点位于平面的另一侧,则我们有一个交点。</p>
<p>通用的 C# 代码如下,无论你的 AABB 是如何表示的(max/min 或 center/extents),只需要稍作修改:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#75715e">// Test if AABB b intersects plane p</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> TestAABBPlane(AABB b, Plane p) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Convert AABB to center-extents representation</span>
</span></span><span style="display:flex;"><span>    Point c = (b.max + b.min) * <span style="color:#ae81ff">0.5f</span>; <span style="color:#75715e">// Compute AABB center</span>
</span></span><span style="display:flex;"><span>    Point e = b.max - c; <span style="color:#75715e">// Compute positive extents</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Compute the projection interval radius of b onto L(t) = b.c + t * p.n</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> r = e[<span style="color:#ae81ff">0</span>]*Abs(p.n[<span style="color:#ae81ff">0</span>]) + e[<span style="color:#ae81ff">1</span>]*Abs(p.n[<span style="color:#ae81ff">1</span>]) + e[<span style="color:#ae81ff">2</span>]*Abs(p.n[<span style="color:#ae81ff">2</span>]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Compute distance of box center from plane</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> s = Dot(p.n, c) - p.d;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Intersection occurs when distance s falls within [-r,+r] interval</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Abs(s) &lt;= r;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><h3 id="让我们来解析这段代码">让我们来解析这段代码<a class="anchor" href="#%e8%ae%a9%e6%88%91%e4%bb%ac%e6%9d%a5%e8%a7%a3%e6%9e%90%e8%bf%99%e6%ae%b5%e4%bb%a3%e7%a0%81">#</a></h3>
<ol>
<li>
<p>函数传入了目标 Mesh 的 AABB,和目标平面</p>
</li>
<li>
<p>进入后的两行假设你的 AABB 是用 max/min 表示的,如果你可以轻松调取 AABB 的 center 和 extents,那么这两行是可以被跳过的</p>
</li>
<li>
<p>下一段代码计算了 AABB 的投影半径,这个半径是 AABB 投影到平面法线上的最大距离。
其取 AABB 的范围和平面法线的绝对值的点积,用于确保计算出的长度是正值,因为两个向量中的元素都是正值或零。</p>
<p>n&rsquo; = (|nx|, |ny|, |nz|)</p>
<p>e⃗ · n&rsquo;⃗ = |e⃗||n&rsquo;⃗|cosθ</p>
<p>|n&rsquo;⃗| = 1</p>
<p>e⃗ · n&rsquo;⃗ = |e⃗|cosθ</p>
</li>
<li>
<p>下面计算了 AABB 中心点到平面的距离,计为 s</p>
</li>
<li>
<p>最后的返回值即为 AABB 自身在平面法线上的距离和其中心到平面距离长短的判断</p>
</li>
</ol>
<h2 id="unity-实现">Unity 实现<a class="anchor" href="#unity-%e5%ae%9e%e7%8e%b0">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span> BoundPlaneIntersect(Mesh mesh, <span style="color:#66d9ef">ref</span> Plane plane)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Compute projection interval radius</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> r = mesh.bounds.extents.x * Mathf.Abs(plane.normal.x) +
</span></span><span style="display:flex;"><span>        mesh.bounds.extents.y * Mathf.Abs(plane.normal.y) +
</span></span><span style="display:flex;"><span>        mesh.bounds.extents.z * Mathf.Abs(plane.normal.z);<span style="color:#75715e">//做点乘,得出mesh包围盒的范围在平面法线上的投影,包围盒在平面法线方向上的最大距离</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Compute distance of box center from plane</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> s = Vector3.Dot(plane.normal, mesh.bounds.center) - (-plane.distance);<span style="color:#75715e">//前面点乘得mesh中心在平面法线上的投影,这是为了确保计算出的距离和后面的平面距离在同一方向</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//如果法线面朝内,后- (-plane.distance)为正,前mesh中心在与相对原点相交且与平面平行的平面&#39;靠近平面的一侧,Vector3.Dot(plane.normal, mesh.bounds.center)为负,符合逻辑</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//因为mesh中心和平面在同一侧,距离为相见</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//若mesh中心在与 相对原点相交且与平面平行的平面&#39; 远离平面的一侧,就是说mesh中心与平面中间相隔了一个原点,那么前后就都是同号,符合逻辑</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Intersection occurs when distance s falls within [-r,+r] interval</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Mathf.Abs(s) &lt;= r;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><h2 id="参考资料">参考资料<a class="anchor" href="#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99">#</a></h2>
<ul>
<li><a href="https://www.google.com/search?q=AABB&#43;-&#43;Axis&#43;Aligned&#43;Bounding&#43;Box">AABB - Axis Aligned Bounding Box</a></li>
<li><a href="https://docs.unity3d.com/ScriptReference/Bounds.html">Bounds-Unity_Documentation</a></li>
</ul>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">

<div>

</div>

<div>

</div>

</div>





  
  
  


 
        
  
  <div class="book-comments">
<div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "rdququ's Blog" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
  
 
        
        
  
 
        
  
  
    <script>(function(){document.querySelectorAll("pre:has(code)").forEach(e=>{e.addEventListener("click",e.focus),e.addEventListener("copy",function(t){if(t.preventDefault(),navigator.clipboard){const t=window.getSelection().toString()||e.textContent;navigator.clipboard.writeText(t)}})})})()</script>
  

      </footer>

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
  
  <aside class="book-toc">
    <div class="book-toc-content">
      
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#前提知识">前提知识</a>
      <ul>
        <li><a href="#什么是-aabb-包围盒">什么是 AABB 包围盒?</a></li>
        <li><a href="#如何表示-aabb">如何表示 AABB?</a></li>
      </ul>
    </li>
    <li><a href="#算法">算法</a>
      <ul>
        <li><a href="#让我们来解析这段代码">让我们来解析这段代码</a></li>
      </ul>
    </li>
    <li><a href="#unity-实现">Unity 实现</a></li>
    <li><a href="#参考资料">参考资料</a></li>
  </ul>
</nav>



    </div>
  </aside>
  
 
  </main>

  
</body>
</html>




















