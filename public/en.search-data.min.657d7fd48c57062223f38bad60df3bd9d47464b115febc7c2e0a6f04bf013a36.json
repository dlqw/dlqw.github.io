[{"id":0,"href":"/docs/posts/functional_programming_paradigm/","title":"Functional Programming Paradigm","section":"Posts","content":"函数式编程风格#\r命令式和声明式（Imperative \u0026amp; Declarative）#\r在谈论 FP 范式这个陌生词汇之前，我想先聊些我们熟悉的。\n1990年后，C 作为计算机教育的101课程，逐渐在中国高校中普及开来。这是一门典型的命令式语言，程序员使用运算，循环和跳转语句，作为汇编语言的抽象对硬件发出指令。这种范式还有一个名字更加广为人知“面向过程编程”。\n现今，几乎所有常见的编程语言都支持这一范式，包括 Java， Python 和 C++ 等常见的面向对象语言。面向对象要求将数据和操作数据的行为封装在对象中，通过这些对象来组织代码。逻辑的封装与数据的抽象并未改变人们依赖显式控制流去操控程序的状态以实现功能。\n不同于命令式的\u0026quot;你该那么做\u0026quot;，声明式语言更关注“你该做什么”。\n请允许我用 C# 举个例子：\n(string name, int age)[] people = new[] { (\u0026#34;Alice\u0026#34;, 12), (\u0026#34;Bob\u0026#34;, 5), (\u0026#34;Charlie\u0026#34;, 35), (\u0026#34;David\u0026#34;, 65), (\u0026#34;Eve\u0026#34;, 40), };我们需要在人群中筛选出成年者，并保存他们的姓名。\n这是一个常见的命令式实现\nstring[] adults = new string[people.Length]; for(int i = 0; i \u0026lt; people.Length; i++) { if (people[i].age \u0026gt;= 18) { adults[i] = people[i].name; } }而声明式则是这样的写法\nstring[] adults = people .Where(p =\u0026gt; p.age \u0026gt;= 18) .Select(p =\u0026gt; p.name) .ToArray();令人遗憾的是，虽然论述到本节时，一定会有读者疑惑于“命令式语言中的方法和声明式的‘做什么’有什么区别”，但鲜见讨论函数式编程的书对此做过解释。\n让我们再来回顾命令式和声明式所关注的点。\n命令式是基于计算机硬件接收并执行指令的层层抽象，关心的是如何逐步发送指令完成对程序的构造。 声明式则最初被定义为非命令式，人们不关心功能如何实现，而是关心功能是什么。这种思潮衍生的极致便是 DSL（领域特定语言）。 倘若存在一个神奇的编译器，可以编译人类日常交流的自然语言。那么，你对他说“嘿！哥们。请先把标准输入流中的第一个和第二个数存起来，然后把他们加起来并编辑成音频，最后向外播放这个音频”，何尝不也是一种命令式呢。\n如果你需要的是声明式语言，请这么说“我需要一个软件，它可以接收用户输入的前两个数，然后用音频输出他们的和，今天下午给我”。笑）\n现在，问题的答案已经呼之欲出了。命令式语言中的方法仍然是指令的体现，无论其是否由你实现。命令式关心的是实现的细节，而声明式关心的是需要实现什么。\n也正如此，两种范式并不于客观上泾渭分明，现在越来越多的编程语言都朝着混合范式的方向发展，我们所使用的 C# 正是其中的佼佼者。\n相同的设计原则#\r或许你已经为之发愁过了，命令式程序员并非未曾意识到状态突变带来的危险，他们会使用锁，或是控制尽可能少的状态更新入口来维持程序的稳定运行。同样的，他们也会使用事件和回调来优化流程控制。\n我说这些并非期望给读者带来“命令式没有函数式编程靠谱”的想法，恰恰相反，我想强调的是：无论哪种范式，在构建或大或小的精妙系统时，我们都遵循着同样的设计原则。\n或许你听过诸如单一职责（single responsibility），高内聚低耦合（loose coupling high cohesion），DRY（don\u0026rsquo;t repeat yourself）一类的词汇，我们不会在这里展开他们，只是希望至少这些词汇能给你带来些安心感。\n什么是函数式编程#\r函数式编程中，程序的构建基于 lambda 演算的组合，应用和归约。\n想象一个只有两侧开口的盒子，你向一侧放入些值，然后可以在另一侧取出一个新值，在此过程中，你并不知道这个盒子是如何运作的，好在你也并不需要知道。这指向了函数式编程中的一个特性：不可变性。确切的说，lambda 演算中没有状态，每一次从盒子里取出的东西都是全新的。不过作为图灵完备者，FP 也可以利用 lambda 演算去模拟状态, 我们会在有状态计算一章中去详细介绍。\n还是那个盒子，这次你没有给它塞值，而是将另一个盒子塞了进去，令人惊奇的是，另一端出现了一个全新的盒子。我们通常管这种可以产生盒子的盒子叫做高阶函数。\n就这样，你可以把这些盒子和值层层嵌套，最后你会得到一个终极的盒子，他就是你所期望构造的程序。当然，因为他本质上仍然是个盒子——我们现在开始叫他函数吧，所以你可以把它当作一个即插即用的组件，插入到任何一个符合规范的另一个函数(程序)中。\n如果你这么做了，恭喜你，你已经开始实践函数式编程了。在使用函数设计精妙的应用程序之前，我们还需要掌握一些基础知识。\n"},{"id":1,"href":"/docs/archive_posts/eventbus/","title":"Eventbus","section":"Archive Posts","content":"EventBus 设计分享#\r回顾原理#\r无论事件总线支持怎样的拓展功能，内部实现怎样优雅，其设计基本上还是基于发布-订阅模型。\n该模型总是包含用于存贮消息映射到回调的数据集合，事件的分发方法，事件的订阅和取消订阅方法。（以下的事件总线，事件系统，事件中心皆指该模型的实际实现）\n发布订阅模型可以轻松支持事件广播，即单一的消息发布者可以把消息传递给多个关心其发送的消息的听众，这些听众会在监听到自己关心的消息时做出相对应的反应。\n在类的依赖关系中，听众和消息发布者都无需关心对方，他们共同依赖事件模块而不是相互耦合。优点是利于代码的维护，复用。这也遵循了迪米特法则。 下面举一个例子来对比接入事件总线前后类的依赖关系\npublic class VTuber { private readonly List\u0026lt;Fans\u0026gt; fansList; public VTuber(List\u0026lt;Fans\u0026gt; fansList) { this.fansList = fansList; } public void Sing() { fansList.ForEach(fans =\u0026gt; fans.OnVTuberSing()); } } public class Fans { public readonly Action OnVTuberSing; protected Fans(Action onVTuberSing) { OnVTuberSing = onVTuberSing; } }上面的代码描述了在 VTuber 唱歌后 Fans 表态的场景。VTuber 不得不了解其所有的粉丝，并在唱歌后逐一通知他们。然而，VTuber 和 Fans 紧密耦合在了一起，只要有一个缺失或者发生更改，代码就无法通过编译或必须紧跟着更新另一个类。\n当不止粉丝来关心 VTuber 的时候，事情就变得更加复杂了。VTuber 必须了解关注 ta 的所有人：粉丝、网警、平台、乐子人，以便在自己有所举动时他们能发出正常的反馈——这很可笑不是吗？哪怕以显示的眼光去看，依赖关系也完全倒置了。事实上是后者关心前者，前者往往完全不了解后者，甚至不清楚后者的存在。 或许熟悉抽象的你已经有了相对应的优化思路，但不要着急，我们再来看看事件总线介入后的局面。\npublic class VTuber { public void Sing() { EventCenter.Instance.PublishEvent(\u0026#34;Sing\u0026#34;); } } public class Fans { private readonly Action onVTuberSing; protected Fans(Action onVTuberSing) { this.onVTuberSing = onVTuberSing; EventCenter.Instance.RegisterEvent(\u0026#34;Sing\u0026#34;, onVTuberSing); } ~Fans() { EventCenter.Instance.UnregisterEvent(\u0026#34;Sing\u0026#34;, onVTuberSing); } }现在 VTuber 完全不再关心关心 ta 的人，仅在 Sing 对外传递了消息，ta 并不关心这条消息会传递给谁。\nFans 仍然关注于 Sing 消息本身。实际上，原本 Fans 就不是关注 VTuber，而是关心 Sing 消息。对于 Sing 这条消息，有些人会商检，有些人会置之不理，有些人会关心其歌词是否涉政涉黄。\n从整体来看，VTuber 和 Fans 再也不是不可分割的。虽然代码中引入了新的模块，并且让原本的两者都依赖于这个模块，但从代码的可维护性和可复用性上来看，仍然是一个进步。再者，实际开发中的业务模型不会像示例中的这么简单，消息的发布者和订阅者都不止一个，其关心的消息和二者本身也都被要求是可轻松拓展的。\n在引入消息模块之前，或许会有人想到可以利用接口抽象消息的发布者（VTuber 一类）和消息的订阅者（Fans 一类）。从而可以消弭业务对象过多导致消息的发布者成员数量爆炸。\npublic interface IDispatcher { public List\u0026lt;ISubscriber\u0026gt; Subscribers { get; } void DoSth(); } public class VTuber : IDispatcher { public VTuber(List\u0026lt;ISubscriber\u0026gt; subscribers) { Subscribers = subscribers; } public List\u0026lt;ISubscriber\u0026gt; Subscribers { get; } public void DoSth() { Subscribers.ForEach(suber =\u0026gt; suber.OnDoSth()); } } public interface ISubscriber { public Action OnDoSth { get; } } public class Fans : ISubscriber { public Fans(Action onDoSth) { OnDoSth = onDoSth; } public Action OnDoSth { get; } }在这个实现中，我们让事件的发布者去关心订阅者的抽象集合。我们无需担心关注者过多的问题了，但是仍然存在问题，我们默认事件的发布者都只去做一件事，VTuber 只去唱歌，游戏博主只发教程视频，广播只会播放眼保健操。显然，在这种实现下，当我们想让发布者去做更多事情的时候，我们就只能增加 DoSth 的数量，相对的每一个关注者都要添加一个 OnDoSthN。相信没有人愿意去堆砌这样的矢山。\n前面我们说过，订阅者关注的是消息本身，而消息的数量和传递的信息都是未知的。显然，面对这样的情况，我们更需要一个方法接收消息并注入面对该消息的回调，而不是为每一个潜在的消息编写 Action。我们可以使用一个\u0026lt;String，Action\u0026gt;的字典来存贮注入的消息和处理方法。\npublic interface IDispatcher { public List\u0026lt;ISubscriber\u0026gt; Subscribers { get; } void Dispatch(string eventName); } public class VTuber : IDispatcher { public VTuber(List\u0026lt;ISubscriber\u0026gt; subscribers) { Subscribers = subscribers; } public List\u0026lt;ISubscriber\u0026gt; Subscribers { get; } public void Dispatch(string eventName) { foreach (var subscriber in Subscribers) { subscriber.EventDict[eventName].Invoke(); } } } public interface ISubscriber { Dictionary\u0026lt;string, Action\u0026gt; EventDict { get; } void Subscribe(string eventName, Action action); void Unsubscribe(string eventName, Action action); } public class Fans : ISubscriber { public Fans(Dictionary\u0026lt;string, Action\u0026gt; eventDict) { EventDict = eventDict; } public Dictionary\u0026lt;string, Action\u0026gt; EventDict { get; } public void Subscribe(string eventName, Action action) { EventDict[eventName] += action; } public void Unsubscribe(string eventName, Action action) { EventDict[eventName] -= action; } }在这个模型下，消息的两端都依赖于抽象，订阅者从构造函数或订阅方法中注入了其关心的事件和处理方法的集合，而发布者关心订阅者的抽象，并在消息发布时遍历他们的事件集合。一切看似很美好，问题在于，就像上面说过的，消息的发布者往往不清楚，甚至完全不了解消息的订阅者。然而要是在消息的订阅者处向消息的发布者注入自己的话，又违背了关心消息本身而不关心消息的发布者的原则。\n一个简单的处理办法是建立一个中介（第三者），来存放消息到处理方法的映射表的合集。所有订阅者都把自己的 eventDict 存在那里。消息的发布者在发布时去访问这个统一的字典，这样就避免了“关心关心 ta 的人”的麻烦。 好的，到这里，恭喜你重新回到了发布订阅模型。\n事实上，你只要把消息发布者遍历统一字典的这一步封装起来放到中介类里（为了维护 DoSth 的单一职责），你就立刻拥有了一个通用且简单的发布订阅模型。\nCodeList#\r可以先跳过这一节，往下看。\nEventCenter#\rusing System; using System.Collections.Generic; using Framework.Utility.ClassTemplate.Singleton; using Sirenix.OdinInspector; namespace Framework.EventSystem { public class EventCenter : EagerSingleton\u0026lt;EventCenter\u0026gt; { [ShowInInspector] private readonly Dictionary\u0026lt;string, List\u0026lt;Action\u0026gt;\u0026gt; eventDict = new(32); private readonly List\u0026lt;string\u0026gt; eventCacheDict = new(16); private readonly Dictionary\u0026lt;string, Action\u0026lt;object[]\u0026gt;[]\u0026gt; parametricEventDict = new(32); #region 注册事件 public void RegisterEvent(string eventName, Action action) { if (!eventDict.ContainsKey(eventName)) { eventDict[eventName] = new List\u0026lt;Action\u0026gt;(); } eventDict[eventName].Add(action); } public void RegisterEvent(string eventName, Action\u0026lt;object[]\u0026gt; action) { if (!parametricEventDict.ContainsKey(eventName)) { parametricEventDict[eventName] = new Action\u0026lt;object[]\u0026gt;[32]; } var value = parametricEventDict[eventName]; for (var i = 0; i \u0026lt; value.Length; i++) { if (value[i] == null) { value[i] = action; break; } } } #endregion #region 取消注册事件 public void UnregisterEvent(string eventName, Action action) { if (!eventDict.TryGetValue(eventName, out var value)) { return; } value.Remove(action); } public void UnregisterEvent(string eventName, Action\u0026lt;object[]\u0026gt; action) { if (!parametricEventDict.TryGetValue(eventName, out var value)) { return; } for (var i = 0; i \u0026lt; value.Length; i++) { if (value[i] == action) { value[i] = null; break; } } } public void UnregisterEvent(string eventName) { if (!eventDict.TryGetValue(eventName, out var value)) { return; } value.Clear(); } public void UnregisterAllEvent() { eventDict.Clear(); } #endregion #region 分发事件 public void PublishEvent(string eventName, bool addToCache = false) { if (addToCache) { eventCacheDict.Add(eventName); return; } if (!eventDict.TryGetValue(eventName, out var value)) { return; } foreach (var action in value) { action(); } } public void PublishEvent(string eventName, object[] args, bool addToCache = false) { if (addToCache) { eventCacheDict.Add(eventName); return; } if (!parametricEventDict.TryGetValue(eventName, out var value)) { return; } foreach (var action in value) { action?.Invoke(args); } } #endregion #region 延迟分发事件 public void PublishCache(string eventName) { if (!eventCacheDict.Contains(eventName)) { return; } PublishEvent(eventName); eventCacheDict.Remove(eventName); } #endregion } }IEventRegister#\rnamespace Framework.EventSystem { public interface IEventRegister { public void Register(object obj); public void Unregister(object obj); } }AnnotatedEventRegistrar#\rusing Framework.EventSystem.Attr; namespace Framework.EventSystem { public class AnnotatedEventRegistrar : IEventRegister { protected AnnotatedEventRegistrar() { Register(this); } ~AnnotatedEventRegistrar() { Unregister(this); } public void Register(object obj) { EventManager.Instance.RegisterEventHandler(obj); } public void Unregister(object obj) { EventManager.Instance.UnregisterEventHandler(obj); } } }UnityAnnotatedEventRegistrar#\rusing Framework.EventSystem.Attr; using UnityEngine; namespace Framework.EventSystem { public class UnityAnnotatedEventRegistrar : MonoBehaviour, IEventRegister { public void Register(object obj) { EventManager.Instance.RegisterEventHandler(obj); } public void Unregister(object obj) { EventManager.Instance.UnregisterEventHandler(obj); } public virtual void Start() { Register(this); } public virtual void OnDestroy() { Unregister(this); } } }EventAttribute#\rusing System; namespace Framework.EventSystem.Attr { /// \u0026lt;summary\u0026gt; /// 标记事件的提供者 /// \u0026lt;/summary\u0026gt; [AttributeUsage(AttributeTargets.Method)] public class EventAttribute : Attribute { public string EventName { get; } public EventAttribute(string eventName) { EventName = eventName; } } }EventManager#\rusing System; using System.Collections.Generic; using System.Reflection; using Framework.LambdaExt; using Framework.Utility.ClassTemplate.Singleton; using UnityEngine; namespace Framework.EventSystem.Attr { public class EventManager : EagerSingleton\u0026lt;EventManager\u0026gt; { private readonly Dictionary\u0026lt;string, List\u0026lt;Action\u0026gt;\u0026gt; actionDict = new Dictionary\u0026lt;string, List\u0026lt;Action\u0026gt;\u0026gt;(); private readonly Dictionary\u0026lt;string, List\u0026lt;Action\u0026lt;object[]\u0026gt;\u0026gt;\u0026gt; parametricActionDict = new Dictionary\u0026lt;string, List\u0026lt;Action\u0026lt;object[]\u0026gt;\u0026gt;\u0026gt;(); private void HandleEventOnRegister(object obj) { var classType = obj.GetType(); var methods = classType.GetMethods(); foreach (var method in methods) { var eventAttributes = method.GetCustomAttribute(typeof(EventAttribute), false); if (eventAttributes == null) { continue; } var eventAttribute = (EventAttribute)eventAttributes; var parms = method.GetParameters(); foreach (var info in parms) { Debug.Log($\u0026#34;存在参数{info.Name}，类型为{info.ParameterType}\u0026#34;); } if (parms.Length == 0) { var action = method.CreateDelegate(typeof(Action), obj) as Action; if (!actionDict.TryGetValue(eventAttribute.EventName, out var value)) { actionDict[eventAttribute.EventName] = new List\u0026lt;Action\u0026gt;(); } else { value.Add(action); } var eventName = eventAttribute.EventName; EventCenter.Instance.RegisterEvent(eventName, action); } else { var action = method.ToAction(obj); if (parametricActionDict.TryGetValue(eventAttribute.EventName, out var value)) { value.Add(action); } else { parametricActionDict[eventAttribute.EventName] = new List\u0026lt;Action\u0026lt;object[]\u0026gt;\u0026gt; { action }; } EventCenter.Instance.RegisterEvent(eventAttribute.EventName, action); } } } private void HandleEventOnUnregister(object obj) { var classType = obj.GetType(); var methods = classType.GetMethods(); foreach (var method in methods) { var eventAttributes = method.GetCustomAttribute(typeof(EventAttribute), false); if (eventAttributes == null) { continue; } var eventAttribute = (EventAttribute)eventAttributes; var parms = method.GetParameters(); if (parms.Length == 0) { var action = method.CreateDelegate(typeof(Action), obj) as Action; if (actionDict.TryGetValue(eventAttribute.EventName, out var value)) { value.Remove(action); } var eventName = eventAttribute.EventName; EventCenter.Instance.UnregisterEvent(eventName, action); } else { var action = method.ToAction(obj); if (parametricActionDict.TryGetValue(eventAttribute.EventName, out var value)) { value.Remove(action); } EventCenter.Instance.UnregisterEvent(eventAttribute.EventName, action); } } } #region 处理签入的事件类 public void RegisterEventHandler(object obj) { HandleEventOnRegister(obj); } #endregion #region 处理签出的事件类 public void UnregisterEventHandler(object obj) { HandleEventOnUnregister(obj); } #endregion #region 声明周期 ~EventManager() { EventCenter.Instance.UnregisterAllEvent(); } #endregion } }HookAttribute#\rusing System; namespace Framework.Hook { [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property)] public class HookAttribute : Attribute { public readonly string MethodName; public HookAttribute(string methodName) { MethodName = methodName; } } }HookManager#\rusing System; using System.Collections.Generic; using System.Linq; using System.Reflection; using Framework.EventSystem; using Framework.LambdaExt; using Framework.Utility; using Framework.Utility.ClassTemplate.Singleton; using Sirenix.OdinInspector; using UnityEngine; using Object = UnityEngine.Object; namespace Framework.Hook { enum HookType { Field, Property } struct HookInfo { public string ChangeEventName; public FieldInfo FieldInfo; public PropertyInfo PropertyInfo; public object LastValue; public HookType HookType; public bool IsValueType; } public class HookManager : UnitySingleton\u0026lt;HookManager\u0026gt; { const BindingFlags k_BindingFlags = BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public; [ShowInInspector] private readonly Dictionary\u0026lt;object, List\u0026lt;HookInfo\u0026gt;\u0026gt; registry = new Dictionary\u0026lt;object, List\u0026lt;HookInfo\u0026gt;\u0026gt;(); [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)] // ReSharper disable once Unity.IncorrectMethodSignature protected override void Awake() { base.Awake(); DontDestroyOnLoad(gameObject); var hookables = FindObjectsByType\u0026lt;Object\u0026gt;(FindObjectsSortMode.InstanceID).Where(IsHookable); foreach (var hookable in hookables) { Register(hookable); } } void Register(Object obj) { var fields = obj.GetType().GetFields(k_BindingFlags) .Where(field =\u0026gt; Attribute.IsDefined(field, typeof(HookAttribute))); foreach (var field in fields) { var hook = field.GetCustomAttribute\u0026lt;HookAttribute\u0026gt;(); var hookMethodName = hook.MethodName; var hookMethod = obj.GetType().GetMethod(hookMethodName, k_BindingFlags); if (hookMethod == null) throw new Exception($\u0026#34;找不到{obj.GetType().Name}的方法{hookMethodName}\u0026#34;); if (hookMethod.GetParameters().Length == 0) throw new Exception($\u0026#34;方法{hookMethodName}必须有参数\u0026#34;); if (hookMethod.GetParameters()[0].ParameterType != field.FieldType) throw new Exception($\u0026#34;方法{hookMethodName}的参数类型必须与字段{field.Name}的类型一致\u0026#34;); var hookAction = hookMethod.ToAction(obj); var changeEventName = $\u0026#34;hook: {obj.GetType().Name}.{field.Name} change - {obj.GetInstanceID()}\u0026#34;; EventCenter.Instance.RegisterEvent(changeEventName, hookAction); var lastValue = ObjectTool.CraeteDeepCopyByJson(field.GetValue(obj)); var newHookInfo = new HookInfo { ChangeEventName = changeEventName, FieldInfo = field, LastValue = lastValue, HookType = HookType.Field, IsValueType = field.FieldType.IsValueType }; if (registry.ContainsKey(obj)) { if (registry[obj].Any(info =\u0026gt; info.FieldInfo == field)) throw new Exception($\u0026#34;已经存在{obj.GetType().Name}的字段{field.Name}的钩子\u0026#34;); registry[obj].Add(newHookInfo); } else { registry.Add(obj, new List\u0026lt;HookInfo\u0026gt; { newHookInfo }); } } var properties = obj.GetType().GetProperties(k_BindingFlags) .Where(property =\u0026gt; Attribute.IsDefined(property, typeof(HookAttribute))); foreach (var property in properties) { var hook = property.GetCustomAttribute\u0026lt;HookAttribute\u0026gt;(); var hookMethodName = hook.MethodName; var hookMethod = obj.GetType().GetMethod(hookMethodName, k_BindingFlags); if (hookMethod == null) throw new Exception($\u0026#34;找不到{obj.GetType().Name}的方法{hookMethodName}\u0026#34;); if (hookMethod.GetParameters().Length == 0) throw new Exception($\u0026#34;方法{hookMethodName}必须有参数\u0026#34;); if (hookMethod.GetParameters()[0].ParameterType != property.PropertyType) throw new Exception($\u0026#34;方法{hookMethodName}的参数类型必须与属性{property.Name}的类型一致\u0026#34;); var hookAction = hookMethod.ToAction(obj); var changeEventName = $\u0026#34;hook: {obj.GetType().Name}.{property.Name} change - {obj.GetInstanceID()}\u0026#34;; EventCenter.Instance.RegisterEvent(changeEventName, hookAction); var lastValue = ObjectTool.CraeteDeepCopyByJson(property.GetValue(obj)); var newHookInfo = new HookInfo { ChangeEventName = changeEventName, PropertyInfo = property, LastValue = lastValue, HookType = HookType.Property, IsValueType = property.PropertyType.IsValueType }; if (registry.ContainsKey(obj)) { if (registry[obj].Any(info =\u0026gt; info.PropertyInfo == property)) throw new Exception($\u0026#34;已经存在{obj.GetType().Name}的属性{property.Name}的钩子\u0026#34;); registry[obj].Add(newHookInfo); } else { registry.Add(obj, new List\u0026lt;HookInfo\u0026gt; { newHookInfo }); } } } static bool IsHookable(object obj) { return obj.GetType().GetMembers(k_BindingFlags) .Any(member =\u0026gt; Attribute.IsDefined(member, typeof(HookAttribute))); } private void Update() { foreach (var (obj, hookInfos) in registry) { for (int i = 0; i \u0026lt; hookInfos.Count; i++) { var info = hookInfos[i]; var newValue = info.HookType == HookType.Field ? info.FieldInfo.GetValue(obj) : info.PropertyInfo.GetValue(obj); if (info.LastValue == null \u0026amp;\u0026amp; newValue == null) continue; if (newValue == null) continue; info.LastValue ??= info.IsValueType ? newValue : ObjectTool.CraeteDeepCopyByJson(newValue); if (!info.LastValue.Equals(newValue)) { EventCenter.Instance.PublishEvent(info.ChangeEventName, new[] { newValue }); info.LastValue = info.IsValueType ? newValue : ObjectTool.CraeteDeepCopyByJson(newValue); } hookInfos[i] = info; } } } } }含参广播#\r原理到此为止，我们已经从依赖倒置的思路推演出了发布订阅模型。不过我们实现的只是一个“不含参的广播”，换言之在 C#的实现层面上，我们只能向订阅者传递一个 String 类型的消息。（实现来看，是订阅者向中介注入了自己关心的消息和处理方法的集合，在发布者发布事件时，中介会检索消息并调用其映射的所有回调方法。这个回调方法目前是无参的。含义上来看，可以认为消息是从发布者流向订阅者的，但要明确的是，无论是发布者还是订阅者，都只关心消息而非对方）\nusing System; using System.Collections.Generic; using Framework.Utility.ClassTemplate.Singleton; using Sirenix.OdinInspector; namespace Framework.EventSystem { public class EventCenter : EagerSingleton\u0026lt;EventCenter\u0026gt; { private readonly Dictionary\u0026lt;string, List\u0026lt;Action\u0026gt;\u0026gt; eventDict = new(32); #region 注册事件 public void RegisterEvent(string eventName, Action action) { if (!eventDict.ContainsKey(eventName)) { eventDict[eventName] = new List\u0026lt;Action\u0026gt;(); } eventDict[eventName].Add(action); } #endregion #region 取消注册事件 public void UnregisterEvent(string eventName, Action action) { if (!eventDict.TryGetValue(eventName, out var value)) { return; } value.Remove(action); } public void UnregisterEvent(string eventName) { if (!eventDict.TryGetValue(eventName, out var value)) { return; } value.Clear(); } public void UnregisterAllEvent() { eventDict.Clear(); } #endregion #region 分发事件 public void PublishEvent(string eventName) { if (!eventDict.TryGetValue(eventName, out var value)) { return; } foreach (var action in value) { action(); } } #endregion } }当理解了消息映射的回调方法的调用原理后，我们很自然可以想到 Action 的调用是可以传参的。我们可以额外建立一个 String 映射到 Action\u0026lt;object[]\u0026gt; 的合集，在 C# 中可以表现为一个字典。\nprivate readonly Dictionary\u0026lt;string, Action\u0026lt;object[]\u0026gt;[]\u0026gt; parametricEventDict = new(32);通过重载 RegisterEvent，我们可以期待一个 Action\u0026lt;object[]\u0026gt;，同时在分发事件时注入其所需的参数（需要重载 PublishEvent） 在此过程，不可避免的会引发因为类型转换导致的装箱。如何优化这一点留给读者和笔者思考和探索。 最后实现如下：\nnamespace Framework.EventSystem { public class EventCenter : EagerSingleton\u0026lt;EventCenter\u0026gt; { ... private readonly Dictionary\u0026lt;string, Action\u0026lt;object[]\u0026gt;[]\u0026gt; parametricEventDict = new(32); #region 注册事件 ... public void RegisterEvent(string eventName, Action\u0026lt;object[]\u0026gt; action) { if (!parametricEventDict.ContainsKey(eventName)) { parametricEventDict[eventName] = new Action\u0026lt;object[]\u0026gt;[32]; } var value = parametricEventDict[eventName]; for (var i = 0; i \u0026lt; value.Length; i++) { if (value[i] == null) { value[i] = action; break; } } } #endregion #region 取消注册事件 ... public void UnregisterEvent(string eventName, Action\u0026lt;object[]\u0026gt; action) { if (!parametricEventDict.TryGetValue(eventName, out var value)) { return; } for (var i = 0; i \u0026lt; value.Length; i++) { if (value[i] == action) { value[i] = null; break; } } } ... #endregion #region 分发事件 ... public void PublishEvent(string eventName, object[] args) { if (!parametricEventDict.TryGetValue(eventName, out var value)) { return; } foreach (var action in value) { action?.Invoke(args); } } #endregion } }延迟分发#\r考虑一个业务场景，你制作了一个任务面板，当玩家完成某项任务时，该面板上对应的任务条目会闪光。很幸运，应用了事件系统后，你能很轻松的让任务系统传递一个某任务完成的信号，监听他的 UI 面板在收到消息的同时忠诚的执行了闪光任务。问题在于，这一切都发生在一瞬间，如果你不想让任务面板探到玩家脸上的话，就要考虑闪光任务是否应该在任务完成的一瞬间就被执行。 延迟分发给出了一种解决思路。\n任务系统会照常分发消息，只不过对于某些不需要立刻分发的任务，他会打上一个延迟分发的 Tag，这些被打上延迟分发 Tag 的消息不会进入常规的事件集合，而是会被投入一个缓存集合。当玩家主动打开任务面板时，一个期待消息参数的缓存清理方法将会被调用，指向性的释放与当前传入详细匹配的键值对，并调用其回调方法。\nnamespace Framework.EventSystem { public class EventCenter : EagerSingleton\u0026lt;EventCenter\u0026gt; { ... private readonly List\u0026lt;string\u0026gt; eventCacheDict = new(16); ... #region 分发事件 public void PublishEvent(string eventName, bool addToCache = false) { if (addToCache) { eventCacheDict.Add(eventName); return; } if (!eventDict.TryGetValue(eventName, out var value)) { return; } foreach (var action in value) { action(); } } public void PublishEvent(string eventName, object[] args, bool addToCache = false) { if (addToCache) { eventCacheDict.Add(eventName); return; } if (!parametricEventDict.TryGetValue(eventName, out var value)) { return; } foreach (var action in value) { action?.Invoke(args); } } #endregion #region 延迟分发事件 public void PublishCache(string eventName) { if (!eventCacheDict.Contains(eventName)) { return; } PublishEvent(eventName); eventCacheDict.Remove(eventName); } #endregion } }使用 Attribute 快捷订阅消息#\r在确定一个实例需要在完整的生命周期保持对某个消息的订阅时，使用 C# 的 Attribute 是个看起来快捷且酷的选择。\n在我的实现中，原本这样的代码\nusing Framework.EventSystem; public class Enemy { private void Die() { } private Enemy() { EventCenter.Instance.RegisterEvent(\u0026#34;GameEnd\u0026#34;, Die); } ~Enemy() { EventCenter.Instance.UnregisterEvent(\u0026#34;GameEnd\u0026#34;, Die); } }可以简化为\nusing Framework.EventSystem; using Framework.EventSystem.Attr; public class Enemy : AnnotatedEventRegistrar { [Event(\u0026#34;GameEnd\u0026#34;)] public void Die() { } }甚至其还支持参数传递\npublic class Enemy : AnnotatedEventRegistrar { [Event(\u0026#34;GameEnd\u0026#34;)] public void Die() { } [Event(\u0026#34;GameStart\u0026#34;)] public void Born(Vector2 pos) { } }对一个继承自 AnnotatedEventRegistrar 或 UnityAnnotatedEventRegistrar 的类，其公开的非静态方法可以被 Event 修饰。\n实现原理#\rEventAttribute 帮助了我们实现了在构造函数/析构函数（Start/OnDestory）中自动注册/取消注册目标方法的功能，方便提高开发效率，也显著提高了代码的可读性（哪些方法会响应分发的消息一目了然）。\n父类 AnnotatedEventRegistrar 会在构造函数中将自身的引用传递给 EventManager，EventManager 会通过反射遍历传入引用类型的所有公开非静态方法，并找出其中所有被 EventAttribute 修饰的方法。这些方法会和传入的实例的引用构造成 Action 或 Action\u0026lt;object[]\u0026gt;。如果方法存在传入参数，就会构造后者。\n下面给出一种构造 Action\u0026lt;object[]\u0026gt; 的方法的实现\npublic static Action\u0026lt;object[]\u0026gt; ToAction(this MethodInfo methodInfo, object target) { // 参数: object[] var parameter = Expression.Parameter(typeof(object[]), \u0026#34;args\u0026#34;); // 创建方法参数表达式 var methodParameters = methodInfo.GetParameters(); var arguments = new Expression[methodParameters.Length]; for (int i = 0; i \u0026lt; methodParameters.Length; i++) { var index = Expression.Constant(i); var parameterType = methodParameters[i].ParameterType; var parameterAccessor = Expression.ArrayIndex(parameter, index); var parameterCast = Expression.Convert(parameterAccessor, parameterType); arguments[i] = parameterCast; } // 创建实例表达式 var instance = Expression.Constant(target); // 创建方法调用表达式 var methodCall = Expression.Call(instance, methodInfo, arguments); // 创建并编译 lambda 表达式 var lambda = Expression.Lambda\u0026lt;Action\u0026lt;object[]\u0026gt;\u0026gt;(methodCall, parameter); return lambda.Compile(); }构造出的委托会和方法名一起注册进事件系统，并存入 EventManager 自己管理的事件字典中。当需要签出事件时，会将字典中的委托和新构造委托进行比对，相同的委托将会被撤销在事件系统中的注册，并被移出事件字典。\n对于需要在 Unity 运行的部分，基于已经完成的实现，可以将原本处于 Start 和 OnDestory 的自动订阅机制拓展到所有 MonoBehavior 生命周期函数上。 一个简单的实现是\n为 EventAttribute 加入记录调用时期的字段，可以是枚举类型的。 把 UnityAnnotatedEventRegistrar 上的自动注册撤销方法拓展到所有目标回调上。 重载 EventManager 的签入签出方法或重构加入一个输入参数做回调时机的验证（匹配当前传入的回调类型和 EventAttribute 记录的回调类型） 基于 EventBus 实现的类 Hook 方法#\r可以使用 HookAttribute 快速实现单向数据绑定，对于继承自 UnityEngine.Object 且非动态生成的实例中标记了 [Hook] 的字段或属性，其变化将会引起同类中参数列表仅为与其类型相同的一个参数的且方法名与注入其的字符串相匹配的非静态方法被调用，可以使用 nameof 优化字符串表现。\n下面是一个用例\npublic class CardState { public int Health; public CardState() { Health = 0; } } public class CardDisplay : MonoBehaviour { public CardState State; [Hook(nameof(RenderHealth))] public int Health =\u0026gt; State?.Health ?? 0; [SerializeField] private TextMeshProUGUI healthText; private void Start() { State = new CardState(); } private void Update() // 模拟数据更新 { if (Input.GetKeyDown(KeyCode.A)) State.Health++; } public void RenderHealth(int newInput) =\u0026gt; healthText.text = newInput.ToString(); }当 Health 发生变化时，RenderHealth() 将会被调用。 HookAttribute 可修饰的字段或属性的类型包括基本类型， class， struct。 实现原理\nHookManager 需要挂载在场景中，其入口函数 Awake 由于 [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)] 的修饰能够确保在场景加载前调用。 程序会检索所有存在成员被 HookAttribute 修饰的 Unity 实例，并将其注册进一个字典。改字典存贮了实例到其被 HookAttribute 修饰成员与其对应的方法构造的 HookInfo。\nstruct HookInfo { public string ChangeEventName; public FieldInfo FieldInfo; public PropertyInfo PropertyInfo; public object LastValue; public HookType HookType; public bool IsValueType; }其中被引用的方法会和被修饰的成员和实例的一同构造事件名和事件回调，他们会被注册进事件中心。\nHookInfo 记录了字段/属性的信息，结合作为键的实例对象，我们就可以获得目标成员的最新值。\nvar newValue = info.HookType == HookType.Field ? info.FieldInfo.GetValue(obj) : info.PropertyInfo.GetValue(obj);对于值类型，我们会和 HookInfo 中存贮的旧值进行比对，如果不同，HookInfo 中的旧值将会被更新，注册的事件也会被发布。\n对于引用类型，我们会创建目标成员的深拷贝与旧值进行比对，后续流程与对值类型进行的操作类似。\n在这里，我采用了 Unity 的 Json 序列化器辅助创建了对象的深拷贝。当然，我们也可以使用反射完成这件事情。\n下面给出深拷贝的创建代码\npublic static object CraeteDeepCopyByJson(object input) { if (input == null) { return null; } var json = JsonUtility.ToJson(input); return JsonUtility.FromJson(json, input.GetType()); }Hook 的事件仅作思路验证，可以在此基础上拓展对 System.Object 的支持和在 HookManager 入口方法之后生成的实例的支持。同时，被销毁的对象也需要被 HookManager 从 registry 中移除。\n"},{"id":2,"href":"/docs/archive_posts/creational_patterns/","title":"Creational Patterns","section":"Archive Posts","content":"\r本文为 2024 年寒假 SAST 游戏组 WOC 授课资料留档\n抽象了实例化过程。\n接口，抽象类 new() 工厂方法 Factory Method#\r工厂方法的意图#\r定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。\n具体实现#\r如果不用工厂方法,我们如何实现?\npublic class Wand//产品 { public string Name { get; set; } } public class FireWand : Wand { public FireWand() { Name = \u0026#34;Fire Wand\u0026#34;; } } public class IceWand : Wand { public IceWand() { Name = \u0026#34;Ice Wand\u0026#34;; } } int main()//实例化,客户端,调用者 { var fireWand = new FireWand(); var iceWand = new IceWand(); }如果我们需要一个新的魔杖,我们需要实现一个新的魔杖类,然后实现一个新的方法,这样就会导致类的爆炸。\n如果某一个魔杖需要求修改,那么需要全局搜索,修改所有的地方。\n如果我们使用工厂方法,我们可以这样实现:\nswtich case (简单工厂)#\rpublic enum WandType { Fire, Ice } public class Wand { public string Name { get; set; } } public class WandFactory { public Wand CreateWand(WandType type)//if else { switch (type) { case WandType.Fire: return new Wand { Name = \u0026#34;Fire Wand\u0026#34; }; case WandType.Ice: return new Wand { Name = \u0026#34;Ice Wand\u0026#34; }; default://缺省:默认 throw new ArgumentOutOfRangeException(nameof(type), type, null); } } } int main() { var factory = new WandFactory(); var fireWand = factory.CreateWand(WandType.Fire); var iceWand = factory.CreateWand(WandType.Ice); }降低了客户端(调用者)和具体产品类的耦合度。然而违背了开闭原则,如果我们需要增加一个新的魔杖,我们需要修改工厂类。\n泛型类#\rpublic enum WandType { Fire, Ice } public class Wand { protected string Name { get; set; } = \u0026#34;Wand\u0026#34;; } public class FireWand : Wand { public FireWand() { Name = \u0026#34;Fire Wand\u0026#34;; Console.WriteLine(\u0026#34;生产了\u0026#34;+Name); } } public class IceWand : Wand { public IceWand() { Name = \u0026#34;Ice Wand\u0026#34;; Console.WriteLine(\u0026#34;生产了\u0026#34;+Name); } } public class WandFactory\u0026lt;T\u0026gt; where T : Wand, new() { public T CreateWand() { return new T(); } } public class Program { public static void Main(string[] args) { var iceWandFactory = new WandFactory\u0026lt;IceWand\u0026gt;(); var wand = iceWandFactory.CreateWand(); var fireWandFactory = new WandFactory\u0026lt;FireWand\u0026gt;(); var wand2 = fireWandFactory.CreateWand(); } }可以使用 where : Wand, new() 来限制泛型类型。\ntips: new() 限制泛型类型必须有无参构造函数。\n泛型方法#\rinterface IWandFactoryMethod { Wand CreateWand\u0026lt;T\u0026gt;() where T : Wand, new(); } public class WandFactory : IWandFactoryMethod//落实 { public Wand CreateWand\u0026lt;T\u0026gt;() where T : Wand, new() { return new T(); } } public class Program { public static void Main(string[] args) { var wandFactory = new WandFactory(); var wand = wandFactory.CreateWand\u0026lt;IceWand\u0026gt;(); var wand2 = wandFactory.CreateWand\u0026lt;FireWand\u0026gt;(); } }三点好处:\n拥有工厂接口 可以限制传入产品,并且在编译期间就可以发现 免去 switch case 的判断 抽象工厂 Abstract Factory#\r抽象工厂的意图#\r提供一个接口,用于创建相关或依赖对象的家族,而不需要明确指定具体类。\n具体实现#\r抽象工厂 具体工厂 抽象产品 具体产品 public enum magicType { Fire, Ice } public abstract class Wand { protected string Name { get; set; } = \u0026#34;Wand\u0026#34;; } public abstract class Sword { protected string Name { get; set; } = \u0026#34;Sword\u0026#34;; } public class FireSword : Sword { public FireSword() { Name = \u0026#34;Fire Sword\u0026#34;; Console.WriteLine(\u0026#34;生产了\u0026#34;+Name); } } public class IceSword : Sword { public IceSword() { Name = \u0026#34;Ice Sword\u0026#34;; Console.WriteLine(\u0026#34;生产了\u0026#34;+Name); } } public class FireWand : Wand { public FireWand() { Name = \u0026#34;Fire Wand\u0026#34;; Console.WriteLine(\u0026#34;生产了\u0026#34;+Name); } } public class IceWand : Wand { public IceWand() { Name = \u0026#34;Ice Wand\u0026#34;; Console.WriteLine(\u0026#34;生产了\u0026#34;+Name); } } public abstract class AbstractFactory { public abstract Wand CreateWand(); public abstract Sword CreateSword(); } public class FireFactory : AbstractFactory { public override Wand CreateWand() { return new FireWand(); } public override Sword CreateSword() { return new FireSword(); } } public class IceFactory : AbstractFactory { public override Wand CreateWand() { return new IceWand(); } public override Sword CreateSword() { return new IceSword(); } } public class Program { static void Main(string[] args) { AbstractFactory factory = new FireFactory(); factory.CreateSword(); factory.CreateWand(); } }缺点#\r如果我们需要增加一个新的产品,比如 Shield,那么我们需要修改 AbstractFactory,这样就违背了开闭原则。\n工厂方法的非单例实现#\r静态类和静态方法\n参考是在设计模式与完美游戏开发的 201-202 页\n生成器 Builder#\r生成器的意图#\r将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示。\n当一个类的构造函数参数个数超过 4 个,而且这些参数有些是可选的参数,考虑使用构造者模式。\n流程分析安排 Director\n功能分开实现 Builder\n流水线,流程分析\n同样的流程,每一步做不一样的事情,结果也不同\n生成器的具体实现#\rpublic class Potion { private List\u0026lt;string\u0026gt; parts = new List\u0026lt;string\u0026gt;();//对接口 public Potion(){} public void Add(string part) { parts.Add(part); } public void Show() { Console.WriteLine(\u0026#34;\\nPotion completed as below :\u0026#34;); foreach (string part in parts) Console.WriteLine(part); } } public class Director//流程分析安排 { private Potion potion; public Director(){} public void Construct(Builder theBuilder)///组装 { potion = new Potion(); theBuilder.BuildPartA(potion); theBuilder.BuildPartB(potion); theBuilder.BuildPartC(potion); potion = GetProduct(); } public Potion GetProduct() { return potion; } } public abstract class Builder//实现功能 { public abstract void BuildPartA(Object part); public abstract void BuildPartB(Object part); public abstract void BuildPartC(Object part); } public class PotionBuilder : Builder { public override void BuildPartA(Object product) { (product as Potion).Add(\u0026#34;瓶子\u0026#34;); } public override void BuildPartB(Object product) { (product as Potion).Add(\u0026#34;水\u0026#34;); } public override void BuildPartC(Object product) { (product as Potion).Add(\u0026#34;药剂\u0026#34;); } } public class Program { public static void Main(string[] args) { Director director = new Director(); Potion product = null; Builder builder = new PotionBuilder(); director.Construct(builder); product = director.GetProduct(); product.Show(); } }单例 Singleton#\r单例的意图#\r提供一个全局访问点来获取唯一的实例。\n也即其使用的范围 -\u0026gt; 全局 + 唯一的\n单例的具体实现#\rpublic class Singleton { private static Singleton _instance; private Singleton() { } public static Singleton GetInstance() { if (_instance == null) { _instance = new Singleton(); } return _instance; } } public class Foo { public static Foo instance { get; } = new Foo(); }Unity 中的单例值得注意的点 =\u0026gt; monobeheviour#\rpublic class GameManager : MonoBehaviour { public static GameManager Instance; private void Awake() { Instance = this;//不要 new 一个新的 否则 丢失引用 } }单例模板#\rpublic class Singleton\u0026lt;T\u0026gt; where T : new() { private static T _instance; private static readonly object _lock = new object(); protected Singleton() { } public static T GetInstance() { if (_instance == null) { lock (_lock) { if (_instance == null) { _instance = new T(); } } } return _instance; } }参考#\r【Sast C# Class 4.1 泛型-类型系统的万金油\n"},{"id":3,"href":"/docs/archive_posts/oo_design/","title":"聊聊面向对象和其设计原则","section":"Archive Posts","content":"\r本文为 2024 年寒假 SAST 游戏组 WOC 授课资料留档\n重温面向对象#\r封装：隐藏内部实现 继承：复用现有代码 多态：改写对象行为 面向对象的目的#\r现实问题（复杂度） → 类 → 实例 (?)\nObject myObj = new Object();封装#\r假设你是军队指挥官，你手下统帅了数十种上万人的军队。当你命令部下向地方发起进攻的时候——\n你是会：\nA 营的小陆向前走三步，向你的 11 点钟方向射击 B 连的小宋向左转 35 度，前进 5 步，3 分钟瞄准时间，炮口倾角 15 度，开火 3 分钟 …… 还是会说：\nA 营向甲点缓慢推进 B 连火力掩护 “给老子啃下***高地（乐）” 显然，身为一军之长的你（作为最高层调用者）对军队中每个单位进行原子级微操是不合适的。军中各单位构成的复杂网络应当被抽象成高级命令。\nint main() { move(\u0026#34;小陆\u0026#34;, 3); fire(\u0026#34;小陆\u0026#34;, -30); rotate(\u0026#34;小宋\u0026#34;, -35); move(\u0026#34;小宋\u0026#34;, 5); artillery_fire(3, 15, 3); }对象化后：\npublic class Army { public enum AdvanceSpeed { Slow, Quick, Normal } public enum ArmyType { Infantry, Artillery } public void Advance(AdvanceSpeed speed, City targetPos) { ... } public void Shield(Army target) { ... } } int Main() { Army A = new Army(...); Army B = new Army(...); A.Advance(AdvanceSpeed.Normal, city_jia); B.Shield(A); }再上一个层级：\npublic class CollectiveArmy { List\u0026lt;Army\u0026gt; Armys = new List\u0026lt;Army\u0026gt;(); public void Attack(Area targetPos) { ... } } int Main() { CollectiveArmy collectiveArmy = new CollectiveArmy(...); collectiveArmy.Attack(area); }通过封装，我们并没有减少现实的复杂性，但让代码更易读、易扩展、易维护。\n代码是写给人看的。\n哪里能用到面向对象#\r面向对象真好使啊——那是不是啥都用 OOP呢？\n例如在“学生管理系统”这种简单逻辑的练习中，其实没必要搞太多类与接口。如果只是打印 \u0026quot;Hello World\u0026quot;，你不会先 class Person 然后 me.Talk(\u0026quot;Hello World\u0026quot;) 吧（笑）。\n面向对象适合复杂系统；面向过程适合时序逻辑。实际项目往往结合使用。\n他在这里合适才用他。 No Silver Bullet（没有银弹）\n面向对象的设计原则#\r单一责任原则#\r定义：\n一个类只允许有一个职责，即只有一个导致该类变更的原因。\n不仅是类，函数也应如此。\n不好的设计#\rpublic class CardDisplay : MonoBehaviour { public Card card; public TextMeshProUGUI nameText; public TextMeshProUGUI descriptionText; public TextMeshProUGUI attackText; public TextMeshProUGUI healthText; public Image artworkImage; void Start() { Draw(); } public void Draw() { nameText.text = card.name; descriptionText.text = card.description; attackText.text = card.attack.ToString(); healthText.text = card.health.ToString(); artworkImage.sprite = card.artwork; } public void ChangeCardHP(int hp) { card.health = hp; healthText.text = card.health.ToString(); } }更好的设计#\rpublic class CardDisplay : MonoBehaviour { public TextMeshProUGUI nameText; public TextMeshProUGUI descriptionText; public TextMeshProUGUI attackText; public TextMeshProUGUI healthText; public Image artworkImage; public void Draw(Card card) { nameText.text = card.name; descriptionText.text = card.description; attackText.text = card.attack.ToString(); healthText.text = card.health.ToString(); artworkImage.sprite = card.artwork; } public void ChangeHealthText(int amount) { healthText.text = amount.ToString(); } } public class CardController : MonoBehaviour { public Card card; public CardDisplay cardDisplay; void Start() { cardDisplay.Draw(card); } public void ChangeHealth(int amount) { card.health += amount; cardDisplay.ChangeHealthText(card.health); } }\r✅ 总结： Do one thing, and do it well.\n开闭原则#\r定义：\n软件实体应对扩展开放，对修改关闭。\n不好的设计#\rpublic class HealthPotion { public void Use() =\u0026gt; Debug.Log(\u0026#34;生命值恢复了100点!\u0026#34;); } public class ManaPotion { public void Use() =\u0026gt; Debug.Log(\u0026#34;魔法值恢复了100点!\u0026#34;); } public class Player { public void UseHealthPotion() { HealthPotion healthPotion = new HealthPotion(); healthPotion.Use(); } public void UseManaPotion() { ManaPotion manaPotion = new ManaPotion(); manaPotion.Use(); } }更好的设计#\rpublic interface IPotion { void Use(); } public class HealthPotion : IPotion { public void Use() =\u0026gt; Debug.Log(\u0026#34;生命值恢复了100点!\u0026#34;); } public class ManaPotion : IPotion { public void Use() =\u0026gt; Debug.Log(\u0026#34;魔法值恢复了100点!\u0026#34;); } public class Player { private IPotion potion; public void UsePotion() { potion.Use(); } }\r✅ 使用抽象（接口 / 继承 / 组合）来扩展，不修改原有代码。\n接口隔离原则#\r定义：\n不应强迫客户端依赖它不使用的方法。\n不好的设计#\rpublic interface IEquipment { void Attack(); void Defend(); void Repair(); void Upgrade(); }更好的设计#\rpublic interface IAttackable { void Attack(); } public interface IDefendable { void Defend(); } public interface IRepairable { void Repair(); } public interface IUpgradeable { void Upgrade(); } 里氏替换原则 (继承)#\r定义：\n子类实例必须能替换所有父类实例。\n不好的设计#\rpublic class Rectangle { public virtual int Width { get; set; } public virtual int Height { get; set; } public virtual int Area() =\u0026gt; Width * Height; } public class Square : Rectangle { public override int Width { get; set; } public override int Height { get =\u0026gt; Width; set =\u0026gt; Width = value; } public override int Area() =\u0026gt; Width * Width; }更好的设计#\rpublic abstract class Quadrangle { public abstract int Width { get; set; } public abstract int Height { get; set; } public abstract int Area(); } public class Rectangle : Quadrangle { public override int Width { get; set; } public override int Height { get; set; } public override int Area() =\u0026gt; Width * Height; } public class Square : Quadrangle { public override int Width { get; set; } public override int Height { get =\u0026gt; Width; set =\u0026gt; Width = value; } public override int Area() =\u0026gt; Width * Width; }\r✅ “正方形是一种长方形”，但行为上却不同。 以行为为导向的抽象才能避免滥用继承。\n最少知识原则#\r定义：\n每个对象应只了解与其紧密相关的对象。\n不好的设计#\rpublic class Player { public void JoinTeam(Guild guild) { Team team = guild.FindTeam(); team.AddPlayer(this); } }更好的设计#\rpublic class Player { public void JoinTeam(Guild guild) { guild.AddPlayer(this); } }\r✅ 减少依赖链，只与直接相关对象交互。\n依赖倒置原则#\r定义：\n高层模块不应依赖于低层模块，二者都应依赖抽象。\n不好的设计#\rpublic class Player { public void SpellFireBall() =\u0026gt; Console.WriteLine(\u0026#34;Fireball!\u0026#34;); public void SpellFrostBall() =\u0026gt; Console.WriteLine(\u0026#34;Frostball!\u0026#34;); } public class Game { public static void Main() { Player player = new Player(); player.SpellFireBall(); player.SpellFrostBall(); } }更好的设计#\rpublic interface ISpell { void Cast(); } public class FireBall : ISpell { public void Cast() =\u0026gt; Console.WriteLine(\u0026#34;Fireball!\u0026#34;); } public class FrostBall : ISpell { public void Cast() =\u0026gt; Console.WriteLine(\u0026#34;Frostball!\u0026#34;); } public class Player { public void Spell(ISpell spell) { spell.Cast(); } } public class Game { public static void Main() { Player player = new Player(); player.Spell(new FireBall()); player.Spell(new FrostBall()); } } 雪中送炭与锦上添花——设计模式#\r参考资料：\n《设计模式：可复用面向对象软件的基础》 《游戏设计模式》 《设计模式与完美游戏开发》 "},{"id":4,"href":"/docs/archive_posts/prefix_infix_postfix_expr/","title":"前缀、后缀，中缀表达式","section":"Archive Posts","content":"中缀表达式#\r中缀表达式就是我们通常所写的表达式,如:1+2*3、1+(2+3)*4-5、1+2*(3+4*(5+6)) 等等。\n后缀表达式及其求值方法#\r后缀表达式又称为逆波兰表达式,它的特点是运算符在操作数的后面,如:123*+、123+4*+5-、123456+*+*+ 等等。\n后缀表达式的求值方法#\r后缀表达式的求值方法是:从左到右遍历表达式的每个数字和符号,遇到是数字就进栈,遇到是符号,就将处于栈顶两个数字出栈,进行运算,运算结果进栈,一直到最终获得结果。\n例如:123*+ 的求值过程如下:\n读入字符 当前栈 说明 1 1 读入 1,进栈 2 1 2 读入 2,进栈 3 1 2 3 读入 3,进栈 * 1 6 读入 *,出栈 3 和 2,计算 2 * 3 = 6,将 6 进栈 + 7 读入 +,出栈 6 和 1,计算 1 + 6 = 7,将 7 进栈 C++ 实现后缀表达式的求值#\r用C++实现后缀表达式的求值。要求有简单的控制台UI,并且要对用户的危险行为进行检查和警告。控制台输出的语句要求是中英文对照,并且在用户进行错误操作的时候告知他进行了什么错误操作。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;sstream\u0026gt; #include \u0026lt;cctype\u0026gt; using namespace std; // 函数声明 bool isOperator(char c); double performOperation(char op, double operand1, double operand2); bool evaluatePostfixExpression(const string\u0026amp; postfix, double\u0026amp; result); int main() { cout \u0026lt;\u0026lt; \u0026#34;欢迎使用后缀表达式计算器!\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;请输入一个后缀表达式,使用空格分隔操作数和操作符,输入\u0026#39;q\u0026#39;退出:\u0026#34; \u0026lt;\u0026lt; endl; while (true) { string input; getline(cin, input); if (input == \u0026#34;q\u0026#34;) { cout \u0026lt;\u0026lt; \u0026#34;感谢使用后缀表达式计算器,再见!\u0026#34; \u0026lt;\u0026lt; endl; break; } // 检查输入中的非法字符 bool validInput = true; for (char c : input) { if (!isspace(c) \u0026amp;\u0026amp; !isdigit(c) \u0026amp;\u0026amp; !isOperator(c)) { validInput = false; cout \u0026lt;\u0026lt; \u0026#34;错误:输入包含非法字符 \u0026#39;\u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#34;\u0026#39;\u0026#34; \u0026lt;\u0026lt; endl; break; } } if (validInput) { double result; if (evaluatePostfixExpression(input, result)) { cout \u0026lt;\u0026lt; \u0026#34;结果: \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;错误:无效的后缀表达式\u0026#34; \u0026lt;\u0026lt; endl; } } cout \u0026lt;\u0026lt; \u0026#34;请输入另一个后缀表达式,或输入\u0026#39;q\u0026#39;退出:\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } bool isOperator(char c) { return c == \u0026#39;+\u0026#39; || c == \u0026#39;-\u0026#39; || c == \u0026#39;*\u0026#39; || c == \u0026#39;/\u0026#39;; } double performOperation(char op, double operand1, double operand2) { switch (op) { case \u0026#39;+\u0026#39;: return operand1 + operand2; case \u0026#39;-\u0026#39;: return operand1 - operand2; case \u0026#39;*\u0026#39;: return operand1 * operand2; case \u0026#39;/\u0026#39;: if (operand2 != 0) { return operand1 / operand2; } else { cout \u0026lt;\u0026lt; \u0026#34;错误:除数不能为零\u0026#34; \u0026lt;\u0026lt; endl; exit(1); } default: cout \u0026lt;\u0026lt; \u0026#34;错误:未知的操作符 \u0026#39;\u0026#34; \u0026lt;\u0026lt; op \u0026lt;\u0026lt; \u0026#34;\u0026#39;\u0026#34; \u0026lt;\u0026lt; endl; exit(1); } } bool evaluatePostfixExpression(const string\u0026amp; postfix, double\u0026amp; result) { stack\u0026lt;double\u0026gt; operandStack; istringstream iss(postfix); string token; while (iss \u0026gt;\u0026gt; token) { if (isdigit(token[0])) { double operand = stod(token); operandStack.push(operand); } else if (isOperator(token[0])) { if (operandStack.size() \u0026lt; 2) { cout \u0026lt;\u0026lt; \u0026#34;错误:操作数不足\u0026#34; \u0026lt;\u0026lt; endl; return false; } double operand2 = operandStack.top(); operandStack.pop(); double operand1 = operandStack.top(); operandStack.pop(); double result = performOperation(token[0], operand1, operand2); operandStack.push(result); } else { cout \u0026lt;\u0026lt; \u0026#34;错误:无效的标记 \u0026#39;\u0026#34; \u0026lt;\u0026lt; token \u0026lt;\u0026lt; \u0026#34;\u0026#39;\u0026#34; \u0026lt;\u0026lt; endl; return false; } } if (operandStack.size() == 1) { result = operandStack.top(); return true; } else { cout \u0026lt;\u0026lt; \u0026#34;错误:操作数不足或操作符过多\u0026#34; \u0026lt;\u0026lt; endl; return false; } }C 实现后缀表达式的求值#\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #define MAX_STACK_SIZE 100 #pragma warning(disable : 4996) // 栈结构和操作 typedef struct { double data[MAX_STACK_SIZE]; int top; } Stack; void initialize(Stack* stack) { stack-\u0026gt;top = -1; } int isEmpty(Stack* stack) { return stack-\u0026gt;top == -1; } void push(Stack* stack, double value) { if (stack-\u0026gt;top \u0026lt; MAX_STACK_SIZE - 1) { stack-\u0026gt;data[++stack-\u0026gt;top] = value; } else { printf(\u0026#34;错误:栈已满\\n\u0026#34;); exit(1); } } double pop(Stack* stack) { if (!isEmpty(stack)) { return stack-\u0026gt;data[stack-\u0026gt;top--]; } else { printf(\u0026#34;错误:栈为空\\n\u0026#34;); exit(1); } } // 函数声明 int isOperator(char c); double performOperation(char op, double operand1, double operand2); int evaluatePostfixExpression(const char* postfix, double* result); int main() { printf(\u0026#34;欢迎使用后缀表达式计算器!\\n\u0026#34;); printf(\u0026#34;请输入一个后缀表达式,使用空格分隔操作数和操作符,输入\u0026#39;q\u0026#39;退出:\\n\u0026#34;); while (1) { char input[100]; fgets(input, sizeof(input), stdin); input[strcspn(input, \u0026#34;\\n\u0026#34;)] = \u0026#39;\\0\u0026#39;; // 去掉换行符 if (strcmp(input, \u0026#34;q\u0026#34;) == 0) { printf(\u0026#34;感谢使用后缀表达式计算器,再见!\\n\u0026#34;); break; } // 检查输入中的非法字符 int validInput = 1; for (int i = 0; input[i] != \u0026#39;\\0\u0026#39;; i++) { if (!isspace(input[i]) \u0026amp;\u0026amp; !isdigit(input[i]) \u0026amp;\u0026amp; !isOperator(input[i])) { validInput = 0; printf(\u0026#34;错误:输入包含非法字符 \u0026#39;%c\u0026#39;\\n\u0026#34;, input[i]); break; } } if (validInput) { double result; if (evaluatePostfixExpression(input, \u0026amp;result)) { printf(\u0026#34;结果: %g\\n\u0026#34;, result); } else { printf(\u0026#34;错误:无效的后缀表达式\\n\u0026#34;); } } printf(\u0026#34;请输入另一个后缀表达式,或输入\u0026#39;q\u0026#39;退出:\\n\u0026#34;); } return 0; } int isOperator(char c) { return c == \u0026#39;+\u0026#39; || c == \u0026#39;-\u0026#39; || c == \u0026#39;*\u0026#39; || c == \u0026#39;/\u0026#39;; } double performOperation(char op, double operand1, double operand2) { switch (op) { case \u0026#39;+\u0026#39;: return operand1 + operand2; case \u0026#39;-\u0026#39;: return operand1 - operand2; case \u0026#39;*\u0026#39;: return operand1 * operand2; case \u0026#39;/\u0026#39;: if (operand2 != 0) { return operand1 / operand2; } else { printf(\u0026#34;错误:除数不能为零\\n\u0026#34;); exit(1); } default: printf(\u0026#34;错误:未知的操作符 \u0026#39;%c\u0026#39;\\n\u0026#34;, op); exit(1); } } int evaluatePostfixExpression(const char* postfix, double* result) { Stack operandStack; initialize(\u0026amp;operandStack); char* token = strtok((char*)postfix, \u0026#34; \u0026#34;); while (token != NULL) { if (isdigit(token[0])) { double operand = atof(token); push(\u0026amp;operandStack, operand); } else if (isOperator(token[0])) { if (operandStack.top \u0026lt; 1) { printf(\u0026#34;错误:操作数不足\\n\u0026#34;); return 0; } double operand2 = pop(\u0026amp;operandStack); double operand1 = pop(\u0026amp;operandStack); double result = performOperation(token[0], operand1, operand2); push(\u0026amp;operandStack, result); } else { printf(\u0026#34;错误:无效的标记 \u0026#39;%s\u0026#39;\\n\u0026#34;, token); return 0; } token = strtok(NULL, \u0026#34; \u0026#34;); } if (operandStack.top == 0) { *result = operandStack.data[0]; return 1; } else { printf(\u0026#34;错误:操作数不足或操作符过多\\n\u0026#34;); return 0; } }后缀表达式的转换方法(中缀转后缀)#\r将中缀表达式转换为后缀表达式的方法是:从左到右遍历中缀表达式的每个数字和符号,若是数字就输出,若是符号,则判断其与栈顶符号的优先级,是右括号或优先级不高于栈顶符号(乘除优先加减)则栈顶元素依次出栈并输出,并将当前符号进栈,一直到最终输出后缀表达式为止。\n例如:1+(2+3)*4-5 的转换过程如下:\n读入字符 当前栈 说明 1 1 读入 1,输出 + + 读入 +,进栈 ( + ( 读入 (,进栈 2 + ( 2 读入 2,输出 + + ( + 读入 +,进栈 3 + ( + 3 读入 3,输出 ) + 读入 ),依次出栈 + 和 (,输出 * * 读入 *,进栈 4 * 4 读入 4,输出 - - 读入 -,进栈 5 - 5 读入 5,输出 空 - 依次出栈 - 和 *,输出 转换后的后缀表达式为:123+4*+5-。\nC++ 实现中缀表达式转后缀表达式#\r#include \u0026lt;iostream\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; // 函数声明 int getOperatorPrecedence(char op); bool isOperator(char c); string infixToPostfix(const string\u0026amp; infix); int main() { cout \u0026lt;\u0026lt; \u0026#34;欢迎使用中缀表达式转后缀表达式程序!\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;请输入一个中缀表达式,输入\u0026#39;q\u0026#39;退出:\u0026#34; \u0026lt;\u0026lt; endl; while (true) { string infixExpression; getline(cin, infixExpression); if (infixExpression == \u0026#34;q\u0026#34;) { cout \u0026lt;\u0026lt; \u0026#34;感谢使用中缀表达式转后缀表达式程序,再见!\u0026#34; \u0026lt;\u0026lt; endl; break; } string postfixExpression = infixToPostfix(infixExpression); cout \u0026lt;\u0026lt; \u0026#34;后缀表达式:\u0026#34; \u0026lt;\u0026lt; postfixExpression \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;请输入另一个中缀表达式,或输入\u0026#39;q\u0026#39;退出:\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } int getOperatorPrecedence(char op) { switch (op) { case \u0026#39;+\u0026#39;: case \u0026#39;-\u0026#39;: return 1; case \u0026#39;*\u0026#39;: case \u0026#39;/\u0026#39;: return 2; default: return 0; } } bool isOperator(char c) { return c == \u0026#39;+\u0026#39; || c == \u0026#39;-\u0026#39; || c == \u0026#39;*\u0026#39; || c == \u0026#39;/\u0026#39;; } string infixToPostfix(const string\u0026amp; infix) { stack\u0026lt;char\u0026gt; operatorStack; string postfixExpression; for (char c : infix) { if (isspace(c)) { continue; } else if (isdigit(c) || isalpha(c)) { postfixExpression += c; } else if (isOperator(c)) { while (!operatorStack.empty() \u0026amp;\u0026amp; getOperatorPrecedence(operatorStack.top()) \u0026gt;= getOperatorPrecedence(c)) { postfixExpression += operatorStack.top(); operatorStack.pop(); } operatorStack.push(c); } else if (c == \u0026#39;(\u0026#39;) { operatorStack.push(c); } else if (c == \u0026#39;)\u0026#39;) { while (!operatorStack.empty() \u0026amp;\u0026amp; operatorStack.top() != \u0026#39;(\u0026#39;) { postfixExpression += operatorStack.top(); operatorStack.pop(); } if (!operatorStack.empty() \u0026amp;\u0026amp; operatorStack.top() == \u0026#39;(\u0026#39;) { operatorStack.pop(); } else { cout \u0026lt;\u0026lt; \u0026#34;错误:括号不匹配\u0026#34; \u0026lt;\u0026lt; endl; exit(1); } } else { cout \u0026lt;\u0026lt; \u0026#34;错误:无效的字符 \u0026#39;\u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#34;\u0026#39;\u0026#34; \u0026lt;\u0026lt; endl; exit(1); } } while (!operatorStack.empty()) { if (operatorStack.top() == \u0026#39;(\u0026#39;) { cout \u0026lt;\u0026lt; \u0026#34;错误:括号不匹配\u0026#34; \u0026lt;\u0026lt; endl; exit(1); } postfixExpression += operatorStack.top(); operatorStack.pop(); } return postfixExpression; }C 实现中缀表达式转后缀表达式#\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #define MAX_STACK_SIZE 100 // 栈结构和操作 typedef struct { char data[MAX_STACK_SIZE]; int top; } Stack; void initialize(Stack* stack) { stack-\u0026gt;top = -1; } int isEmpty(Stack* stack) { return stack-\u0026gt;top == -1; } int isFull(Stack* stack) { return stack-\u0026gt;top == MAX_STACK_SIZE - 1; } void push(Stack* stack, char value) { if (!isFull(stack)) { stack-\u0026gt;data[++stack-\u0026gt;top] = value; } else { printf(\u0026#34;错误:栈已满\\n\u0026#34;); exit(1); } } char pop(Stack* stack) { if (!isEmpty(stack)) { return stack-\u0026gt;data[stack-\u0026gt;top--]; } else { printf(\u0026#34;错误:栈为空\\n\u0026#34;); exit(1); } } char peek(Stack* stack) { if (!isEmpty(stack)) { return stack-\u0026gt;data[stack-\u0026gt;top]; } else { return \u0026#39;\\0\u0026#39;; } } // 函数声明 int getOperatorPrecedence(char op); int isOperator(char c); void infixToPostfix(const char* infix, char* postfix); int main() { printf(\u0026#34;欢迎使用中缀表达式转后缀表达式程序!\\n\u0026#34;); printf(\u0026#34;请输入一个中缀表达式,输入\u0026#39;q\u0026#39;退出:\\n\u0026#34;); while (1) { char infixExpression[100]; fgets(infixExpression, sizeof(infixExpression), stdin); infixExpression[strcspn(infixExpression, \u0026#34;\\n\u0026#34;)] = \u0026#39;\\0\u0026#39;; // 去掉换行符 if (strcmp(infixExpression, \u0026#34;q\u0026#34;) == 0) { printf(\u0026#34;感谢使用中缀表达式转后缀表达式程序,再见!\\n\u0026#34;); break; } char postfixExpression[100]; infixToPostfix(infixExpression, postfixExpression); printf(\u0026#34;后缀表达式:%s\\n\u0026#34;, postfixExpression); printf(\u0026#34;请输入另一个中缀表达式,或输入\u0026#39;q\u0026#39;退出:\\n\u0026#34;); } return 0; } int getOperatorPrecedence(char op) { switch (op) { case \u0026#39;+\u0026#39;: case \u0026#39;-\u0026#39;: return 1; case \u0026#39;*\u0026#39;: case \u0026#39;/\u0026#39;: return 2; default: return 0; } } int isOperator(char c) { return c == \u0026#39;+\u0026#39; || c == \u0026#39;-\u0026#39; || c == \u0026#39;*\u0026#39; || c == \u0026#39;/\u0026#39;; } void infixToPostfix(const char* infix, char* postfix) { Stack operatorStack; initialize(\u0026amp;operatorStack); int i = 0; int j = 0; while (infix[i] != \u0026#39;\\0\u0026#39;) { if (isspace(infix[i])) { i++; continue; } else if (isdigit(infix[i]) || isalpha(infix[i])) { postfix[j++] = infix[i]; } else if (isOperator(infix[i])) { while (!isEmpty(\u0026amp;operatorStack) \u0026amp;\u0026amp; getOperatorPrecedence(peek(\u0026amp;operatorStack)) \u0026gt;= getOperatorPrecedence(infix[i])) { postfix[j++] = pop(\u0026amp;operatorStack); } push(\u0026amp;operatorStack, infix[i]); } else if (infix[i] == \u0026#39;(\u0026#39;) { push(\u0026amp;operatorStack, infix[i]); } else if (infix[i] == \u0026#39;)\u0026#39;) { while (!isEmpty(\u0026amp;operatorStack) \u0026amp;\u0026amp; peek(\u0026amp;operatorStack) != \u0026#39;(\u0026#39;) { postfix[j++] = pop(\u0026amp;operatorStack); } if (!isEmpty(\u0026amp;operatorStack) \u0026amp;\u0026amp; peek(\u0026amp;operatorStack) == \u0026#39;(\u0026#39;) { pop(\u0026amp;operatorStack); // 弹出 \u0026#39;(\u0026#39; } else { printf(\u0026#34;错误:括号不匹配\\n\u0026#34;); exit(1); } } else { printf(\u0026#34;错误:无效的字符 \u0026#39;%c\u0026#39;\\n\u0026#34;, infix[i]); exit(1); } i++; } while (!isEmpty(\u0026amp;operatorStack)) { if (peek(\u0026amp;operatorStack) == \u0026#39;(\u0026#39;) { printf(\u0026#34;错误:括号不匹配\\n\u0026#34;); exit(1); } postfix[j++] = pop(\u0026amp;operatorStack); } postfix[j] = \u0026#39;\\0\u0026#39;; // 添加字符串终止符 }前缀表达式及其求值方法#\r前缀表达式又称为波兰表达式,它的特点是运算符在操作数的前面,如:+1*23、-+1*+2345、+1*2+3*4+56 等等。\n前缀表达式的求值方法#\r前缀表达式的求值方法是:从右到左遍历表达式的每个数字和符号,遇到是数字就进栈,遇到是符号,就将处于栈顶两个数字出栈,进行运算,运算结果进栈,一直到最终获得结果。\n例如:+1*23 的求值过程如下:\n读入字符 当前栈 说明 3 3 读入 3,进栈 2 3 2 读入 2,进栈 * 6 读入 *,出栈 2 和 3,计算 2 * 3 = 6,将 6 进栈 1 6 1 读入 1,进栈 + 7 读入 +,出栈 1 和 6,计算 1 + 6 = 7,将 7 进栈 C++ 实现前缀表达式的求值#\r#include \u0026lt;iostream\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;sstream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cctype\u0026gt; using namespace std; // 函数声明 bool isOperator(const string\u0026amp; token); bool isNumeric(const string\u0026amp; token); double evaluatePrefixExpression(const vector\u0026lt;string\u0026gt;\u0026amp; tokens); int main() { cout \u0026lt;\u0026lt; \u0026#34;欢迎使用前缀表达式求值程序!\u0026#34; \u0026lt;\u0026lt; endl; while (true) { cout \u0026lt;\u0026lt; \u0026#34;请输入前缀表达式,操作符和操作数之间用空格分隔,支持+、-、*、/:\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;输入 q 退出程序\u0026#34; \u0026lt;\u0026lt; endl; string input; getline(cin, input); if (input == \u0026#34;q\u0026#34;) { break; // 用户输入了\u0026#34;q\u0026#34;,退出程序 } istringstream iss(input); vector\u0026lt;string\u0026gt; tokens; string token; while (iss \u0026gt;\u0026gt; token) { tokens.push_back(token); } if (tokens.empty()) { cout \u0026lt;\u0026lt; \u0026#34;错误:输入为空,请重新输入表达式。\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;输入 q 退出程序\u0026#34; \u0026lt;\u0026lt; endl; continue; // 继续下一次循环 } double result = evaluatePrefixExpression(tokens); if (!isnan(result)) { cout \u0026lt;\u0026lt; \u0026#34;表达式结果为:\u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;错误:无法计算表达式结果,请检查表达式是否正确。\u0026#34; \u0026lt;\u0026lt; endl; } } cout \u0026lt;\u0026lt; \u0026#34;感谢使用前缀表达式求值程序!\u0026#34; \u0026lt;\u0026lt; endl; return 0; } bool isOperator(const string\u0026amp; token) { return (token == \u0026#34;+\u0026#34; || token == \u0026#34;-\u0026#34; || token == \u0026#34;*\u0026#34; || token == \u0026#34;/\u0026#34;); } bool isNumeric(const string\u0026amp; token) { for (char c : token) { if (!isdigit(c) \u0026amp;\u0026amp; c != \u0026#39;.\u0026#39; \u0026amp;\u0026amp; c != \u0026#39;-\u0026#39;) { return false; } } return true; } double evaluatePrefixExpression(const vector\u0026lt;string\u0026gt;\u0026amp; tokens) { stack\u0026lt;double\u0026gt; operandStack; for (int i = tokens.size() - 1; i \u0026gt;= 0; i--) { const string\u0026amp; token = tokens[i]; if (isNumeric(token)) { operandStack.push(stod(token)); } else if (isOperator(token)) { if (operandStack.size() \u0026lt; 2) { cout \u0026lt;\u0026lt; \u0026#34;错误:操作数不足,无法进行操作。\u0026#34; \u0026lt;\u0026lt; endl; return NAN; } double operand1 = operandStack.top(); operandStack.pop(); double operand2 = operandStack.top(); operandStack.pop(); if (token == \u0026#34;+\u0026#34;) { operandStack.push(operand1 + operand2); } else if (token == \u0026#34;-\u0026#34;) { operandStack.push(operand1 - operand2); } else if (token == \u0026#34;*\u0026#34;) { operandStack.push(operand1 * operand2); } else if (token == \u0026#34;/\u0026#34;) { if (operand2 == 0) { cout \u0026lt;\u0026lt; \u0026#34;错误:除数为零,无法进行除法操作。\u0026#34; \u0026lt;\u0026lt; endl; return NAN; } operandStack.push(operand1 / operand2); } } else { cout \u0026lt;\u0026lt; \u0026#34;错误:无效的表达式元素 \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; token \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;,请检查表达式是否正确。\u0026#34; \u0026lt;\u0026lt; endl; return NAN; } } if (operandStack.size() != 1) { cout \u0026lt;\u0026lt; \u0026#34;错误:操作数和操作符数量不匹配,无法计算表达式结果。\u0026#34; \u0026lt;\u0026lt; endl; return NAN; } return operandStack.top(); }C 实现前缀表达式的求值#\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #include \u0026lt;math.h\u0026gt; #define MAX_EXPRESSION_SIZE 100 #pragma warning(disable : 4996) // 函数声明 bool isOperator(const char token); bool isNumeric(const char* token); double evaluatePrefixExpression(const char** tokens, int numTokens); int main() { printf(\u0026#34;欢迎使用前缀表达式求值程序!\\n\u0026#34;); while (1) { printf(\u0026#34;请输入前缀表达式,操作符和操作数之间用空格分隔,支持+、-、*、/:\\n\u0026#34;); printf(\u0026#34;输入 q 退出程序。\\n\u0026#34;); char input[MAX_EXPRESSION_SIZE]; fgets(input, sizeof(input), stdin); input[strcspn(input, \u0026#34;\\n\u0026#34;)] = \u0026#39;\\0\u0026#39;; // 移除末尾的换行符 if (strcmp(input, \u0026#34;q\u0026#34;) == 0) { break; // 用户输入了\u0026#34;q\u0026#34;,退出程序 } const char* delimiters = \u0026#34; \u0026#34;; char* token = strtok(input, delimiters); const char* tokens[MAX_EXPRESSION_SIZE]; int numTokens = 0; while (token != NULL \u0026amp;\u0026amp; numTokens \u0026lt; MAX_EXPRESSION_SIZE) { tokens[numTokens] = token; numTokens++; token = strtok(NULL, delimiters); } if (numTokens == 0) { printf(\u0026#34;错误:输入为空,请重新输入表达式。\\n\u0026#34;); printf(\u0026#34;输入 q 退出程序。\\n\u0026#34;); continue; // 继续下一次循环 } double result = evaluatePrefixExpression(tokens, numTokens); if (!isnan(result)) { printf(\u0026#34;表达式结果为:%g\\n\u0026#34;, result); } else { printf(\u0026#34;错误:无法计算表达式结果,请检查表达式是否正确。\\n\u0026#34;); } } printf(\u0026#34;感谢使用前缀表达式求值程序!\\n\u0026#34;); return 0; } bool isOperator(const char token) { return (token == \u0026#39;+\u0026#39; || token == \u0026#39;-\u0026#39; || token == \u0026#39;*\u0026#39; || token == \u0026#39;/\u0026#39;); } bool isNumeric(const char* token) { for (int i = 0; token[i] != \u0026#39;\\0\u0026#39;; i++) { if (!isdigit(token[i]) \u0026amp;\u0026amp; token[i] != \u0026#39;.\u0026#39; \u0026amp;\u0026amp; token[i] != \u0026#39;-\u0026#39;) { return false; } } return true; } double evaluatePrefixExpression(const char** tokens, int numTokens) { double operandStack[MAX_EXPRESSION_SIZE]; int top = -1; for (int i = numTokens - 1; i \u0026gt;= 0; i--) { const char* token = tokens[i]; if (isNumeric(token)) { operandStack[++top] = atof(token); } else if (isOperator(token[0])) { if (top \u0026lt; 1) { printf(\u0026#34;错误:操作数不足,无法进行操作。\\n\u0026#34;); return NAN; } double operand1 = operandStack[top--]; double operand2 = operandStack[top--]; switch (token[0]) { case \u0026#39;+\u0026#39;: operandStack[++top] = operand1 + operand2; break; case \u0026#39;-\u0026#39;: operandStack[++top] = operand1 - operand2; break; case \u0026#39;*\u0026#39;: operandStack[++top] = operand1 * operand2; break; case \u0026#39;/\u0026#39;: if (operand2 == 0) { printf(\u0026#34;错误:除数为零,无法进行除法操作。\\n\u0026#34;); return NAN; } operandStack[++top] = operand1 / operand2; break; default: printf(\u0026#34;错误:无效的操作符 \\\u0026#34;%s\\\u0026#34;,请检查表达式是否正确。\\n\u0026#34;, token); return NAN; } } else { printf(\u0026#34;错误:无效的表达式元素 \\\u0026#34;%s\\\u0026#34;,请检查表达式是否正确。\\n\u0026#34;, token); return NAN; } } if (top != 0) { printf(\u0026#34;错误:操作数和操作符数量不匹配,无法计算表达式结果。\\n\u0026#34;); return NAN; } return operandStack[top]; }前缀表达式的转换方法(中缀转前缀)#\r将中缀表达式转换为前缀表达式的方法是:从右到左遍历中缀表达式的每个数字和符号,若是数字就输出,若是符号,则判断其与栈顶符号的优先级,是右括号或优先级不高于栈顶符号(乘除优先加减)则栈顶元素依次出栈并输出,并将当前符号进栈,一直到最终输出前缀表达式为止。\n例如:1+(2+3)*4-5 的转换过程如下:\n读入字符 当前栈 说明 5 5 读入 5,进栈 - - 读入 -,进栈 4 - 4 读入 4,进栈 * * 读入 *,进栈 + + 读入 +,进栈 3 + 3 读入 3,进栈 + + 读入 +,进栈 2 + 2 读入 2,进栈 ( + ( 读入 (,进栈 1 + ( 1 读入 1,输出 空 + 依次出栈 + 和 (,输出 转换后的前缀表达式为:-*+12345。\nC++ 实现中缀表达式转前缀表达式#\r#include \u0026lt;iostream\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; // 函数声明 int getOperatorPrecedence(char op); bool isOperator(char token); bool isOperand(char token); string infixToPrefix(const string\u0026amp; infixExpression); int main() { cout \u0026lt;\u0026lt; \u0026#34;欢迎使用中缀表达式转前缀表达式程序!\u0026#34; \u0026lt;\u0026lt; endl; while (true) { cout \u0026lt;\u0026lt; \u0026#34;请输入中缀表达式或输入 \u0026#39;q\u0026#39; 退出:\u0026#34; \u0026lt;\u0026lt; endl; string input; getline(cin, input); if (input == \u0026#34;q\u0026#34;) { break; // 用户输入了\u0026#39;q\u0026#39;,退出程序 } string prefixExpression = infixToPrefix(input); if (!prefixExpression.empty()) { cout \u0026lt;\u0026lt; \u0026#34;前缀表达式为:\u0026#34; \u0026lt;\u0026lt; prefixExpression \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;错误:无法转换表达式,请检查表达式是否正确。\u0026#34; \u0026lt;\u0026lt; endl; } } cout \u0026lt;\u0026lt; \u0026#34;感谢使用中缀表达式转前缀表达式程序!\u0026#34; \u0026lt;\u0026lt; endl; return 0; } int getOperatorPrecedence(char op) { switch (op) { case \u0026#39;+\u0026#39;: case \u0026#39;-\u0026#39;: return 1; case \u0026#39;*\u0026#39;: case \u0026#39;/\u0026#39;: return 2; default: return 0; } } bool isOperator(char token) { return (token == \u0026#39;+\u0026#39; || token == \u0026#39;-\u0026#39; || token == \u0026#39;*\u0026#39; || token == \u0026#39;/\u0026#39;); } bool isOperand(char token) { return isalnum(token); } string infixToPrefix(const string\u0026amp; infixExpression) { string prefixExpression; stack\u0026lt;char\u0026gt; operatorStack; // 反转中缀表达式,方便从右到左处理 string reversedInfix = infixExpression; reverse(reversedInfix.begin(), reversedInfix.end()); for (char token : reversedInfix) { if (isOperand(token)) { prefixExpression = token + prefixExpression; } else if (isOperator(token)) { while (!operatorStack.empty() \u0026amp;\u0026amp; getOperatorPrecedence(token) \u0026lt; getOperatorPrecedence(operatorStack.top())) { prefixExpression = operatorStack.top() + prefixExpression; operatorStack.pop(); } operatorStack.push(token); } else if (token == \u0026#39;)\u0026#39;) { operatorStack.push(token); } else if (token == \u0026#39;(\u0026#39;) { while (!operatorStack.empty() \u0026amp;\u0026amp; operatorStack.top() != \u0026#39;)\u0026#39;) { prefixExpression = operatorStack.top() + prefixExpression; operatorStack.pop(); } if (!operatorStack.empty()) { operatorStack.pop(); // 弹出匹配的右括号 } else { return \u0026#34;\u0026#34;; // 括号不匹配 } } } while (!operatorStack.empty()) { if (operatorStack.top() == \u0026#39;(\u0026#39; || operatorStack.top() == \u0026#39;)\u0026#39;) { return \u0026#34;\u0026#34;; // 括号不匹配 } prefixExpression = operatorStack.top() + prefixExpression; operatorStack.pop(); } return prefixExpression; }C 实现中缀表达式转前缀表达式#\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #define MAX_SIZE 100 #pragma warning(disable : 4996) typedef struct { char arr[MAX_SIZE]; int top; } Stack; void initStack(Stack* s) { s-\u0026gt;top = -1; } bool isEmpty(Stack s) { return s.top == -1; } bool isFull(Stack s) { return s.top == MAX_SIZE - 1; } void push(Stack* s, char ch) { if (isFull(*s)) { printf(\u0026#34;Stack overflow!\\n\u0026#34;); exit(1); } s-\u0026gt;arr[++(s-\u0026gt;top)] = ch; } char pop(Stack* s) { if (isEmpty(*s)) { printf(\u0026#34;Stack underflow!\\n\u0026#34;); exit(1); } return s-\u0026gt;arr[(s-\u0026gt;top)--]; } char peek(Stack s) { return s.arr[s.top]; } bool isOperator(char ch) { return ch == \u0026#39;+\u0026#39; || ch == \u0026#39;-\u0026#39; || ch == \u0026#39;*\u0026#39; || ch == \u0026#39;/\u0026#39;; } int precedence(char ch) { switch (ch) { case \u0026#39;+\u0026#39;: case \u0026#39;-\u0026#39;: return 1; case \u0026#39;*\u0026#39;: case \u0026#39;/\u0026#39;: return 2; default: return -1; } } void infixToPrefix(char* infix, char* prefix) { Stack operators; initStack(\u0026amp;operators); int j = 0; for (int i = strlen(infix) - 1; i \u0026gt;= 0; i--) { char ch = infix[i]; if ((ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) || (ch \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;z\u0026#39;) || (ch \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;Z\u0026#39;)) { prefix[j++] = ch; } else if (ch == \u0026#39;)\u0026#39;) { push(\u0026amp;operators, ch); } else if (ch == \u0026#39;(\u0026#39;) { while (!isEmpty(operators) \u0026amp;\u0026amp; peek(operators) != \u0026#39;)\u0026#39;) { prefix[j++] = pop(\u0026amp;operators); } if (!isEmpty(operators) \u0026amp;\u0026amp; peek(operators) == \u0026#39;)\u0026#39;) { pop(\u0026amp;operators); } } else if (isOperator(ch)) { while (!isEmpty(operators) \u0026amp;\u0026amp; precedence(ch) \u0026lt;= precedence(peek(operators))) { prefix[j++] = pop(\u0026amp;operators); } push(\u0026amp;operators, ch); } } while (!isEmpty(operators)) { prefix[j++] = pop(\u0026amp;operators); } prefix[j] = \u0026#39;\\0\u0026#39;; _strrev(prefix); } int main() { char infix[MAX_SIZE], prefix[MAX_SIZE]; while (1) { printf(\u0026#34;请输入中缀表达式[不要留空格] (输入q退出): \u0026#34;); scanf(\u0026#34;%s\u0026#34;, infix); if (strcmp(infix, \u0026#34;q\u0026#34;) == 0) { printf(\u0026#34;退出计算器。\\n\u0026#34;); break; } infixToPrefix(infix, prefix); printf(\u0026#34;前缀表达式: %s\\n\u0026#34;, prefix); } return 0; }"},{"id":5,"href":"/docs/archive_posts/archive_blog_1/","title":"2D图形——渲染、精灵和简单应用","section":"Archive Posts","content":"像素缓冲区和垂直同步#\rCRT 显示器基础#\r现在大家用的比较多的是液晶显示器(LCD), 在早先年，大家用的 CRT 显示器比较多，也就是阴极管射线显示器。LCD 通过控制是否透光来控制亮和暗，当色彩不变时，液晶也保持不变，这样就无须考虑刷新率的问题。对于画面稳定、无闪烁感的液晶显示器，刷新率不高但图像也很稳定。不过对于我们今天要谈的游戏来说，缺点就很明显了，其相应速度不够，画面有时候会有重影。\n当然，我们这节课的主题是 2D 游戏渲染基础，和大家聊显示器主要也是让大家更好的了解我们渲染操作生成后呈现的载体。\n其实 LCD 和 CRT 显示器在刷新上的原理是差不多的，当然我们前面也说了，在早点年，CRT 显示器是当时的主流，综合考虑，也是为了让大家了解 2D 渲染这项技术在诞生之初的显示设备的环境，我打算从 CRT 显示器的角度带大家聊聊显示器的工作原理。\n大家高中信息课应该教过，在 CRT 显示器内部，绘制图形是通过电子枪发射电子流完成的。这样讲可能比较抽象。其实，在显示器内部有一层荧光板，荧光板上面有一些荧光粉末，红绿蓝三种颜色的荧光粉末，单色的荧光粉末会聚集起来形成一个小小的荧光单元。红绿蓝三种单元各出一个聚集在一起就是一个像素点，密密麻麻的像素点就充斥在荧光板上了。\n电子枪则会一口气发射三注电子流，很好理解，这些电子流依次打在了 RGB 三色上，由于电子流的强度不一样，每个像素点的红绿蓝三色的光也不一样，通过空间混色法，每个像素点就会呈现出不同的颜色。\n当然，电子流的能量是有限的，这些荧光粉很快就会熄灭，所以电子枪需要不断的发射电子流，这样才能保证荧光粉不断的发光，显示器才能一直显示图像。这就是刷新了。\n不过要想让画面动起来，而不是显示器上某个像素点一直再发不同的光，然而其他地方却一片黑，我们的电子流就要去射击不同的像素点，让整个显示器都呈现出画面。我们管这叫扫描。当然这里也运用到了人眼的视觉残留效应，想必大家很清楚。\n当然扫描也不是乱扫的，是有章法有规则的，请看下图。\n这张图大家肯定超级熟悉吧。电子枪从左上角向右扫，然后再从右向左扫，直到扫完整个屏幕。欸，我估计聪明的小伙伴已经发现了，这个扫描线不是绝对水平的，而是略微带一点倾斜。这也是为了让扫描线能扫过整个屏幕而不是只在一条横线上来回扫。从左向右扫的每条扫描线都略微下坡，其实这个下坡的度数是可以算出来的，其斜率大约为 -1/水平分辨率, 非常好算，我就不带大家算一遍了。\n消隐期 BLANK#\r其实，在 CRT 显示器中，从右向左的这一条扫描线往往不会真实的扫描，而是消隐，大家可以理解为电子枪在这段时间不喷了，画面上一片漆黑。这个时间段我们称为行消隐期(HBLANK)，也可以叫做水平回扫。\n啥是行？电子束既要作水平方向的运动，又要作垂直方向的运动。前者形成一行的扫描，称为行扫描，后者形成一幅画面的扫描，称为场扫描。\n当电子流从左上角扫到右下角后，屏幕就完成了一帧的渲染，不过这时候电子枪指着右下角啊，难道说下一帧是从右下角原路返回右上角吗？听起来好像效率挺高的，不过我们实际上不会这么干。而是让电子枪直接从右下角跳到右上角，然后再从右上角开始扫描。电子枪从右下角移动到左上角的的过程，我们称作场消隐期(VBLANK)，也可以叫做垂直回扫。同样的，这段时间内，画面上也是一片漆黑的。\n垂直同步#\r前面我们已经谈过了画面撕裂的原理，是渲染帧数超过刷新率，在显示器才显示到一半时就粗暴的给他塞了新的画面进去。那后来人是怎么解决这个问题的呢？很简单，就是在显示器刷新的时候，我们不提交渲染，直到等显示器刷新完了。这样就不会出现画面撕裂的问题了。这个技术就是垂直同步(VSYNC)。\n简单来说就是渲染循环受到真实刷新率的支配嘛。让游戏渲染的输出频率对标设备的刷新率，游戏的主循环又会和渲染循环相互制约，游戏的帧率也就被限制在了设备的刷新率上。当然这也会造成输入延迟，这一点不理解的同学可以去听我上一节的课，讲的很清楚。\n下面来点套话\n为了同步显示屏的显示过程和控制器，控制器会产生一系列的定时信号。当电子枪换行进行扫描时，控制器会发出一个水平同步信号 HSync；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，控制器会发出一个垂直同步信号 VSync。\nVSYNC信号有效时，表示一帧数据的开始。\n像素缓冲区#\r缓冲区是一个很好理解的概念，图像从我们的 GPU 到屏幕上并不是实时的一步到位的。在 GPU 内存上有一系列的缓冲区用来暂存渲染数据。\n我们在屏幕上展示出来的图像实际上是存储来 GPU 内存里面的。现代的硬件也足够支撑高分辨率的图像存在内存中，然而，这并不意味着我们就可以高枕无忧了。游戏循环仍然要像我们之前反复强调的那样考虑到 CRT(或者其他什么) 的电子枪。请试想，当 CRT 喷枪才在屏幕中喷到一半的时候，缓冲区就写入了新的数据，等这帧渲染完成后，显示器就会显示出一半新的画面，一半旧的画面，这就是我们前面说的画面撕裂。更糟糕的是，新数据提交的时候，上一帧还没开始绘制，那么就不是说屏幕中同时存在新的和旧的画面了，而是直接丢失了上一帧的画面。\n为了解决这个问题，早期的开发者想出了一种现在我们已经很难接受的办法，那就是等到场消隐期再开始渲染，但这样的做法带来的弊端也很明显，游戏循环被完全锁死在了显示器的刷新率上了。\n当然，还有另一种解决方案-多缓冲技术。我们可以在 GPU 内存中准备多个缓冲区，游戏循环可以将图像写入缓冲区A，这时屏幕正在绘制缓冲区B，等到下一帧，屏幕显示缓冲区A，游戏循环则将图像写入缓冲区B，由于屏幕和游戏循环的工作是交替进行的，所以我们可以保证屏幕显示的是完整的一帧画面。\n为了完全消灭画面撕裂，缓冲区的交换必须在场消隐期进行，这就是我们之前一直说的垂直同步。\n当然，这种技术的前提有两个，一个是交换缓冲区的速度足够快，在绝大多数场景下，这一点是不会变的，然而第二点则是等待 VBLANK。首先你得把游戏里面垂直同步的开关打开，缓冲区的交换才会等待垂直同步。有一些玩家为了追求极致的帧率和更低的输入延迟会关闭垂直同步，然而他们的屏幕刷新率又远低于游戏帧率，那么画面撕裂仍然会存在，缓冲区的存在只是一定程度的减缓了这种现象。\n当然，有双缓冲区也有三缓冲区，甚至更多，为了画面的稳定和帧率的平滑，他们放弃了较短的输入延迟。\n精灵 Sprite#\r为什么是『精灵 · Sprite』？#\rSprite 是 德州仪器(TI)的工程师 Daniel Hillis 在 1970 年代后期创造的一个术语，也有一种说法，该词汇来自于 TI 的经理 David Ackley。\n在计算机图形学和游戏开发领域，Sprite 指的是集成到更大场景中的独立悬浮于帧缓冲之上的的二维位图(Textrue2D)，其更多的用来表示游戏角色或者其他动态对象。\n想象一下，你有一张图片作为游戏的背景——还有另外一张图片漂浮在这个作为背景的图片上，在游戏更新的过程中，后者会移动，旋转，缩放，甚至是可交互的，就像神话中的『幽灵』或者说『精灵』。\n画家算法#\r基本思想#\r先将画面中的物体按其距离观察点的远近进行排序，结果存放在一张线形表中。距观察点远者称其优先级高，放在表头,距观察点近者称其优先级低，放在表尾，这张表称为深度优先级表。\n然后按照从表头到表尾的顺序逐个绘制物体。由于距观察者近的物体在表尾最后画出，它覆盖了远处的物体，最终在屏幕上产生了正确的遮挡关系。\n精灵动画#\r就像所有动画一样，精灵动画也是运用的人眼的视觉残留效应，那么当然，一组精灵动画就需要一组精灵图片，为了让你的游戏人物的行动看起来足够流畅，一秒完成的动作至少也需要24张图片，一个简单攻击动作的精灵图量往往在8张以上。\n精灵表单#\r为了保证精灵完全对其，我们通常要求美术绘制的角色起码得是同一个尺寸，在过去，这个尺寸往往是 2^n 次方，这也是许多库内部规定好的。当然，我们现在已经不追 2^n 次方了，但是仍然需要一个角色一系列的动画帧保持相同的大小，并且，别的角色也最好按照设定保持类似的比例。\n许多美术给图喜欢一张一张的给，那么这其实是让每张图片都成为以一个单独的纹理，并且图片中也会存在大量的留白，虽然现代引擎对这一类资源做过优化，但是不管是对内存，还是对程序员（有些美术给图之后往往就甩手不管图片的裁剪了）的头发来说，这都是一件很痛苦的事情。\n一个更好的做法是将所有的动画帧放在一张图片上，这张图片，我们叫做精灵表单，这张表单上的图片，我们希望间距足够小，并且成行成列的对齐，这样不仅能节省不少内存空间，还可以让处理素材更加快捷。\n下面我提供一个打包的小工具，大家可以试试。 TexturePacker\n当然，游戏引擎对图片的大小，长和宽都是有限制的。最好不要把所有图片都塞进一张精灵表里。\n滚屏#\r在以前简单的 2D 游戏中，比如俄罗斯方块一类，游戏中所有元素都可以在一张固定大小的小小屏幕中展现出来，但随着玩法的更新迭代，游戏的世界也越来越大，再也不是一张固定大小的图片能承载的下的了。屏幕的大小没有办法改变，但实际上可显示的图片是可与改变的，想象一下，你面前有一张巨大的画布，你用一个木框去框住一小部分，这时候你再扯动，这时候这张远超木框大小的画布的全部内容就都可以再一个小小的屏幕中全部展现出来。\n单轴滚屏#\r单轴滚动顾名思义，就是屏幕在单个轴上滚动，其实现原理也特别简单。你可以按照屏幕大小绘制出一连串的图片，在游戏进行时只需要同时绘制出两张图片就可以。图片绘制的时机你可以采用时间计算，也可以采用Trigger或者射线检测，当你给你的每张图片都加上ID，你就可以非常自由的控制下一张改出现那一张图片了。又或者你的玩家吃到什么道具，同样可以很方便的影响到下一张图片的绘制。\n无限滚屏#\r无限滚屏的原理其实和上面的单轴没有任何区别，只是说上面的图片出现顺序可能是写在策划表里的，而无限滚动是做一个循环或者随机打散组成序列。\n平行滚屏#\r当然，制作过 2D 横版卷轴游戏的同学可能会知道，我们的背景实质上是分层的，远景，中景，近景，他们的移动都是有不同的速率的。\n这会让你的游戏看起来更加真实，美术绝赞。\n四向滚屏#\r四向滚屏的数学运算确实比单轴滚屏难了一个维度，但其实解决方案也是很多的。你可以选定一个坐标原点，以你的图片的长宽为x,y轴的单位长度构建一个坐标系，后面就是简单的数学问题了，一个很简单的很符合直觉的解决方案是，渲染你的角色所在的矩阵四角的图片。实际上就是你的角色所在的矩阵的四个点为中心渲染出图片。\n很简单的算法吧，一句话就可以描述。\n瓦片地图#\r素材复用在现代游戏中是很重要的一环，相信大家都没法接受每一关都需要重新绘制一遍，尤其是对于游戏地图来说，很多花草竹石在每个场景中也都大同小异。\n瓦片地图把游戏世界划分成等分的网格（可以是等六边形也可以是平行四边形或者其他什么形状），每个方块都有其对应的精灵。一般来说游戏引擎都会提供一个瓦片地图的编辑器，一张画布，上面来绘制你的地图，一个调色板，上面是你将采用的精灵。\n参考资料#\r光栅扫描 液晶屏刷新原理和时序 AHU计算机图形学 Sprite (computer graphics) "},{"id":6,"href":"/docs/blog/","title":"Blog","section":"Topic","content":"Blog#\rFunctional Programming Paradigm\rMarch 29, 2025\rFP,\rC#\r"},{"id":7,"href":"/docs/links/","title":"Links","section":"Topic","content":"Links#\rIndividuals#\r594飞飘的个人博客\rwhisper3zzzの小窝\rSerein207的C/C\u0026#43;\u0026#43;学习笔记\rFOTH0626\rJS_KringKoter’s blog\rtimesfaner\u0026#39;s Blog\rAvidel\u0026#39;s Blog\r西洲’s blog\rOrganizations#\rSAST.Mathematics SIG\r"},{"id":8,"href":"/docs/archive/","title":"Archive","section":"Topic","content":""}]