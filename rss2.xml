<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>蛐蛐的软件开发世界</title>
    <link>https://rdququ.top/</link>
    
    <atom:link href="https://rdququ.top/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>正在学习unity中</description>
    <pubDate>Fri, 08 Dec 2023 06:03:44 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>UnityshaderGraph学习2021版</title>
      <link>https://rdququ.top/posts/1fbb4100/</link>
      <guid>https://rdququ.top/posts/1fbb4100/</guid>
      <pubDate>Fri, 08 Dec 2023 05:02:30 GMT</pubDate>
      
        
        
      <description>&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h2 id=&quot;创建&quot;&gt;创建&lt;/h2&gt;
&lt;p&gt;选择 URP 模板创建不需要配置环境 普通 3D 项目，包管理器安装 Universal RP, visual effect graph，设置中正常配置 Graphics&lt;/p&gt;
</description>
        
      
      
      
      <content:encoded><![CDATA[<span id="more"></span><h2 id="创建">创建</h2><p>选择 URP 模板创建不需要配置环境 普通 3D 项目，包管理器安装 Universal RP, visual effect graph，设置中正常配置 Graphics</p><h2 id="光照模型">光照模型</h2><p>Create =&gt; ShaderGraph =&gt; URP =&gt; Lit Shader Graph</p><p>输入属性节点： <img data-src="输入属性节点.png" alt="输入属性节点" /></p><p>属性设置： <img data-src="属性设置.png" alt="属性设置" /></p><ul><li>Precision [精度] [single/half] half 性能更好</li></ul><p>在 Universal 中</p><ul><li>Material [材质]<ul><li>[sprite Custom] 自定义精灵</li><li>[sprite Lit] 精灵光照</li><li>[sprite Unlit] 精灵非光照</li><li>[Decal] 贴花</li><li>[Lit] 光照</li><li>[Unlit] 非光照</li></ul></li><li>Allow Material Override [允许材质覆盖] [勾选] 可以通过材质检查器修改某些图形属性。</li><li>workflow [工作流] [Specular/Metallic] [勾选] 镜面高光/金属工作流</li><li>Surface Type [表面类型] [Opaque/Transparent] [半透明/不透明]</li><li>Render Face [渲染面] [Front/Back/Double] [正面/背面/双面]</li><li>Depth Write [深度写入] [Auto/Force Enabled/Force Disabled] [自动/强制开启/强制关闭]</li><li>Depth Test [深度测试] [Never/Less/Equal/LessEqual/Greater/NotEqual/GreaterEqual/Always] [从不/小于/等于/小于等于/大于/不等于/大于等于/总是]</li><li>Alpha Clipping [Alpha裁剪] [勾选]</li><li>Receive Shadows [接收阴影] [勾选]</li><li>Fragment Normal Space [片段法线空间] [Tangent/World/View] [切线/世界/视图]</li><li>Clear Coat [清漆] [勾选]</li><li>Custom Editor GUI [自定义编辑器GUI]</li><li>Supports VFXGRAph [支持VFXGRAph] [勾选]</li></ul><p>顶点着色器: <img data-src="顶点着色器.png" alt="顶点着色器" /></p><p>片段着色器: <img data-src="片段着色器.png" alt="片段着色器" /></p><p>乘法节点 Multiply: 颜色叠加</p>]]></content:encoded>
      
      
      
      
      <comments>https://rdququ.top/posts/1fbb4100/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>AABB_Plane_intersection原理详解及Unity实现</title>
      <link>https://rdququ.top/posts/2c23d1d4/</link>
      <guid>https://rdququ.top/posts/2c23d1d4/</guid>
      <pubDate>Tue, 05 Dec 2023 13:39:39 GMT</pubDate>
      
      <description>&lt;p&gt;起因是我在学习 runtime 的 mesh 切割算法，需要判断目标 mesh 是否和切面相交（不相交的话我就不需要去处理了）</description>
      
      
      
      <content:encoded><![CDATA[<p>起因是我在学习 runtime 的 mesh 切割算法，需要判断目标 mesh 是否和切面相交（不相交的话我就不需要去处理了） <span id="more"></span> ## 前提知识</p><p>Unity 的 mesh 和 collider 都使用 AABB 包围盒</p><h3 id="什么是-aabb-包围盒">什么是 AABB 包围盒？</h3><p>AABB ==&gt; Axis Aligned Bounding Box (轴对齐边界框)</p><p>AABB（轴对齐边界框）是一个 3D 框。它的宽度/高度/深度不必相等，但宽度始终与 X 轴对齐，高度与 Y 轴对齐，深度与 Z 轴对齐。也就是说，这个盒子是不能旋转的。</p><h3 id="如何表示-aabb">如何表示 AABB？</h3><p>有两种常见的方法，存储最左边和最右边的角，或者存储中心点和盒子在每侧延伸多远的向量。</p><p>第一种：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> AABB</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Vector3 min;</span><br><span class="line">    <span class="keyword">public</span> Vector3 max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> AABB</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Vector3 center;</span><br><span class="line">    <span class="keyword">public</span> Vector3 extents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img data-src="AABB表示法.png" alt="AABB表示法" /><figcaption aria-hidden="true">AABB表示法</figcaption></figure><h2 id="算法">算法</h2><p>为了测试 AABB 和平面是否相交，我们首先必须将 AABB 的每个顶点投影到平面的法线上。这使我们 AABB 的所有顶点都在一条线上。</p><p>然后，我们检查离平面最远的顶点。如果与顶点对角线相对的顶点位于平面的另一侧，则我们有一个交点。</p><p>通用的 C# 代码如下，无论你的 AABB 是如何表示的(max/min 或 center/extents)，只需要稍作修改：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Test if AABB b intersects plane p</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">TestAABBPlane</span>(<span class="params">AABB b, Plane p</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Convert AABB to center-extents representation</span></span><br><span class="line">    Point c = (b.max + b.min) * <span class="number">0.5f</span>; <span class="comment">// Compute AABB center</span></span><br><span class="line">    Point e = b.max - c; <span class="comment">// Compute positive extents</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute the projection interval radius of b onto L(t) = b.c + t * p.n</span></span><br><span class="line">    <span class="built_in">float</span> r = e[<span class="number">0</span>]*Abs(p.n[<span class="number">0</span>]) + e[<span class="number">1</span>]*Abs(p.n[<span class="number">1</span>]) + e[<span class="number">2</span>]*Abs(p.n[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute distance of box center from plane</span></span><br><span class="line">    <span class="built_in">float</span> s = Dot(p.n, c) - p.d;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Intersection occurs when distance s falls within [-r,+r] interval</span></span><br><span class="line">    <span class="keyword">return</span> Abs(s) &lt;= r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="让我们来解析这段代码">让我们来解析这段代码</h3><ol type="1"><li>函数传入了目标 Mesh 的 AABB，和目标平面</li><li>进入后的两行假设你的 AABB 是用 max/min 表示的，如果你可以轻松调取 AABB 的 center 和 extents，那么这两行是可以被跳过的</li><li>下一段代码计算了 AABB 的投影半径，这个半径是 AABB 投影到平面法线上的最大距离。</li><li>其取 AABB 的范围和平面法线的绝对值的点积，用于确保计算出的长度是正值，因为两个向量中的元素都是正值或零。<span class="math display">\[n&#39; = (\lvert n_{x} \rvert,\lvert n_{y} \rvert,\lvert n_{z} \rvert) \\ \vec{e} \cdot \vec{n&#39;} = \lvert\vec{e} \rvert \lvert\vec{n&#39;} \rvert \cos \theta \\ \lvert\vec{n&#39;} \rvert =1 \\\vec{e} \cdot \vec{n&#39;} = \lvert\vec{e} \rvert  \cos \theta\]</span></li><li>下面计算了 AABB 中心点到平面的距离，计为 s</li><li>最后的返回值即为 AABB 自身在平面法线上的距离和其中心到平面距离长短的判断</li></ol><h3 id="unity-实现">Unity 实现</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">BoundPlaneIntersect</span>(<span class="params">Mesh mesh, <span class="keyword">ref</span> Plane plane</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Compute projection interval radius</span></span><br><span class="line">        <span class="built_in">float</span> r = mesh.bounds.extents.x * Mathf.Abs(plane.normal.x) +</span><br><span class="line">            mesh.bounds.extents.y * Mathf.Abs(plane.normal.y) +</span><br><span class="line">            mesh.bounds.extents.z * Mathf.Abs(plane.normal.z);<span class="comment">//做点乘，得出mesh包围盒的范围在平面法线上的投影，包围盒在平面法线方向上的最大距离</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Compute distance of box center from plane</span></span><br><span class="line">        <span class="built_in">float</span> s = Vector3.Dot(plane.normal, mesh.bounds.center) - (-plane.distance);<span class="comment">//前面点乘得mesh中心在平面法线上的投影，这是为了确保计算出的距离和后面的平面距离在同一方向</span></span><br><span class="line">        <span class="comment">//如果法线面朝内，后- (-plane.distance)为正，前mesh中心在与相对原点相交且与平面平行的平面‘靠近平面的一侧，Vector3.Dot(plane.normal, mesh.bounds.center)为负，符合逻辑</span></span><br><span class="line">        <span class="comment">//因为mesh中心和平面在同一侧，距离为相见</span></span><br><span class="line">        <span class="comment">//若mesh中心在与 相对原点相交且与平面平行的平面‘ 远离平面的一侧，就是说mesh中心与平面中间相隔了一个原点，那么前后就都是同号，符合逻辑</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Intersection occurs when distance s falls within [-r,+r] interval</span></span><br><span class="line">        <span class="keyword">return</span> Mathf.Abs(s) &lt;= r;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料">参考资料</h2><ol type="1"><li><a href="https://gdbooks.gitbooks.io/3dcollisions/content/Chapter1/aabb.html">AABB - Axis Aligned Bounding Box</a></li><li><a href="https://docs.unity.cn/cn/2021.3/ScriptReference/Bounds.html">Bounds-Unity_Documentation</a></li></ol>]]></content:encoded>
      
      
      
      
      <comments>https://rdququ.top/posts/2c23d1d4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Unity底层如何处理C#</title>
      <link>https://rdququ.top/posts/c896f832/</link>
      <guid>https://rdququ.top/posts/c896f832/</guid>
      <pubDate>Mon, 04 Dec 2023 14:20:41 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;关键词&quot;&gt;关键词&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;.NET mono 虚拟机&lt;/li&gt;
&lt;li&gt;IL2CPP</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="关键词">关键词</h2><ul><li>.NET mono 虚拟机</li><li>IL2CPP <span id="more"></span> ### 为什么选择 mono</li></ul><p>Mono 是一个开源的 .NET 框架的实现，它可以在 Linux、Mac、Windows 等平台上运行，而且可以在这些平台上编译出可执行文件。</p><p>开源、跨平台、Mono的开发工具( MonoDevelop 现在已被弃用)</p><h3 id="为什么推出-il2cpp">为什么推出 IL2CPP</h3><ul><li>Mono 没有合法身份， 微软收购之后的版权问题</li><li>Mono 虚拟机 解释执行 .NET 字节码，效率低</li><li>有些平台不允许内置 .net 虚拟机 (eg. iOS)</li><li>如果有新的平台出现，Mono 难以为其提供支持(跨不了平台咯)，移植很麻烦(eg. WebGL)</li></ul><p>IL: Intermediate Language .NET框架中间语言, .NET字节码 IL2CPP: IL to C++，将IL转换为C++代码 --&gt; 编译为可执行文件 --&gt; native platform</p><p>Unity:</p><ol type="1"><li>Unity C/C++ 以及 native 的开发 --&gt; 跨平台的 runtime (xcode, android studio)</li><li>Unity 开发者脚本语言(C#) --&gt; .NET字节码 --&gt; .dll --&gt; IL code --&gt; IL2CPP --&gt; C++</li><li>C# GC --&gt; c++ 为其提供支持 IL2CPP vm:支持 C# .NET 独有的特性，如反射，泛型，委托，lambda表达式等</li></ol><h3 id="il2cpp-做了什么有什么优势">IL2CPP 做了什么？有什么优势？</h3><ol type="1"><li>跨平台可以执行问题 --&gt; Unity --&gt;&gt; 移植 IL2CPP --&gt; .NET 版本问题</li><li>性能获得提升 --&gt; 基于 IL2CPP 发布(而不是 Mono)</li></ol>]]></content:encoded>
      
      
      
      
      <comments>https://rdququ.top/posts/c896f832/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>线性代数在游戏开发中的基础和简单应用</title>
      <link>https://rdququ.top/posts/90745bbc/</link>
      <guid>https://rdququ.top/posts/90745bbc/</guid>
      <pubDate>Sat, 18 Nov 2023 06:08:32 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;坐标系&quot;&gt;坐标系&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;笛卡尔坐标系&lt;/li&gt;
&lt;li&gt;圆柱坐标系 垂直“高度与” &lt;span class=&quot;math inline&quot;&gt;&#92;(h&#92;)&lt;/span&gt; 、从垂直轴发出的辐射轴 &lt;span class=&quot;math inline&quot;&gt;&#92;(r&#92;)&lt;/span&gt; 、偏航角(yaw) &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;theta&#92;)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;球坐标系 俯仰角(pitch) &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;phi&#92;)&lt;/span&gt; 、偏航角(yaw) &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;theta&#92;)&lt;/span&gt; 、半径长度 &lt;span class=&quot;math inline&quot;&gt;&#92;(r&#92;)&lt;/span&gt; eg. 经纬线</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="坐标系">坐标系</h2><ul><li>笛卡尔坐标系</li><li>圆柱坐标系 垂直“高度与” <span class="math inline">\(h\)</span> 、从垂直轴发出的辐射轴 <span class="math inline">\(r\)</span> 、偏航角(yaw) <span class="math inline">\(\theta\)</span></li><li>球坐标系 俯仰角(pitch) <span class="math inline">\(\phi\)</span> 、偏航角(yaw) <span class="math inline">\(\theta\)</span> 、半径长度 <span class="math inline">\(r\)</span> eg. 经纬线 <span id="more"></span> ### 笛卡尔坐标系的左手系和右手系</li></ul><p>手握拳，伸出大拇指，四指从 <span class="math inline">\(x\)</span> 轴指向 <span class="math inline">\(y\)</span> 轴，大拇指指向 <span class="math inline">\(z\)</span> 轴，这就是右手系。</p><p>反之为左手系。</p><h2 id="向量vector">向量(vector)</h2><p>在 n 维空间中包含 modulus (模)和 direction (方向)的量。</p><h3 id="模长">模长</h3><p>向量的模长是向量的长度，用 <span class="math inline">\(||\vec{v}||\)</span> 表示。</p><p>$ |||| =  $</p><h4 id="magic-number-卡马克快速平方根">magic number (卡马克快速平方根)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">Q_rsqrt</span><span class="params">( <span class="type">float</span> number )</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> i;</span><br><span class="line">  <span class="type">float</span> x2, y;</span><br><span class="line">  <span class="type">const</span> <span class="type">float</span> threehalfs = <span class="number">1.5F</span>;</span><br><span class="line"></span><br><span class="line">  x2 = number * <span class="number">0.5F</span>;</span><br><span class="line">  y = number;</span><br><span class="line">  i = * ( <span class="type">long</span> * ) &amp;y;                       <span class="comment">// evil floating point bit level hacking</span></span><br><span class="line">  i = <span class="number">0x5f3759df</span> - (i &gt;&gt; <span class="number">1</span>);                 <span class="comment">// what the fuck?</span></span><br><span class="line">  y = * ( <span class="type">float</span> * ) &amp;i;</span><br><span class="line">  y = y * (threehalfs - ( x2 * y * y ) );    <span class="comment">// 1st iteration</span></span><br><span class="line">  y = y * (threehalfs - ( x2 * y * y ) );    <span class="comment">// 2nd iteration, this can be removed</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.bilibili.com/video/BV18j411i7bp">科普视频</a></p><p><a href="http://www.beyond3d.com/content/articles/8/">真正的作者</a></p><h3 id="归一化和单位向量">归一化和单位向量</h3><h3 id="三角形法则加减法">三角形法则（加减法）</h3><h3 id="点积">点积</h3><ul><li>投影的计算</li><li>是否共线</li></ul><h3 id="叉积">叉积</h3><ul><li>右手法则的原理</li><li>点在三角形的内/外？</li></ul><h2 id="线性插值-lerp">线性插值 (Lerp)</h2><h2 id="矩阵">矩阵</h2><h3 id="用矩阵表示点和向量">用矩阵表示点和向量</h3><h3 id="单位矩阵">单位矩阵</h3><h3 id="矩阵乘法">矩阵乘法</h3><h3 id="矩阵的转置">矩阵的转置</h3><h3 id="逆矩阵于逆矩阵的求法">逆矩阵于逆矩阵的求法</h3><p><a href="https://blog.csdn.net/daduzimama/article/details/120509856">逆矩阵的求法</a></p><h3 id="伴随矩阵">伴随矩阵</h3><h3 id="正交矩阵">正交矩阵</h3><h3 id="齐次坐标-来不及就不讲"><em>齐次坐标</em> (来不及就不讲)</h3>]]></content:encoded>
      
      
      
      
      <comments>https://rdququ.top/posts/90745bbc/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>引擎开发实战学习笔记</title>
      <link>https://rdququ.top/posts/b15b4e49/</link>
      <guid>https://rdququ.top/posts/b15b4e49/</guid>
      <pubDate>Tue, 14 Nov 2023 07:26:04 GMT</pubDate>
      
      <description>&lt;p&gt;记录</description>
      
      
      
      <content:encoded><![CDATA[<p>记录 <span id="more"></span></p><ol type="1"><li>EntryPoint</li><li>Logging</li></ol>]]></content:encoded>
      
      
      
      
      <comments>https://rdququ.top/posts/b15b4e49/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Component-Based &amp; Component-Oriented Programming</title>
      <link>https://rdququ.top/posts/c63a25c3/</link>
      <guid>https://rdququ.top/posts/c63a25c3/</guid>
      <pubDate>Sat, 11 Nov 2023 04:09:40 GMT</pubDate>
      
      <description>&lt;p&gt;一点关于 Component 的思考&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>一点关于 Component 的思考</p><span id="more"></span><h2 id="前置知识">前置知识</h2><h3 id="面向对象编程-object-oriented-programming">面向对象编程 Object Oriented Programming</h3><h4 id="继承">继承</h4><h5 id="实现继承">实现继承</h5><p>让派生类可以使用基类的接口和实现，而不需要重新编写相同的代码。目的是代码的复用。 但是实现继承会导致派生类和基类之间的强耦合，当基类的实现发生变化时，派生类也需要跟着变化。</p><h5 id="接口继承">接口继承</h5><p>接口继承是指派生类只继承基类的接口，而不继承基类的实现。目的是让更高层的调用者不需要关注具体细节，可以一视同仁的去处理他见到的所以对象。我们也会把这种思想叫做“归一化”，典型的就是<code>toString()</code>方法。</p><p>反过来也一样，高层的调用者不需要对底层的实现指手画脚，最好连告知都不需要告知他们。我们把这种策略叫做“封装”</p><h4 id="缺点">缺点</h4><ul><li>代码复用性相对差</li><li>实际开发中，对象缺少明显的父子继承关系</li><li>实现继承的强耦合性</li></ul><p>游戏世界的对象是绝对复杂的，再父子继承的过程中，我们几乎没办法找到一个父类或者祖父类让所有子类都心甘情愿的继承他。</p><p>下面可以举一个小栗子</p><p>我们有一个 <code>水陆空三栖核能魔法混动运兵器</code>，那么这个类该继承自谁呢？</p><p>或许你能搞定他的父类，但是你能搞定他的祖父类吗？战车？船只？还是飞机？</p><p>或许你会觉得这个例子太过刁钻了，但事实上，哪怕是现实世界的对象，纯粹的 OO 也会心有余而力不足。比如，弓骑兵到底是骑兵的子类还是弓手的子类？还有那个经久不衰的笑话，连裤袜倒是改继承自裤子还是袜子？虽然最高法告诉我们连裤袜就是连裤袜，但是对于一种编程范式来说，模糊和冗余是致命的。</p><p>这就是这节课我为什么要和大家谈面向组件开发。</p><h2 id="什么是面向组件编程-component-oriented-programming">什么是面向组件编程 Component-Oriented Programming</h2><h3 id="什么是组件">什么是组件</h3><p>组件的本质，就是把一些经常使用的功能或者行为抽离出来，封装成一个个独立的模块，在要使用的时候想乐高积木或者 Switch 的游戏卡带一样，组装起来或者插进我们想要构建功能的对象中就可以了。这种性质，我们也称为 PnP，即 Plug and Play, 即插即用。大家以后要熟悉这个词，在很多领域都会大量出现。</p><h2 id="另一种解决方案面向数据编程-data-oriented-programming">另一种解决方案——面向数据编程 Data-Oriented Programming</h2><h2 id="没有银弹">没有银弹</h2><p>"A":"a" "B":"b" "Sprite":4</p>]]></content:encoded>
      
      
      
      
      <comments>https://rdququ.top/posts/c63a25c3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>GAMES101Notes</title>
      <link>https://rdququ.top/posts/6206937d/</link>
      <guid>https://rdququ.top/posts/6206937d/</guid>
      <pubDate>Mon, 06 Nov 2023 13:51:16 GMT</pubDate>
      
      <description>&lt;p&gt;GAMES101Notes&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>GAMES101Notes</p><span id="more"></span><h2 id="leture-3-transform">Leture 3 Transform</h2><ul><li>Modeling -&gt;transformation, rotation, scaling eg. Camera &amp; IK</li><li>Viewing -&gt; (3D to 2D)projection</li></ul><h3 id="scale">Scale</h3><p><span class="math display">\[x&#39; = sx \\ y&#39; = sy\]</span></p><p><span class="math display">\[\begin{bmatrix}x&#39; \\y&#39; \\\end{bmatrix} =\begin{bmatrix}s &amp; 0 \\0 &amp; s \\\end{bmatrix}\begin{bmatrix}x \\y \\\end{bmatrix}\]</span></p><p><span class="math display">\[\begin{bmatrix}x&#39; \\y&#39; \\\end{bmatrix} =\begin{bmatrix}s_x &amp; 0 \\0 &amp; s_y \\\end{bmatrix}\begin{bmatrix}x \\y \\\end{bmatrix}\]</span></p><h3 id="reflection-matrix">Reflection Matrix</h3><p><span class="math display">\[x&#39; = -x \\y&#39; = -y\]</span></p><p><span class="math display">\[\begin{bmatrix}x&#39; \\y&#39; \\\end{bmatrix} =\begin{bmatrix}-1 &amp; 0 \\0 &amp; -1 \\\end{bmatrix}\begin{bmatrix}x \\y \\\end{bmatrix}\]</span></p><h3 id="shear-matrix">Shear Matrix</h3><p><span class="math display">\[x&#39; = x + ay \\y&#39; = y + bx\]</span></p><p><span class="math display">\[\begin{bmatrix}x&#39; \\y&#39; \\\end{bmatrix} =\begin{bmatrix}1 &amp; a \\b &amp; 1 \\\end{bmatrix}\begin{bmatrix}x \\y \\\end{bmatrix}\]</span></p><h3 id="rotateabount-origin00ccw-by-default绕原点逆时针">Rotate(abount origin<span class="math inline">\((0,0)\)</span>,CCW by default)『绕原点，逆时针』</h3><p><span class="math display">\[x&#39; = xcos\theta - ysin\theta \\y&#39; = xsin\theta + ycos\theta\]</span></p><p><span class="math display">\[\begin{bmatrix}x&#39; \\y&#39; \\\end{bmatrix} =\begin{bmatrix}cos\theta &amp; -sin\theta \\sin\theta &amp; cos\theta \\\end{bmatrix}\begin{bmatrix}x \\y \\\end{bmatrix}\]</span></p><p><span class="math display">\[R = \begin{bmatrix}cos\theta &amp; -sin\theta \\sin\theta &amp; cos\theta \\\end{bmatrix}\]</span></p><h3 id="linear-transform-matricesof-the-same-dimension相同">Linear Transform = Matrices(of the same dimension)『相同』</h3><p><span class="math display">\[x&#39; = ax + by \\y&#39; = cx + dy\]</span></p><p><span class="math display">\[\begin{bmatrix}x&#39; \\y&#39; \\\end{bmatrix} =\begin{bmatrix}a &amp; b \\c &amp; d \\\end{bmatrix}\begin{bmatrix}x \\y \\\end{bmatrix}\]</span></p><p><span class="math display">\[x&#39; = Mx\]</span></p><h3 id="translation">Translation</h3><p><span class="math display">\[x&#39; = x + t_x\\y&#39; = y + t_y\]</span></p><p><span class="math display">\[\begin{bmatrix}x&#39; \\y&#39; \\\end{bmatrix} =\begin{bmatrix}1 &amp; 0 \\0 &amp; 1 \\\end{bmatrix}\begin{bmatrix}x \\y \\\end{bmatrix} +\begin{bmatrix}t_x \\t_y \\\end{bmatrix}\]</span></p><p><span class="math display">\[\begin{bmatrix}x&#39; \\y&#39; \\\end{bmatrix} =\begin{bmatrix}a &amp; b \\c &amp; d \\\end{bmatrix}\begin{bmatrix}x \\y \\\end{bmatrix} +\begin{bmatrix}t_x \\t_y \\\end{bmatrix}\]</span></p><p>显然，平移不是线性变换</p><p>但是我们想要有一个大统一的概念可以描述这些变换</p><h3 id="homogeneous-coordinates齐次坐标">Homogeneous Coordinates『齐次坐标』</h3><p>Add a third coordinate <span class="math inline">\(w\)</span> to <span class="math inline">\((x,y)\)</span></p><ul><li>2D point: <span class="math inline">\(= (x,y,1)^T\)</span></li><li>2D vector: <span class="math inline">\(= (x,y,0)^T\)</span></li></ul><p>Maxtrix representation of translation</p><p><span class="math display">\[\begin{bmatrix}x&#39; \\y&#39; \\w&#39; \\\end{bmatrix} =\begin{bmatrix}1 &amp; 0 &amp; t_x \\0 &amp; 1 &amp; t_y \\0 &amp; 0 &amp; 1 \\\end{bmatrix} ·\begin{bmatrix}x \\y \\1 \\\end{bmatrix} =\begin{bmatrix}x + t_x \\y + t_y \\1 \\\end{bmatrix}\]</span></p><p><span class="math inline">\(w\)</span> 的意义是什么呢？</p>In homogeneous coordinates, $<span class="math display">\[\begin{bmatrix}x \\y \\w \\\end{bmatrix}\]</span>$ is the 2D point $<span class="math display">\[\begin{bmatrix}\frac{x}{w} \\\frac{y}{w} \\1\end{bmatrix}\]</span><p>, w  $</p><h3 id="d-transformations">2D transformations</h3><h4 id="scale-1">scale</h4>$ S(s_x,s_y) =<span class="math display">\[\begin{bmatrix}s_x &amp; 0 &amp; 0 \\0 &amp; s_y &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span><p>$</p><h4 id="rotate">rotate</h4>$ R() =<span class="math display">\[\begin{bmatrix}cos\theta &amp; -sin\theta &amp; 0 \\sin\theta &amp; cos\theta &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span><p>$</p><h4 id="shear">shear</h4>$ H(a,b) =<span class="math display">\[\begin{bmatrix}1 &amp; a &amp; 0 \\b &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span><p>$</p><h4 id="translate">translate</h4>$ T(t_x,t_y) =<span class="math display">\[\begin{bmatrix}1 &amp; 0 &amp; t_x \\0 &amp; 1 &amp; t_y \\0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span><p>$</p><h3 id="inverse-transform">Inverse transform</h3><p>逆变换刚好对应逆矩阵</p><h2 id="lecture-4-transformation-cont">Lecture 4 Transformation Cont</h2><p><a href="https://blog.csdn.net/daduzimama/article/details/120509856">逆矩阵的求法</a></p><p>当一个矩阵的逆等同于他的伴随矩阵，那么这个矩阵是正交矩阵。</p><p>旋转矩阵是正交矩阵</p><h3 id="d-transformations-1">3D transformations</h3><ul><li><p>Scale $ S(s_x,s_y,s_z) =</p><span class="math display">\[\begin{bmatrix}s_x &amp; 0 &amp; 0 &amp; 0 \\0 &amp; s_y &amp; 0 &amp; 0 \\0 &amp; 0 &amp; s_z &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span><p>$</p></li><li><p>Translate $ T(t_x,t_y,t_z) =</p><span class="math display">\[\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; t_x \\0 &amp; 1 &amp; 0 &amp; t_y \\0 &amp; 0 &amp; 1 &amp; t_z \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span><p>$</p></li><li><p>Rotate(Around x-, y-, z-axis) $ R_x() =</p><span class="math display">\[\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; cos\theta &amp; -sin\theta &amp; 0 \\0 &amp; sin\theta &amp; cos\theta &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span><p>\ $ $ R_y() =</p><span class="math display">\[\begin{bmatrix}cos\theta &amp; 0 &amp; sin\theta &amp; 0 \\0 &amp; 1 &amp; 0 &amp; 0 \\-sin\theta &amp; 0 &amp; cos\theta &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span><p>\ $ $ R_z() =</p><span class="math display">\[\begin{bmatrix}cos\theta &amp; -sin\theta &amp; 0 &amp; 0 \\sin\theta &amp; cos\theta &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span><p>$</p></li></ul><h4 id="rodrigues-rotation-formula罗德里格斯旋转公式">Rodrigues' Rotation Formula『罗德里格斯旋转公式』</h4><p>Rotation by angle <span class="math inline">\(\alpha\)</span> around axis <span class="math inline">\(n\)</span></p>$ (,) = cos() + (1-cos())^T + sin()N\ N =<span class="math display">\[\begin{bmatrix}0 &amp; -n_z &amp; n_y \\n_z &amp; 0 &amp; -n_x \\-n_y &amp; n_x &amp; 0 \\\end{bmatrix}\]</span><p>$</p><h3 id="viewing-transformation观测变换">Viewing transformation『观测变换』</h3><h3 id="view-camera-transformation视图变换">View / Camera transformation『视图变换』</h3><h3 id="projection-transformation投影变换">Projection transformation『投影变换』</h3><h4 id="orthographic-projection正交投影">Orthographic projection『正交投影』</h4><ul><li>相机置于原点，面朝 -z 轴</li><li>丢掉 z 轴</li><li>Translate and scale to <span class="math inline">\([-1,1]^2\)</span></li></ul><h5 id="in-general">In general</h5><ul><li>We want to map a cuboid <span class="math inline">\([l,r] \times [b,t] \times [\boldsymbol f,\boldsymbol n]\)</span> to the "canonical" cube<span class="math inline">\([-1,1]^3\)</span></li></ul><h6 id="transformation-matrix">Transformation matrix</h6><p>Translate(center to origin) -&gt; Scale(length/width/height to 2)</p>$ M_{ortho} =<span class="math display">\[\begin{bmatrix}\frac{2}{r-l} &amp; 0 &amp; 0 &amp; 0 \\0 &amp; \frac{2}{t-b} &amp; 0 &amp; 0 \\0 &amp; 0 &amp; \frac{2}{\boldsymbol n-\boldsymbol f} &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span>·<span class="math display">\[\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; -\frac{r+l}{2} \\0 &amp; 1 &amp; 0 &amp; -\frac{t+b}{2} \\0 &amp; 0 &amp; 1 &amp; -\frac{\boldsymbol n+\boldsymbol f}{2} \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span>=<span class="math display">\[\begin{bmatrix}\frac{2}{r-l} &amp; 0 &amp; 0 &amp; -\frac{r+l}{r-l} \\0 &amp; \frac{2}{t-b} &amp; 0 &amp; -\frac{t+b}{t-b} \\0 &amp; 0 &amp; \frac{2}{\boldsymbol n-\boldsymbol f} &amp; -\frac{\boldsymbol n+\boldsymbol f}{\boldsymbol n-\boldsymbol f} \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span><p>$</p><h4 id="perspective-projection透视投影">Perspective projection『透视投影』</h4><ul><li>First "aquish" the frustum into a cuboid <span class="math inline">\((n \rightarrow n, f \rightarrow f)(M_{persp \rightarrow ortho})\)</span></li><li>Do orthographic projection</li></ul><ol type="1"><li><p>In order to find a transformation</p><ul><li>Find the relationship between transformed points <span class="math inline">\((x&#39;,y&#39;,z&#39;)\)</span> and original points <span class="math inline">\((x,y,z)\)</span></li><li><span class="math inline">\(y&#39; = \frac{n}{z}y\\ x&#39; = \frac{n}{z}x\)</span> --&gt; similar to <span class="math inline">\(y&#39;\)</span></li></ul></li><li><p>In homogeneous corrdinates</p></li></ol>$<span class="math display">\[\begin{bmatrix}x \\y \\z \\1 \\\end{bmatrix} \xrightarrow{M_{persp \rightarrow ortho}}\begin{bmatrix}\frac{n}{z}x \\\frac{n}{z}y \\unknown \\1 \\\end{bmatrix} \xlongequal{mult. by z}\begin{bmatrix}nx \\ny \\unknown \\z \\\end{bmatrix}\]</span><p>$</p><p>显然，我们可以逆推出 <span class="math inline">\(M_{persp \rightarrow ortho}\)</span> 长这样</p>$ M_{persp ortho} =<span class="math display">\[\begin{bmatrix} n &amp; 0 &amp; 0 &amp; 0 \\0 &amp; n &amp; 0 &amp; 0 \\? &amp; ? &amp; ? &amp; ? \\0 &amp; 0 &amp; 1 &amp; 0 \\\end{bmatrix}\]</span><p>$</p><p>近和远处的 <span class="math inline">\(z\)</span> 不会发生变化</p><p>把 z 代换成 n，n 是我们取得特殊定值</p>$<span class="math display">\[\begin{bmatrix}x \\y \\z \\1 \\\end{bmatrix}\]</span>=<span class="math display">\[\begin{bmatrix}nx \\ny \\unknown \\z \\\end{bmatrix} \xrightarrow{replace\space z\space with\space n}\begin{bmatrix}x \\y \\n \\1 \\\end{bmatrix} \rightarrow\begin{bmatrix}nx \\ny \\n^2 \\n \\\end{bmatrix}\]</span><p>$</p><p>我们现在要求解第三行，且我们知道 x 轴和 y 轴对 z 轴没有影响, 因为最终的结果中没有 x 和 y</p>$<span class="math display">\[\begin{bmatrix}0\space 0\space A\space B\end{bmatrix}\]</span>·<span class="math display">\[\begin{bmatrix}x \\y \\n \\1 \\\end{bmatrix}\]</span><p>= n^2 $</p><p>我们可以推出</p>$<span class="math display">\[\begin{bmatrix}0 &amp; 0 &amp; A &amp; B\end{bmatrix}\]</span>·<span class="math display">\[\begin{bmatrix}x \\y \\n \\1 \\\end{bmatrix}\]</span><p>= n^2  An + B = n^2 $</p><p>我们又知道任何点的 z 坐标在远平面上都不会变化，所以我们可以推出</p>$<span class="math display">\[\begin{bmatrix}0 \\0 \\f \\1 \\\end{bmatrix} \Rightarrow\begin{bmatrix}0 \\0 \\f \\1 \\\end{bmatrix}\]</span>==<span class="math display">\[\begin{bmatrix}0 \\0 \\f^2 \\f \\\end{bmatrix} \Rightarrow\]</span><p>Af + B = f^2 $</p><p>解得</p><p>$ A = n+f \ B = -nf $</p><p>所以</p>$ M_{persp ortho} =<span class="math display">\[\begin{bmatrix} n &amp; 0 &amp; 0 &amp; 0 \\0 &amp; n &amp; 0 &amp; 0 \\0 &amp; 0 &amp; n+f &amp; -nf \\0 &amp; 0 &amp; 1 &amp; 0 \\\end{bmatrix}\]</span><p>$</p>$ M_{persp} = M_{ortho} · M_{persp ortho} =<span class="math display">\[\begin{bmatrix}\frac{2}{r-l} &amp; 0 &amp; 0 &amp; -\frac{r+l}{r-l} \\0 &amp; \frac{2}{t-b} &amp; 0 &amp; -\frac{t+b}{t-b} \\0 &amp; 0 &amp; \frac{2}{\boldsymbol n-\boldsymbol f} &amp; -\frac{\boldsymbol n+\boldsymbol f}{\boldsymbol n-\boldsymbol f} \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span>·<span class="math display">\[\begin{bmatrix} n &amp; 0 &amp; 0 &amp; 0 \\0 &amp; n &amp; 0 &amp; 0 \\0 &amp; 0 &amp; n+f &amp; -nf \\0 &amp; 0 &amp; 1 &amp; 0 \\\end{bmatrix}\]</span>=<span class="math display">\[\begin{bmatrix}\frac{2n}{r-l} &amp; 0 &amp; \frac{r+l}{r-l} &amp; 0 \\0 &amp; \frac{2n}{t-b} &amp; \frac{t+b}{t-b} &amp; 0 \\0 &amp; 0 &amp; \frac{n+f}{n-f} &amp; \frac{2nf}{n-f} \\0 &amp; 0 &amp; 1 &amp; 0 \\\end{bmatrix}\]</span><p>$</p><h2 id="rasterizationtriangles光栅化">Rasterization(Triangles)光栅化</h2><p>定义 field of view(fovY)垂直的可视角度 和 aspect ratio(w/h)屏幕长宽比 <img data-src="垂直可视角度和屏幕长宽比.png" alt="垂直可视角度和屏幕长宽比" /> n:near, t:top, b:bottom, l:left, r:right</p><p>视口变换</p><p><span class="math display">\[\begin{bmatrix}x \\y \\z \\1 \\\end{bmatrix} =\begin{bmatrix}\frac{w}{2} &amp; 0 &amp; 0 &amp; \frac{w}{2} \\0 &amp; \frac{h}{2} &amp; 0 &amp; \frac{h}{2} \\0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{bmatrix}·\begin{bmatrix}x \\y \\z \\1 \\\end{bmatrix}\]</span></p><h3 id="sample-采样">Sample 『采样』</h3><ul><li>Sample if center of pixel is inside triangle</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">Inside</span>(<span class="params">tri,x,y</span>)</span> =&gt; Point(x,y) <span class="keyword">in</span> tri ? <span class="number">1</span> : <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> y = <span class="number">0</span>; y &lt; h; y++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> x = <span class="number">0</span>; x &lt; w; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        image[x][y] = Inside(tri,x + <span class="number">0.5f</span>,y + <span class="number">0.5f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">做叉积判断点 Q 是否在 tri 内</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">P0</span></span><br><span class="line"><span class="comment">|\</span></span><br><span class="line"><span class="comment">| \    *Q</span></span><br><span class="line"><span class="comment">|  \</span></span><br><span class="line"><span class="comment">|___\P2</span></span><br><span class="line"><span class="comment">P1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>采样率低 =&gt; 走样 =&gt; 锯齿...</p><h3 id="anti-aliasing反走样抗锯齿">Anti-aliasing『反走样/抗锯齿』</h3><p>采样之前做一个滤波(filtering)</p><ul><li>Frequency『频率』</li><li>Frequency domain『频域』</li></ul><h4 id="数字信号处理相关的前置知识">数字信号处理相关的前置知识</h4><p>傅里叶变换 =&gt; 把函数从时域转换到频域 <img data-src="时域到频域.png" alt="时域到频域" /></p><ul><li>Low-pass filter『低通滤波器』</li><li>High-pass filter『高通滤波器』</li><li>Band-pass filter『带通滤波器』</li><li>Band-stop filter『带阻滤波器』</li><li>Gaussian filter『高斯滤波器』</li><li>Box filter『盒子滤波器』 ...</li></ul><p>Filtering = Convolution『卷积』= Average『平均』= Blurring『模糊』</p><p>时域卷积 = 频域乘积</p><figure><img data-src="时域图到频谱图.png" alt="时域图到频谱图" /><figcaption aria-hidden="true">时域图到频谱图</figcaption></figure><p>采样是重复原始信号的频谱</p><ul><li>采样定理: 在进行模拟/数字信号的转换过程中，当采样频率fs.max大于信号中最高频率fmax的2倍时(fs.max&gt;2fmax)，采样之后的数字信号完整地保留了原始信号中的信息，一般实际应用中保证采样频率为信号最高频率的2.56～4倍；采样定理又称奈奎斯特定理。</li></ul><p><a href="https://zhuanlan.zhihu.com/p/74736706">采样定理，频谱混叠和傅里叶变换 深入理解</a></p><p>这篇文章很好地解释了为什么"对于一个连续的信号采样，采样后的频谱相当于将采样前的频谱进行延拓" <a href="https://www.projectrhea.org/rhea/index.php/2015_Fall_ECE_438_Boutin_A_visual_explanation_of_aliasing_and_repetition_with_the_DTFT_Erik_Swan">A visual explanation of aliasing and repetition with the DTFT</a></p><blockquote><p>时域采样得到的离散信号并不只代表这个时域信号，有无数多个频率不同的信号的采样结果是一样的，也就导致了频域上的周期延拓</p></blockquote><p>有无数个高频分量可以匹配相同的离散数据，因此离散信号的频域包含所有这些频率。 <img data-src="连续信号采样频谱拓展的解释.gif" alt="连续信号采样频谱拓展的解释" /></p><p>当延拓的图形重合的时候，我们就认定这时候发生了走样。</p><p>要反走样，最直接的办法就是增加采样率，在现实中的意义就是“换一个更好的分辨率更好的显示器”（让图形之间离得更远） 从算法/软件角度来说，我们也可以采用之前的在采样前添加滤波的方法。我们可以给图像添加一个低通滤波，把高频的信息去掉。（让图形更瘦）</p><h4 id="antialiasing-by-supersampling超采样msaa">Antialiasing By Supersampling『超采样』(MSAA)</h4><p>将一个像素近似认为更多的像素 =&gt; 给一个像素内部增加更多的采样点 =&gt; 工业界的做法</p><h4 id="fast-approximate-antialiasing快速近似反走样抗锯齿fxaa">Fast Approximate Antialiasing『快速近似反走样/抗锯齿』(FXAA)</h4><p>图像的后期处理 =&gt; 通过图像匹配的办法把存在锯齿的边界找到，并且更换成没有锯齿的边界 =&gt; 效率高</p><h4 id="temporal-antialiasing时域反走样抗锯齿taa">Temporal Antialiasing『时域反走样/抗锯齿』(TAA)</h4><p>静态场景中 =&gt; 复用上一帧感知的结果 =&gt; 相当于把 MSAA 对应的样本分布在了时间上，并且在当前帧没有引入任何额外操作</p><h3 id="z-buffering深度缓冲">Z-buffering『深度缓冲』</h3><h4 id="painters-algorithm画家算法">Painter's Algorithm『画家算法』</h4><h5 id="基本思想">基本思想</h5><p>先将画面中的物体按其距离观察点的远近进行排序，结果存放在一张线形表中。距观察点远者称其优先级高，放在表头,距观察点近者称其优先级低，放在表尾，这张表称为深度优先级表。</p><p>然后按照从表头到表尾的顺序逐个绘制物体。由于距观察者近的物体在表尾最后画出，它覆盖了远处的物体，最终在屏幕上产生了正确的遮挡关系。</p><h5 id="缺陷">缺陷</h5><figure><img data-src="画家算法的缺陷.png" alt="画家算法的缺陷" /><figcaption aria-hidden="true">画家算法的缺陷</figcaption></figure><h4 id="z-buffer">Z-Buffer</h4><ul><li>frame buffer 存贮当前看到的场景</li><li>depth buffer 存储每个像素所看到的几何物体最浅的深度的信息</li></ul><figure><img data-src="深度缓存.png" alt="深度缓存" /><figcaption aria-hidden="true">深度缓存</figcaption></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Initialize depth buffer to +∞</span><br><span class="line"></span><br><span class="line">During rasterization:</span><br><span class="line">  <span class="keyword">for</span>(each triangle T)</span><br><span class="line">    <span class="keyword">for</span>(each sample (x,y,z) in T)</span><br><span class="line">      <span class="keyword">if</span>(z &lt; zbuffer[x,y])<span class="comment">// 如果该像素的深度小于此坐标深度缓存记录的深度</span></span><br><span class="line">        zbuffer[x,y] = z;<span class="comment">//更新深度</span></span><br><span class="line">        framebuffer[x,y] = color;<span class="comment">//更新 rgb</span></span><br></pre></td></tr></table></figure><p>处理不了透明物体</p><h3 id="shading着色">Shading『着色』</h3><p>The process of applying a material to an object.</p><h4 id="blinnphong-reflection-model布林-冯反射模型">Blinn–Phong reflection model『布林-冯反射模型』</h4><ul><li>Ambient『环境光』</li><li>Diffuse『漫反射』</li><li>Specular『镜面反射/高光』</li></ul><p>Compute light reflected toward camera at a specific <strong>shading point</strong> Inputs:</p><ul><li>Viewer direction，观察方向，使用v表示</li><li>Surface normal，法线方向，使用n表示</li><li>Light direction，光线方向，使用l(小写的L)表示</li></ul><figure><img data-src="shading_point.png" alt="shading_point" /><figcaption aria-hidden="true">shading_point</figcaption></figure><p>Shading is Local =&gt; 着色不考虑其他物体的影响，只考虑着色点自身，故而只有明暗，没有阴影</p><h5 id="diffuse-reflection">Diffuse Reflection</h5><p>从接收角度看： In general, light per unit area is proportional to the cosine of the angle between the light direction and the surface normal =&gt; <span class="math inline">\(\cos\theta=l\cdot n\)</span></p><p>从输出角度看 <img data-src="LightFalloff.png" alt="LightFalloff" /> 光的能量会在传播中被“稀释”，一个单位面积上接收到的光的能量和光线传播的距离的平方成反比 =&gt; <span class="math inline">\(I/r^2\)</span></p><p>综合来看 <span class="math inline">\(L_d = k_d(I/r^2)max(0,\vec{n}\cdot\vec{l})\)</span> <span class="math inline">\(L_d\)</span> is diffusely <span class="math inline">\(k_d\)</span> is diffuse coefficient(color) <span class="math inline">\(I/r^2\)</span> is energy arrived at the shading point <span class="math inline">\(max(0,\vec{n}\cdot\vec{l})\)</span> is energy recevied by the shading point</p><p>观察方向对漫反射像完全没有影响 =&gt; 因为反射是完全随机的，因此可以认为漫反射光在任何反射方向上的分布都是一样的</p><h5 id="ambient-lighting">Ambient lighting</h5><p>参考： <a href="https://zhuanlan.zhihu.com/p/442023993">Blinn-Phong光照模型从定义到实现</a></p><h2 id="参考资料">参考资料</h2><ol type="1"><li><a href="https://www.bilibili.com/video/BV1X7411F744">闫令祺-GAMES101</a></li><li><a href="https://zhuanlan.zhihu.com/p/442023993">Blinn-Phong光照模型从定义到实现</a></li></ol>]]></content:encoded>
      
      
      <category domain="https://rdququ.top/categories/%E5%AD%A6%E4%B9%A0%E5%90%91/">学习向</category>
      
      <category domain="https://rdququ.top/categories/%E5%AD%A6%E4%B9%A0%E5%90%91/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/">计算机图形学</category>
      
      
      <category domain="https://rdququ.top/tags/GAMES101Notes/">GAMES101Notes</category>
      
      
      <comments>https://rdququ.top/posts/6206937d/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>GAMES104Notes</title>
      <link>https://rdququ.top/posts/32cb02ce/</link>
      <guid>https://rdququ.top/posts/32cb02ce/</guid>
      <pubDate>Mon, 06 Nov 2023 04:49:57 GMT</pubDate>
      
      <description>&lt;p&gt;GAMES104Notes&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>GAMES104Notes</p><span id="more"></span><figure><img data-src="GAMES104_Zoo%20of%20Game%20Engines-1.png" alt="AMES104_Zoo of Game Engines-1" /><figcaption aria-hidden="true">AMES104_Zoo of Game Engines-1</figcaption></figure><figure><img data-src="GAMES104_Middlewares.png" alt="GAMES104_Middlewares" /><figcaption aria-hidden="true">GAMES104_Middlewares</figcaption></figure><h2 id="引擎的基本架构">引擎的基本架构</h2><p>自顶向底的五层架构</p><ul><li>Tool Layer 工具链和编辑环境</li><li>Function Layer 游戏逻辑设计</li><li>Resource Layer 处理存储不同种类的文件资源</li><li>Core Layer 构建功能</li><li>Platform Layer 硬件的运行环境，输入设备的差别，软件的发布平台</li></ul><h3 id="resource-layer">resource layer</h3><p>importing: resource -&gt; asset</p><p>全局唯一编号: GUID</p><p>Runtime Asset Manager</p><p>Manager Asset Life Cycle</p><h3 id="function-layer">Function Layer</h3><p>tick &amp; frame</p><p>Multi-threading</p><h3 id="core-layer">Core Layer</h3><p>Math Library</p><p>Math Efficiency eg. Quick and dirty hacks</p><ul><li>Carmack's 1/sqrt(x)</li><li>Magic number</li></ul><p>eg. SIMD<img data-src="SIMD-1.png" alt="Alt text" /></p><p>Data Structure and Containers</p><p>Memory Management</p><p>Foundation of Game Engine</p><h3 id="platform-layer">Platform Layer</h3><p>Target on Different Platform</p><p>Graphics API eg. Render Hardware Interface(RHI)</p><p>Hardware Architecture</p><h3 id="tool-layer">Tool Layer</h3><p>Allow Anyone to Create Game</p><p>Digital Content Creation(DCC)</p><h2 id="如何构建游戏世界">如何构建游戏世界</h2><h3 id="game-objectgo">game object(GO)</h3><h4 id="property">property</h4><h4 id="behavior">behavior</h4><h4 id="oop-vs.-component">OOP vs. Component</h4><p>OOP 也符合直觉，但是在复杂的游戏世界中并没有非常清晰的父子继承关系。</p><p>现在更多地使用 Component 的方式，将游戏对象的行为分解为多个组件，每个组件只负责一种行为。</p><h4 id="component-based-tick">Component-based Tick</h4><p>和曾经分GO Tick不同，现在是分Component Tick。由于 pipeline 效率更高</p><h4 id="go-间通信">GO 间通信</h4><ul><li>Hard Code</li><li>Event</li><li>uid</li></ul><h4 id="scene-management">Scene Management</h4><ol type="1"><li><p>No division &amp; Drived by grid</p></li><li><p>Spatial Data Structures</p><ul><li>Quadtree</li><li>Octree</li><li>Binary Space Partitioning(BSP)</li><li>Bounding Volume Hierarchy(BVH)</li><li>Scene Graph</li></ul></li></ol><h2 id="rendering">Rendering</h2><h3 id="basics-of-game-rendering">Basics of Game Rendering</h3><h4 id="gpu">GPU</h4><h5 id="simdsingle-instruction-multiple-data单指令多数据">SIMD(Single Instruction Multiple Data/单指令多数据)</h5><p><code>SMID_ADD c, a, b</code></p><h5 id="simtsingle-instruction-multiple-thread单指令多线程">SIMT(Single Instruction Multiple Thread/单指令多线程)</h5><p><code>SIMT_ADD c, a, b</code></p><h5 id="gpu-architecture">GPU Architecture</h5><ul><li>GPC(Graphics Processing Cluster)</li><li>SM(Streaming Multiprocessor)</li><li>Texture Units</li><li>CUDA Core</li><li>Warp</li></ul><figure><img data-src="GAMES101_GPU_Architecture.png" alt="GPU Architecture" /><figcaption aria-hidden="true">GPU Architecture</figcaption></figure><h5 id="data-flow-from-cpu-to-gpu">Data Flow From CPU to GPU</h5><ul><li>CPU and Main Memory</li><li>CPU to GPU</li><li>GPU and Video Memory</li></ul><p>尽可能让数据单向传输，从 CPU 到 GPU 尽可能不要从 GPU 里读数据</p><h5 id="be-aware-of-cache-efficiency">Be Aware of Cache Efficiency</h5><p>数据一定要放在一起为 Cache(缓存) 做准备</p><h5 id="gpu-bounds-and-performance">GPU Bounds and Performance</h5><h4 id="renderable">Renderable</h4><h5 id="mesh">Mesh</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span></span><br><span class="line">&#123;</span><br><span class="line">  Vector3 m_position;</span><br><span class="line">  <span class="comment">// other attributes</span></span><br><span class="line">  UByte4 m_color;</span><br><span class="line">  Vector3 m_normal;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mesh</span></span><br><span class="line">&#123;</span><br><span class="line">  Vertex m_vertex[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>Vertex Data<ul><li>Vertex declaration</li><li>Vertex buffer</li></ul></li><li>Index Data<ul><li>Index declaration</li><li>Index buffer</li></ul></li></ul><p>Triangle Strip 利好 Cache</p><h3 id="material-shader-and-lighting">Material, Shader, and Lighting</h3><h3 id="special-rendering">Special Rendering</h3><h3 id="pipeline">Pipeline</h3>]]></content:encoded>
      
      
      <category domain="https://rdququ.top/categories/%E5%AD%A6%E4%B9%A0%E5%90%91/">学习向</category>
      
      <category domain="https://rdququ.top/categories/%E5%AD%A6%E4%B9%A0%E5%90%91/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/">游戏引擎</category>
      
      
      <category domain="https://rdququ.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/">计算机图形学</category>
      
      <category domain="https://rdququ.top/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/">游戏引擎</category>
      
      <category domain="https://rdququ.top/tags/GAMES104/">GAMES104</category>
      
      
      <comments>https://rdququ.top/posts/32cb02ce/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2D图形——渲染、精灵和简单应用</title>
      <link>https://rdququ.top/posts/220dd5af/</link>
      <guid>https://rdququ.top/posts/220dd5af/</guid>
      <pubDate>Sun, 05 Nov 2023 14:03:42 GMT</pubDate>
      
      <description>&lt;p&gt;2D 渲染基础&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>2D 渲染基础</p><span id="more"></span><h2 id="像素缓冲区和垂直同步">像素缓冲区和垂直同步</h2><h3 id="crt-显示器基础">CRT 显示器基础</h3><p>现在大家用的比较多的是液晶显示器(LCD), 在早先年，大家用的 CRT 显示器比较多，也就是阴极管射线显示器。LCD 通过控制是否透光来控制亮和暗，当色彩不变时，液晶也保持不变，这样就无须考虑刷新率的问题。对于画面稳定、无闪烁感的液晶显示器，刷新率不高但图像也很稳定。不过对于我们今天要谈的游戏来说，缺点就很明显了，其相应速度不够，画面有时候会有重影。</p><p>当然，我们这节课的主题是 2D 游戏渲染基础，和大家聊显示器主要也是让大家更好的了解我们渲染操作生成后呈现的载体。</p><p>其实 LCD 和 CRT 显示器在刷新上的原理是差不多的，当然我们前面也说了，在早点年，CRT 显示器是当时的主流，综合考虑，也是为了让大家了解 2D 渲染这项技术在诞生之初的显示设备的环境，我打算从 CRT 显示器的角度带大家聊聊显示器的工作原理。</p><p>大家高中信息课应该教过，在 CRT 显示器内部，绘制图形是通过电子枪发射电子流完成的。这样讲可能比较抽象。其实，在显示器内部有一层荧光板，荧光板上面有一些荧光粉末，红绿蓝三种颜色的荧光粉末，单色的荧光粉末会聚集起来形成一个小小的荧光单元。红绿蓝三种单元各出一个聚集在一起就是一个像素点，密密麻麻的像素点就充斥在荧光板上了。 电子枪则会一口气发射三注电子流，很好理解，这些电子流依次打在了 RGB 三色上，由于电子流的强度不一样，每个像素点的红绿蓝三色的光也不一样，通过空间混色法，每个像素点就会呈现出不同的颜色。</p><p>当然，电子流的能量是有限的，这些荧光粉很快就会熄灭，所以电子枪需要不断的发射电子流，这样才能保证荧光粉不断的发光，显示器才能一直显示图像。这就是刷新了。</p><p>不过要想让画面动起来，而不是显示器上某个像素点一直再发不同的光，然而其他地方却一片黑，我们的电子流就要去射击不同的像素点，让整个显示器都呈现出画面。我们管这叫扫描。当然这里也运用到了人眼的视觉残留效应，想必大家很清楚。</p><p>当然扫描也不是乱扫的，是有章法有规则的，请看下图。</p><figure><img data-src="CRT显示器扫描.png" alt="CRT显示器扫描" /><figcaption aria-hidden="true">CRT显示器扫描</figcaption></figure><p>这张图大家肯定超级熟悉吧。电子枪从左上角向右扫，然后再从右向左扫，直到扫完整个屏幕。欸，我估计聪明的小伙伴已经发现了，这个扫描线不是绝对水平的，而是略微带一点倾斜。这也是为了让扫描线能扫过整个屏幕而不是只在一条横线上来回扫。从左向右扫的每条扫描线都略微下坡，其实这个下坡的度数是可以算出来的，其斜率大约为 -1/水平分辨率, 非常好算，我就不带大家算一遍了。</p><h4 id="消隐期-blank">消隐期 BLANK</h4><p>其实，在 CRT 显示器中，从右向左的这一条扫描线往往不会真实的扫描，而是消隐，大家可以理解为电子枪在这段时间不喷了，画面上一片漆黑。这个时间段我们称为<strong>行消隐期(HBLANK)</strong>，也可以叫做水平回扫。</p><p>啥是行？电子束既要作水平方向的运动，又要作垂直方向的运动。前者形成一行的扫描，称为行扫描，后者形成一幅画面的扫描，称为场扫描。</p><p>当电子流从左上角扫到右下角后，屏幕就完成了一帧的渲染，不过这时候电子枪指着右下角啊，难道说下一帧是从右下角原路返回右上角吗？听起来好像效率挺高的，不过我们实际上不会这么干。而是让电子枪直接从右下角跳到右上角，然后再从右上角开始扫描。电子枪从右下角移动到左上角的的过程，我们称作<strong>场消隐期(VBLANK)</strong>，也可以叫做垂直回扫。同样的，这段时间内，画面上也是一片漆黑的。</p><h4 id="垂直同步">垂直同步</h4><p>前面我们已经谈过了画面撕裂的原理，是渲染帧数超过刷新率，在显示器才显示到一半时就粗暴的给他塞了新的画面进去。 那后来人是怎么解决这个问题的呢？很简单，就是在显示器刷新的时候，我们不提交渲染，直到等显示器刷新完了。这样就不会出现画面撕裂的问题了。这个技术就是<strong>垂直同步(VSYNC)</strong>。</p><p>简单来说就是渲染循环受到真实刷新率的支配嘛。让游戏渲染的输出频率对标设备的刷新率，游戏的主循环又会和渲染循环相互制约，游戏的帧率也就被限制在了设备的刷新率上。当然这也会造成输入延迟，这一点不理解的同学可以去听我上一节的课，讲的很清楚。</p><p>下面来点<strong>套话</strong><br />为了同步显示屏的显示过程和控制器，控制器会产生一系列的定时信号。当电子枪换行进行扫描时，控制器会发出一个<strong>水平同步信号 HSync</strong>；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，控制器会发出一个<strong>垂直同步信号 VSync</strong>。</p><p>VSYNC信号有效时，表示一帧数据的开始。</p><h3 id="像素缓冲区">像素缓冲区</h3><p>缓冲区是一个很好理解的概念，图像从我们的 GPU 到屏幕上并不是实时的一步到位的。在 GPU 内存上有一系列的缓冲区用来暂存渲染数据。</p><p>我们在屏幕上展示出来的图像实际上是存储来 GPU 内存里面的。现代的硬件也足够支撑高分辨率的图像存在内存中，然而，这并不意味着我们就可以高枕无忧了。游戏循环仍然要像我们之前反复强调的那样考虑到 CRT(或者其他什么) 的电子枪。请试想，当 CRT 喷枪才在屏幕中喷到一半的时候，缓冲区就写入了新的数据，等这帧渲染完成后，显示器就会显示出一半新的画面，一半旧的画面，这就是我们前面说的画面撕裂。更糟糕的是，新数据提交的时候，上一帧还没开始绘制，那么就不是说屏幕中同时存在新的和旧的画面了，而是直接丢失了上一帧的画面。</p><p>为了解决这个问题，早期的开发者想出了一种现在我们已经很难接受的办法，那就是等到场消隐期再开始渲染，但这样的做法带来的弊端也很明显，游戏循环被完全锁死在了显示器的刷新率上了。</p><p>当然，还有另一种解决方案-多缓冲技术。我们可以在 GPU 内存中准备多个缓冲区，游戏循环可以将图像写入缓冲区A，这时屏幕正在绘制缓冲区B，等到下一帧，屏幕显示缓冲区A，游戏循环则将图像写入缓冲区B，由于屏幕和游戏循环的工作是交替进行的，所以我们可以保证屏幕显示的是完整的一帧画面。</p><p>为了完全消灭画面撕裂，缓冲区的交换必须在场消隐期进行，这就是我们之前一直说的<strong>垂直同步</strong>。</p><p>当然，这种技术的前提有两个，一个是交换缓冲区的速度足够快，在绝大多数场景下，这一点是不会变的，然而第二点则是等待 VBLANK。首先你得把游戏里面垂直同步的开关打开，缓冲区的交换才会等待垂直同步。有一些玩家为了追求极致的帧率和更低的输入延迟会关闭垂直同步，然而他们的屏幕刷新率又远低于游戏帧率，那么画面撕裂仍然会存在，缓冲区的存在只是一定程度的减缓了这种现象。</p><p>当然，有双缓冲区也有三缓冲区，甚至更多，为了画面的稳定和帧率的平滑，他们放弃了较短的输入延迟。</p><h2 id="精灵-sprite">精灵 Sprite</h2><h3 id="为什么是精灵-sprite">为什么是『精灵 · Sprite』？</h3><p>Sprite 是 德州仪器(TI)的工程师 Daniel Hillis 在 1970 年代后期创造的一个术语，也有一种说法，该词汇来自于 TI 的经理 David Ackley。</p><p>在计算机图形学和游戏开发领域，Sprite 指的是集成到更大场景中的独立悬浮于帧缓冲之上的的二维位图(Textrue2D)，其更多的用来表示游戏角色或者其他动态对象。</p><p>想象一下，你有一张图片作为游戏的背景——还有另外一张图片漂浮在这个作为背景的图片上，在游戏更新的过程中，后者会移动，旋转，缩放，甚至是可交互的，就像神话中的『幽灵』或者说『精灵』。</p><h3 id="画家算法">画家算法</h3><h4 id="基本思想">基本思想</h4><p>先将画面中的物体按其距离观察点的远近进行排序，结果存放在一张线形表中。距观察点远者称其优先级高，放在表头,距观察点近者称其优先级低，放在表尾，这张表称为深度优先级表。</p><p>然后按照从表头到表尾的顺序逐个绘制物体。由于距观察者近的物体在表尾最后画出，它覆盖了远处的物体，最终在屏幕上产生了正确的遮挡关系。</p><h3 id="精灵动画">精灵动画</h3><p>就像所有动画一样，精灵动画也是运用的人眼的视觉残留效应，那么当然，一组精灵动画就需要一组精灵图片，为了让你的游戏人物的行动看起来足够流畅，一秒完成的动作至少也需要24张图片，一个简单攻击动作的精灵图量往往在8张以上。</p><h3 id="精灵表单">精灵表单</h3><p>为了保证精灵完全对其，我们通常要求美术绘制的角色起码得是同一个尺寸，在过去，这个尺寸往往是 <span class="math inline">\(2^n\)</span> 次方，这也是许多库内部规定好的。当然，我们现在已经不追 <span class="math inline">\(2^n\)</span> 次方了，但是仍然需要一个角色一系列的动画帧保持相同的大小，并且，别的角色也最好按照设定保持类似的比例。</p><p>许多美术给图喜欢一张一张的给，那么这其实是让每张图片都成为以一个单独的纹理，并且图片中也会存在大量的留白，虽然现代引擎对这一类资源做过优化，但是不管是对内存，还是对程序员（有些美术给图之后往往就甩手不管图片的裁剪了）的头发来说，这都是一件很痛苦的事情。</p><p>一个更好的做法是将所有的动画帧放在一张图片上，这张图片，我们叫做精灵表单，这张表单上的图片，我们希望间距足够小，并且成行成列的对齐，这样不仅能节省不少内存空间，还可以让处理素材更加快捷。 <img data-src="AttackCombo.png" alt="AttackCombo" /> 下面我提供一个打包的小工具，大家可以试试。 <a href="https://www.codeandweb.com/texturepacker">TexturePacker</a></p><p>当然，游戏引擎对图片的大小，长和宽都是有限制的。最好不要把所有图片都塞进一张精灵表里。</p><h2 id="滚屏">滚屏</h2><p>在以前简单的 2D 游戏中，比如俄罗斯方块一类，游戏中所有元素都可以在一张固定大小的小小屏幕中展现出来，但随着玩法的更新迭代，游戏的世界也越来越大，再也不是一张固定大小的图片能承载的下的了。屏幕的大小没有办法改变，但实际上可显示的图片是可与改变的，想象一下，你面前有一张巨大的画布，你用一个木框去框住一小部分，这时候你再扯动，这时候这张远超木框大小的画布的全部内容就都可以再一个小小的屏幕中全部展现出来。</p><h3 id="单轴滚屏">单轴滚屏</h3><p>单轴滚动顾名思义，就是屏幕在单个轴上滚动，其实现原理也特别简单。你可以按照屏幕大小绘制出一连串的图片，在游戏进行时只需要同时绘制出两张图片就可以。图片绘制的时机你可以采用时间计算，也可以采用Trigger或者射线检测，当你给你的每张图片都加上ID，你就可以非常自由的控制下一张改出现那一张图片了。又或者你的玩家吃到什么道具，同样可以很方便的影响到下一张图片的绘制。</p><h3 id="无限滚屏">无限滚屏</h3><p>无限滚屏的原理其实和上面的单轴没有任何区别，只是说上面的图片出现顺序可能是写在策划表里的，而无限滚动是做一个循环或者随机打散组成序列。</p><h3 id="平行滚屏">平行滚屏</h3><p>当然，制作过 2D 横版卷轴游戏的同学可能会知道，我们的背景实质上是分层的，远景，中景，近景，他们的移动都是有不同的速率的。</p><p>这会让你的游戏看起来更加真实，美术绝赞。</p><h3 id="四向滚屏">四向滚屏</h3><p>四向滚屏的数学运算确实比单轴滚屏难了一个维度，但其实解决方案也是很多的。你可以选定一个坐标原点，以你的图片的长宽为x,y轴的单位长度构建一个坐标系，后面就是简单的数学问题了。一个很简单的很符合直觉的解决方案是，渲染你的角色所在的矩阵四角的图片。实际上就是你的角色所在的矩阵的四个点为中心渲染出图片。 很简单的算法吧，一句话就可以描述。</p><h2 id="瓦片地图">瓦片地图</h2><p>素材复用在现代游戏中是很重要的一环，相信大家都没法接受每一关都需要重新绘制一遍，尤其是对于游戏地图来说，很多花草竹石在每个场景中也都大同小异。</p><p>瓦片地图把游戏世界划分成等分的网格（可以是等六边形也可以是平行四边形或者其他什么形状），每个方块都有其对应的精灵。一般来说游戏引擎都会提供一个瓦片地图的编辑器，一张画布，上面来绘制你的地图，一个调色板，上面是你将采用的精灵。</p><h2 id="参考资料">参考资料</h2><ol type="1"><li><p><a href="https://vibaike.com/130533/">光栅扫描</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/412713532">液晶屏刷新原理和时序</a></p></li><li><p><a href="https://chillstepp.github.io/2020/07/17/AHU%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/">AHU计算机图形学</a></p></li><li><p><a href="https://handwiki.org/wiki/Sprite_(computer_graphics)">Sprite (computer graphics)</a></p></li></ol>]]></content:encoded>
      
      
      
      
      <comments>https://rdququ.top/posts/220dd5af/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Unity rectTransform 解析</title>
      <link>https://rdququ.top/posts/462539dc/</link>
      <guid>https://rdququ.top/posts/462539dc/</guid>
      <pubDate>Sat, 04 Nov 2023 04:35:35 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/RectTransform.html&quot;&gt;官方文档地址&lt;/a&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><a href="https://docs.unity3d.com/ScriptReference/RectTransform.html">官方文档地址</a> <span id="more"></span> - anchoredPosition 锚点位置 不要使用 position 也不要使用 <strong>localPosition</strong>. 数据类型是 Vector2 The position of the pivot of this RectTransform relative to the anchor reference point. 相对于锚点参照点的轴枢位置</p><ul><li><p>pivot 锚点 数据类型是 Vector2 The normalized position in this RectTransform that it rotates around. 在此 RectTransform 中环绕的归一化位置。 (0,0) 为左下角，(1,1) 为右上角.</p></li><li><p>sizeDelta 大小 数据类型是 Vector2 The size of this RectTransform relative to the distances between the anchors. 相对于锚点之间的距离，此 RectTransform 的大小。 If the anchors are together, sizeDelta is the same as size. If the anchors are in each of the four corners of the parent, the sizeDelta is how much bigger or smaller the rectangle is compared to its parent. 如果锚点在一起，则 sizeDelta 与 size 相同。如果锚点分别位于父对象的四个角上，那么 sizeDelta 就是矩形相对于父对象的大小。</p></li></ul>]]></content:encoded>
      
      
      
      
      <comments>https://rdququ.top/posts/462539dc/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
