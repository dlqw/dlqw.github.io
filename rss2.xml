<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>蛐蛐的软件开发世界</title>
    <link>https://rdququ.top/</link>
    
    <atom:link href="https://rdququ.top/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>正在学习unity中</description>
    <pubDate>Tue, 12 Dec 2023 14:56:04 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>不透明物体与半透明物体边缘算法与Unity Shader Graph 实现</title>
      <link>https://rdququ.top/posts/223f372/</link>
      <guid>https://rdququ.top/posts/223f372/</guid>
      <pubDate>Tue, 12 Dec 2023 11:25:29 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;前置知识&quot;&gt;前置知识&lt;/h2&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="前置知识">前置知识</h2><span id="more"></span><h3 id="归一化空间坐标-ndknormalized-device-coordinates">归一化空间坐标 NDK(Normalized Device Coordinates)</h3><p>在齐次裁剪空间的基础上进行透视除法或称齐次除法, 得到的坐标叫做NDC空间坐标。</p><p><a href="https://zhuanlan.zhihu.com/p/102758967">一篇文章彻底弄懂齐次裁剪 - 知乎 (zhihu.com)</a></p><h4 id="透视除法-齐次除法perspective-division-homogeneous-division">透视除法-齐次除法(<strong>perspective division</strong>-<strong>homogeneous division)</strong></h4><p>就是将齐次裁剪空间坐标positionCS的X,Y,Z分量都除以W分量。</p><p><a href="https://www.jianshu.com/p/7e701d7bfd79">写给大家看的“透视除法” —— 齐次坐标和投影 - 简书 (jianshu.com)</a></p><p><img data-src="https://pic4.zhimg.com/80/v2-4baca450c51c7f0eea873c42eeda0eef_720w.webp" /></p><h2 id="算法原理">算法原理</h2><h2 id="unity-shader-graph-实现">Unity Shader Graph 实现</h2><h3 id="scenedepth">SceneDepth</h3><blockquote><p>Provides access to the current <strong>Camera</strong> 's depth buffer using input <strong>UV</strong> , which is expected to be normalized screen coordinates. Note: Depth buffer access requires depth buffer to be enabled on the active <strong>Render Pipeline</strong> . This process is different per <strong>Render Pipeline</strong> . It is recommended you read the documentation of your active <strong>Render Pipeline</strong> for information on enabling the depth buffer. If the depth buffer is unavailable this <a href="https://link.zhihu.com/?target=https%3A//docs.unity3d.com/Packages/com.unity.shadergraph%406.9/manual/Node.html">Node</a> will return mid grey.</p></blockquote><p>也就是说SceneDepth Node是对深度纹理进行获取的节点，只不过获取的方法不同，而深度纹理中存储的是NDC坐标的深度值。</p><figure><img data-src="https://pic4.zhimg.com/80/v2-199f0cb63bdba7f81de4c826056dcbff_720w.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li>Linear01获取的是线性的范围为[0,1]的深度值。 &gt; 想要把Raw Depth转换成线性 ，并且从近平面到远平面为0-1的深度，就需要Linear 01 Depth，这时0.5深度就是视锥体一半的位置。 &gt;</li><li>Raw也就是深度纹理中存储的非线性，范围为[0,1]的值。 &gt; 表示深度缓冲的原始数据，普通的深度缓冲使用32位的浮点数表示深度，相机近平面的深度为0，远平面的深度为1。而Unity 使用了Reversed Z，这就使得近平面深度为1，而远平面深度为0，另外，如果相机的投影矩阵不是正交矩阵，那么深度缓冲中的深度就不是线性的，举个例子就是深度0.5代表的地方并不是视锥体一半的位置。 &gt;</li><li>Eye获取的是视角空间下的线性深度值，范围为[near, far]。 &gt; Linear Eye Depth中深度为1表示沿着摄像机Z轴，距离为1个单位的地方，2就是距离两个单位的地方，以此类推。 &gt;</li></ul><h3 id="screenposition">ScreenPosition</h3><blockquote><p>Provides access to the mesh vertex or fragment's <strong>Screen Position</strong> .</p></blockquote><figure><img data-src="https://pic3.zhimg.com/80/v2-439252aa4b98dac54ced99bf1460a58e_720w.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li>ScreenPosition在Default选项下会进行齐次除法运算（即除以w分量），这里的w范围为[0,1],也就是NDC下的w分量。经过透视除法的，左下角是（0，0）右上角是（1，1）的屏幕空间</li><li>在Raw选项下，不会进行齐次除法运算,这里的w范围是[Near, Far],是Clip Space中的w分量。未经过透视除法的，左下角是（0，0）右上角是（1，1）的屏幕空间</li><li>Center: 经过透视除法的，左下角是（-1，-1）右上角是（1，1）的屏幕空间</li><li>Tiled: 经过透视除法的，分成上下均等的四块组成，每块左下角是（0，0）右上角是（1，1）的屏幕空间</li></ul><p>在这里ScreenPosition的w分量的含义也就是ClipSpace下的w分量，范围是[Near, Far],而当xy除以w分量后，越远的顶点也就会除以越大的w分量，就会产生透视现象。</p><h3 id="存疑之处与我的观点证明">存疑之处与我的观点/证明</h3><p>博主<a href="https://www.zhihu.com/people/lute-li">Lute Li</a>，认为</p><blockquote><p>（Scene Depth是除开透明模型之外的深度，Screen Position是所有模型的深度，相减就是边缘）</p></blockquote><p>出处<a href="https://zhuanlan.zhihu.com/p/109547098">从头学ShaderGraph 5-护盾材质 - 知乎 (zhihu.com)</a></p><p><img data-src="https://pic2.zhimg.com/80/v2-fea83d5ed062c6bfe5dc8221e2d5d999_720w.webp" /></p><p><strong>(Vertex Shader) =&gt; Clip Space =&gt; (透视除法) =&gt; NDC =&gt; (视口变换) =&gt; Window Space =&gt; (Fragment Shader)</strong></p><p>现象很好观察，但是不知道原理，翻遍了官方文档和网上的教程也没能得到一个足够有说服力的解释，现在可以知道 SceneDepth 的 Eye 获取的是视角空间下的线性深度值，范围为[near, far]，ScreenPosition 的 w 分量是是 Clip Space 中未经过透视除法的值，范围也是[near, far]。我们知道物体自Eye/View/Camera Space(这玩意名字真多)到Cliping Space 要经过一次透视变换，或者说透视除法，所以实际上，Screen Graph 的 w 分量也许就是 Eye Space 下到相机的距离(不是深度，所以也存储了透明物体的距离)</p><figure><img data-src="image/不透明物体与半透明物体边缘算法与Unity-Shader-Graph-实现/1702390346535.png" alt="1702390346535" /><figcaption aria-hidden="true">1702390346535</figcaption></figure><p>上图的实验一定程度上看可以证明上文的观点。</p><p>有趣的是，当我们把 Surface Type 修改为Transparent, 场景中的透明与不透明物体的交界处出现了一道淡淡的白线</p><figure><img data-src="image/不透明物体与半透明物体边缘算法与Unity-Shader-Graph-实现/1702390608834.png" alt="1702390608834" /><figcaption aria-hidden="true">1702390608834</figcaption></figure><p>我们将 Comparison 节点的输入值 B 调大，交界处出现了明显的白线</p><figure><img data-src="image/不透明物体与半透明物体边缘算法与Unity-Shader-Graph-实现/1702390681409.png" alt="1702390681409" /><figcaption aria-hidden="true">1702390681409</figcaption></figure><figure><img data-src="image/不透明物体与半透明物体边缘算法与Unity-Shader-Graph-实现/1702390730401.png" alt="1702390730401" /><figcaption aria-hidden="true">1702390730401</figcaption></figure><p>我们知道，初始输出的两个节点的取值范围都是[n,f]，所以当我们把对比节点的输入值B调到1的时候，边界就很明显了。</p><p>现在，结果已经呼之欲出了，Scene Depth 节点的 Eye 输出的是深度值，我们知道，透明物体默认不会写入深度缓冲，Screen Position 输出的是简单的距离，故而相减可以得到边界。</p><h2 id="参考资料与引用">参考资料与引用</h2><ol type="1"><li><a href="https://zhuanlan.zhihu.com/p/535898515">unity urp 20 SceneDepth和ScreenPosition.w - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/347698766">Shader Graph中的Scene Depth和Screen Position - 知乎 (zhihu.com)</a></li><li><a href="https://www.bilibili.com/video/BV1sa411C7Xd/">2022版Unity Shader Graph教程04 水面 (上) 超简单ShaderGraph入门_哔哩哔哩_bilibili</a></li><li><a href="https://zhuanlan.zhihu.com/p/102758967">一篇文章彻底弄懂齐次裁剪 - 知乎 (zhihu.com)</a></li><li><a href="https://www.jianshu.com/p/7e701d7bfd79">写给大家看的“透视除法” —— 齐次坐标和投影 - 简书 (jianshu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/493733502">Unity Shader Graph 中深度纹理（Depth Texture）和屏幕空间坐标（Screen Position） - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/109547098">从头学ShaderGraph 5-护盾材质 - 知乎 (zhihu.com)</a></li><li><a href="https://carmencincotti.com/2022-05-02/homogeneous-coordinates-clip-space-ndc/#homogeneous-coordinates">Homogeneous Coordinates, Clip Space, and NDC | WebGPU | Carmen's Graphics Blog --- 齐次坐标、裁剪空间和 NDC |网络GPU |Carmen 的图形博客 (carmencincotti.com)</a></li></ol>]]></content:encoded>
      
      
      
      
      <comments>https://rdququ.top/posts/223f372/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Unity_GC_浅谈</title>
      <link>https://rdququ.top/posts/e44777a7/</link>
      <guid>https://rdququ.top/posts/e44777a7/</guid>
      <pubDate>Sun, 10 Dec 2023 05:50:22 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;unity-底层的内存分配&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#unity-底层的内存分配&quot;&gt;&lt;/a&gt; Unity 底层的内存分配&lt;/h2&gt;
&lt;h3 id=&quot;托管内存&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="unity-底层的内存分配"><a class="markdownIt-Anchor" href="#unity-底层的内存分配"></a> Unity 底层的内存分配</h2><h3 id="托管内存"><a class="markdownIt-Anchor" href="#托管内存"></a> 托管内存</h3><p>Mono 和 IL2CPP 的脚本虚拟机(virtual machines =&gt; VMs)实现了托管内存系统(脚本内存系统)。这些VMs提供了数种受控内存环境。</p><h4 id="managed-heap-托管堆"><a class="markdownIt-Anchor" href="#managed-heap-托管堆"></a> Managed Heap 『托管堆』</h4><p>GC 自动控制的内存区域。</p><h4 id="scripting-stack-脚本栈"><a class="markdownIt-Anchor" href="#scripting-stack-脚本栈"></a> Scripting Stack 『脚本栈』</h4><p>在应用程序进入和退出任何代码范围时构建和展开</p><h4 id="native-vm-memory-本地虚拟机内存"><a class="markdownIt-Anchor" href="#native-vm-memory-本地虚拟机内存"></a> Native VM Memory 『本地虚拟机内存』</h4><p>包含与 Unity 脚本层相关的内存，大多数情况下不需要主动管理。</p><h3 id="c-非托管内存"><a class="markdownIt-Anchor" href="#c-非托管内存"></a> C# 非托管内存</h3><p>允许编写 C# 代码来访问本机内存以微调内存分配。<br />可以使用 Unity 核心 API 中的 Unity.Collections 命名空间（包括 NativeArray）和 Unity Collections 包中的数据结构来访问 C# 非托管内存。如果使用 Unity 的 C# Job 系统或 Burst，则必须使用 C# 非托管内存。</p><h3 id="native-memory-本机内存"><a class="markdownIt-Anchor" href="#native-memory-本机内存"></a> Native Memory 『本机内存』</h3><h2 id="unity-应用的-gc-算法"><a class="markdownIt-Anchor" href="#unity-应用的-gc-算法"></a> Unity 应用的 GC 算法</h2><h3 id="boehmgc"><a class="markdownIt-Anchor" href="#boehmgc"></a> BoehmGC</h3><h4 id="boehmgc-算法原理"><a class="markdownIt-Anchor" href="#boehmgc-算法原理"></a> BoehmGC 算法原理</h4><h4 id="boehmgc-的内存管理"><a class="markdownIt-Anchor" href="#boehmgc-的内存管理"></a> BoehmGC 的内存管理</h4><h4 id="boehmgc-算法实现"><a class="markdownIt-Anchor" href="#boehmgc-算法实现"></a> BoehmGC 算法实现</h4><h4 id="mono-与-il2cpp-中的-boehmgc"><a class="markdownIt-Anchor" href="#mono-与-il2cpp-中的-boehmgc"></a> MONO 与 IL2CPP 中的 BoehmGC</h4><h3 id="渐进式-gc"><a class="markdownIt-Anchor" href="#渐进式-gc"></a> 渐进式 GC</h3><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/623849906">Unity 垃圾回收GC的原理？</a></li><li><a href="https://zhuanlan.zhihu.com/p/265217138">Unity GC 学习总结</a></li><li><a href="https://zhuanlan.zhihu.com/p/41023320">解读MONO内存管理和回收！</a></li><li><a href="https://zhuanlan.zhihu.com/p/41398507">解读MONO内存管理：BOEHM GC原理及总结</a></li><li><a href="https://juejin.cn/post/6966954993869914119">Unity3D托管堆BoehmGC算法学习-内存分配篇</a></li><li><a href="https://juejin.cn/post/6968400262629163038">Unity3D托管堆BoehmGC算法学习-垃圾回收篇</a></li><li><a href="https://zhuanlan.zhihu.com/p/381859536?">【笔记】Unity内存分配和回收的底层原理</a></li><li><a href="https://docs.unity3d.com/Manual/performance-memory-overview.html">Memory in Unity Unity</a></li><li><a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">Garbage collection (computer science)</a></li></ol>]]></content:encoded>
      
      
      
      
      <comments>https://rdququ.top/posts/e44777a7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>UnityshaderGraph学习2021版</title>
      <link>https://rdququ.top/posts/1fbb4100/</link>
      <guid>https://rdququ.top/posts/1fbb4100/</guid>
      <pubDate>Fri, 08 Dec 2023 05:02:30 GMT</pubDate>
      
      <description>&lt;p&gt;学习笔记</description>
      
      
      
      <content:encoded><![CDATA[<p>学习笔记 <span id="more"></span></p><h2 id="创建">创建</h2><p>选择 URP 模板创建不需要配置环境 普通 3D 项目，包管理器安装 Universal RP, visual effect graph，设置中正常配置 Graphics</p><h2 id="光照模型">光照模型</h2><p>Create =&gt; ShaderGraph =&gt; URP =&gt; Lit Shader Graph</p><p>输入属性节点： <img data-src="输入属性节点.png" alt="输入属性节点" /></p><p>属性设置： <img data-src="属性设置.png" alt="属性设置" /></p><ul><li>Precision [精度] [single/half] half 性能更好</li></ul><p>在 Universal 中</p><ul><li>Material [材质]<ul><li>[sprite Custom] 自定义精灵</li><li>[sprite Lit] 精灵光照</li><li>[sprite Unlit] 精灵非光照</li><li>[Decal] 贴花</li><li>[Lit] 光照</li><li>[Unlit] 非光照</li></ul></li><li>Allow Material Override [允许材质覆盖] [勾选] 可以通过材质检查器修改某些图形属性。</li><li>workflow [工作流] [Specular/Metallic] [勾选] 镜面高光/金属工作流</li><li>Surface Type [表面类型] [Opaque/Transparent] [半透明/不透明]</li><li>Render Face [渲染面] [Front/Back/Double] [正面/背面/双面]</li><li>Depth Write [深度写入] [Auto/Force Enabled/Force Disabled] [自动/强制开启/强制关闭]</li><li>Depth Test [深度测试] [Never/Less/Equal/LessEqual/Greater/NotEqual/GreaterEqual/Always] [从不/小于/等于/小于等于/大于/不等于/大于等于/总是]</li><li>Alpha Clipping [Alpha裁剪] [勾选]</li><li>Receive Shadows [接收阴影] [勾选]</li><li>Fragment Normal Space [片段法线空间] [Tangent/World/View] [切线/世界/视图]</li><li>Clear Coat [清漆] [勾选]</li><li>Custom Editor GUI [自定义编辑器GUI]</li><li>Supports VFXGRAph [支持VFXGRAph] [勾选]</li></ul><p>顶点着色器: <img data-src="顶点着色器.png" alt="顶点着色器" /></p><p>片段着色器: <img data-src="片元着色器.png" alt="片元着色器" /></p><p>乘法节点 Multiply: 颜色叠加</p><h3 id="fragment">Fragment</h3><h4 id="base-color">Base Color</h4><p>主贴图，展现了模型的基本纹理 可以新建一个 Texture2D 属性，然后将其作为输入 <img data-src="UnityShaderGraphBaseColor.png" alt="UnityShaderGraphBaseColor" /></p><p>MainTexture 保持默认</p><h4 id="normal">Normal</h4><figure><img data-src="UnityShaderGraphNormal.png" alt="UnityShaderGraphNormal" /><figcaption aria-hidden="true">UnityShaderGraphNormal</figcaption></figure><p>注意 Sample Texture 2D 的 Type 要设置为 Normal NormalTexture 的 Mode 选择 Normal Map</p><h4 id="metallic">Metallic</h4><p><img data-src="UnityShaderGraphMetallic.png" alt="UnityShaderGraphMetallic" /> 保持默认</p><h4 id="smoothness">Smoothness</h4><figure><img data-src="UnityShaderGraphSmoothness.png" alt="UnityShaderGraphSmoothness" /><figcaption aria-hidden="true">UnityShaderGraphSmoothness</figcaption></figure><p>输出金属光泽度的 Alpha 通道与 Smoothness 通过 Multiply 乘法节点相乘, 得到输出值</p><h4 id="emission">Emission</h4><p><img data-src="UnityShaderGraphEmission.png" alt="UnityShaderGraphEmission" /> 自发光贴图与类型为 Boolean Keywork 的 EmissiveTexture 相乘来控制是否自发光，得到其输出值与 EmissionColor 相乘得到最终的输出值</p><h4 id="ao">AO</h4><p><img data-src="UnityShaderGraphAO.png" alt="UnityShaderGraphAO" /> 保持默认</p><h3 id="sub-graph">Sub Graph</h3><p>框选中对应节点右击 Convert to =&gt; Sub-graph</p><h3 id="轮廓光边缘光">轮廓光/边缘光</h3><p>Fresnel Effect</p>]]></content:encoded>
      
      
      
      
      <comments>https://rdququ.top/posts/1fbb4100/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>AABB_Plane_intersection原理详解及Unity实现</title>
      <link>https://rdququ.top/posts/2c23d1d4/</link>
      <guid>https://rdququ.top/posts/2c23d1d4/</guid>
      <pubDate>Tue, 05 Dec 2023 13:39:39 GMT</pubDate>
      
      <description>&lt;p&gt;起因是我在学习 runtime 的 mesh 切割算法，需要判断目标 mesh 是否和切面相交（不相交的话我就不需要去处理了）</description>
      
      
      
      <content:encoded><![CDATA[<p>起因是我在学习 runtime 的 mesh 切割算法，需要判断目标 mesh 是否和切面相交（不相交的话我就不需要去处理了） <span id="more"></span> ## 前提知识</p><p>Unity 的 mesh 和 collider 都使用 AABB 包围盒</p><h3 id="什么是-aabb-包围盒">什么是 AABB 包围盒？</h3><p>AABB ==&gt; Axis Aligned Bounding Box (轴对齐边界框)</p><p>AABB（轴对齐边界框）是一个 3D 框。它的宽度/高度/深度不必相等，但宽度始终与 X 轴对齐，高度与 Y 轴对齐，深度与 Z 轴对齐。也就是说，这个盒子是不能旋转的。</p><h3 id="如何表示-aabb">如何表示 AABB？</h3><p>有两种常见的方法，存储最左边和最右边的角，或者存储中心点和盒子在每侧延伸多远的向量。</p><p>第一种：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> AABB</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Vector3 min;</span><br><span class="line">    <span class="keyword">public</span> Vector3 max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> AABB</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Vector3 center;</span><br><span class="line">    <span class="keyword">public</span> Vector3 extents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img data-src="AABB表示法.png" alt="AABB表示法" /><figcaption aria-hidden="true">AABB表示法</figcaption></figure><h2 id="算法">算法</h2><p>为了测试 AABB 和平面是否相交，我们首先必须将 AABB 的每个顶点投影到平面的法线上。这使我们 AABB 的所有顶点都在一条线上。</p><p>然后，我们检查离平面最远的顶点。如果与顶点对角线相对的顶点位于平面的另一侧，则我们有一个交点。</p><p>通用的 C# 代码如下，无论你的 AABB 是如何表示的(max/min 或 center/extents)，只需要稍作修改：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Test if AABB b intersects plane p</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">TestAABBPlane</span>(<span class="params">AABB b, Plane p</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Convert AABB to center-extents representation</span></span><br><span class="line">    Point c = (b.max + b.min) * <span class="number">0.5f</span>; <span class="comment">// Compute AABB center</span></span><br><span class="line">    Point e = b.max - c; <span class="comment">// Compute positive extents</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute the projection interval radius of b onto L(t) = b.c + t * p.n</span></span><br><span class="line">    <span class="built_in">float</span> r = e[<span class="number">0</span>]*Abs(p.n[<span class="number">0</span>]) + e[<span class="number">1</span>]*Abs(p.n[<span class="number">1</span>]) + e[<span class="number">2</span>]*Abs(p.n[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute distance of box center from plane</span></span><br><span class="line">    <span class="built_in">float</span> s = Dot(p.n, c) - p.d;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Intersection occurs when distance s falls within [-r,+r] interval</span></span><br><span class="line">    <span class="keyword">return</span> Abs(s) &lt;= r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="让我们来解析这段代码">让我们来解析这段代码</h3><ol type="1"><li>函数传入了目标 Mesh 的 AABB，和目标平面</li><li>进入后的两行假设你的 AABB 是用 max/min 表示的，如果你可以轻松调取 AABB 的 center 和 extents，那么这两行是可以被跳过的</li><li>下一段代码计算了 AABB 的投影半径，这个半径是 AABB 投影到平面法线上的最大距离。</li><li>其取 AABB 的范围和平面法线的绝对值的点积，用于确保计算出的长度是正值，因为两个向量中的元素都是正值或零。<span class="math display">\[n&#39; = (\lvert n_{x} \rvert,\lvert n_{y} \rvert,\lvert n_{z} \rvert) \\ \vec{e} \cdot \vec{n&#39;} = \lvert\vec{e} \rvert \lvert\vec{n&#39;} \rvert \cos \theta \\ \lvert\vec{n&#39;} \rvert =1 \\\vec{e} \cdot \vec{n&#39;} = \lvert\vec{e} \rvert  \cos \theta\]</span></li><li>下面计算了 AABB 中心点到平面的距离，计为 s</li><li>最后的返回值即为 AABB 自身在平面法线上的距离和其中心到平面距离长短的判断</li></ol><h3 id="unity-实现">Unity 实现</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">BoundPlaneIntersect</span>(<span class="params">Mesh mesh, <span class="keyword">ref</span> Plane plane</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Compute projection interval radius</span></span><br><span class="line">        <span class="built_in">float</span> r = mesh.bounds.extents.x * Mathf.Abs(plane.normal.x) +</span><br><span class="line">            mesh.bounds.extents.y * Mathf.Abs(plane.normal.y) +</span><br><span class="line">            mesh.bounds.extents.z * Mathf.Abs(plane.normal.z);<span class="comment">//做点乘，得出mesh包围盒的范围在平面法线上的投影，包围盒在平面法线方向上的最大距离</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Compute distance of box center from plane</span></span><br><span class="line">        <span class="built_in">float</span> s = Vector3.Dot(plane.normal, mesh.bounds.center) - (-plane.distance);<span class="comment">//前面点乘得mesh中心在平面法线上的投影，这是为了确保计算出的距离和后面的平面距离在同一方向</span></span><br><span class="line">        <span class="comment">//如果法线面朝内，后- (-plane.distance)为正，前mesh中心在与相对原点相交且与平面平行的平面‘靠近平面的一侧，Vector3.Dot(plane.normal, mesh.bounds.center)为负，符合逻辑</span></span><br><span class="line">        <span class="comment">//因为mesh中心和平面在同一侧，距离为相见</span></span><br><span class="line">        <span class="comment">//若mesh中心在与 相对原点相交且与平面平行的平面‘ 远离平面的一侧，就是说mesh中心与平面中间相隔了一个原点，那么前后就都是同号，符合逻辑</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Intersection occurs when distance s falls within [-r,+r] interval</span></span><br><span class="line">        <span class="keyword">return</span> Mathf.Abs(s) &lt;= r;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料">参考资料</h2><ol type="1"><li><a href="https://gdbooks.gitbooks.io/3dcollisions/content/Chapter1/aabb.html">AABB - Axis Aligned Bounding Box</a></li><li><a href="https://docs.unity.cn/cn/2021.3/ScriptReference/Bounds.html">Bounds-Unity_Documentation</a></li></ol>]]></content:encoded>
      
      
      
      
      <comments>https://rdququ.top/posts/2c23d1d4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Unity底层如何处理C#</title>
      <link>https://rdququ.top/posts/c896f832/</link>
      <guid>https://rdququ.top/posts/c896f832/</guid>
      <pubDate>Mon, 04 Dec 2023 14:20:41 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;关键词&quot;&gt;关键词&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;.NET mono 虚拟机&lt;/li&gt;
&lt;li&gt;IL2CPP</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="关键词">关键词</h2><ul><li>.NET mono 虚拟机</li><li>IL2CPP <span id="more"></span> ### 为什么选择 mono</li></ul><p>Mono 是一个开源的 .NET 框架的实现，它可以在 Linux、Mac、Windows 等平台上运行，而且可以在这些平台上编译出可执行文件。</p><p>开源、跨平台、Mono的开发工具( MonoDevelop 现在已被弃用)</p><h3 id="为什么推出-il2cpp">为什么推出 IL2CPP</h3><ul><li>Mono 没有合法身份， 微软收购之后的版权问题</li><li>Mono 虚拟机 解释执行 .NET 字节码，效率低</li><li>有些平台不允许内置 .net 虚拟机 (eg. iOS)</li><li>如果有新的平台出现，Mono 难以为其提供支持(跨不了平台咯)，移植很麻烦(eg. WebGL)</li></ul><p>IL: Intermediate Language .NET框架中间语言, .NET字节码 IL2CPP: IL to C++，将IL转换为C++代码 --&gt; 编译为可执行文件 --&gt; native platform</p><p>Unity:</p><ol type="1"><li>Unity C/C++ 以及 native 的开发 --&gt; 跨平台的 runtime (xcode, android studio)</li><li>Unity 开发者脚本语言(C#) --&gt; .NET字节码 --&gt; .dll --&gt; IL code --&gt; IL2CPP --&gt; C++</li><li>C# GC --&gt; c++ 为其提供支持 IL2CPP vm:支持 C# .NET 独有的特性，如反射，泛型，委托，lambda表达式等</li></ol><h3 id="il2cpp-做了什么有什么优势">IL2CPP 做了什么？有什么优势？</h3><ol type="1"><li>跨平台可以执行问题 --&gt; Unity --&gt;&gt; 移植 IL2CPP --&gt; .NET 版本问题</li><li>性能获得提升 --&gt; 基于 IL2CPP 发布(而不是 Mono)</li></ol>]]></content:encoded>
      
      
      
      
      <comments>https://rdququ.top/posts/c896f832/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>线性代数在游戏开发中的基础和简单应用</title>
      <link>https://rdququ.top/posts/90745bbc/</link>
      <guid>https://rdququ.top/posts/90745bbc/</guid>
      <pubDate>Sat, 18 Nov 2023 06:08:32 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;坐标系&quot;&gt;坐标系&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;笛卡尔坐标系&lt;/li&gt;
&lt;li&gt;圆柱坐标系 垂直“高度与” &lt;span class=&quot;math inline&quot;&gt;&#92;(h&#92;)&lt;/span&gt; 、从垂直轴发出的辐射轴 &lt;span class=&quot;math inline&quot;&gt;&#92;(r&#92;)&lt;/span&gt; 、偏航角(yaw) &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;theta&#92;)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;球坐标系 俯仰角(pitch) &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;phi&#92;)&lt;/span&gt; 、偏航角(yaw) &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;theta&#92;)&lt;/span&gt; 、半径长度 &lt;span class=&quot;math inline&quot;&gt;&#92;(r&#92;)&lt;/span&gt; eg. 经纬线</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="坐标系">坐标系</h2><ul><li>笛卡尔坐标系</li><li>圆柱坐标系 垂直“高度与” <span class="math inline">\(h\)</span> 、从垂直轴发出的辐射轴 <span class="math inline">\(r\)</span> 、偏航角(yaw) <span class="math inline">\(\theta\)</span></li><li>球坐标系 俯仰角(pitch) <span class="math inline">\(\phi\)</span> 、偏航角(yaw) <span class="math inline">\(\theta\)</span> 、半径长度 <span class="math inline">\(r\)</span> eg. 经纬线 <span id="more"></span> ### 笛卡尔坐标系的左手系和右手系</li></ul><p>手握拳，伸出大拇指，四指从 <span class="math inline">\(x\)</span> 轴指向 <span class="math inline">\(y\)</span> 轴，大拇指指向 <span class="math inline">\(z\)</span> 轴，这就是右手系。</p><p>反之为左手系。</p><h2 id="向量vector">向量(vector)</h2><p>在 n 维空间中包含 modulus (模)和 direction (方向)的量。</p><h3 id="模长">模长</h3><p>向量的模长是向量的长度，用 <span class="math inline">\(||\vec{v}||\)</span> 表示。</p><p>$ |||| =  $</p><h4 id="magic-number-卡马克快速平方根">magic number (卡马克快速平方根)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">Q_rsqrt</span><span class="params">( <span class="type">float</span> number )</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> i;</span><br><span class="line">  <span class="type">float</span> x2, y;</span><br><span class="line">  <span class="type">const</span> <span class="type">float</span> threehalfs = <span class="number">1.5F</span>;</span><br><span class="line"></span><br><span class="line">  x2 = number * <span class="number">0.5F</span>;</span><br><span class="line">  y = number;</span><br><span class="line">  i = * ( <span class="type">long</span> * ) &amp;y;                       <span class="comment">// evil floating point bit level hacking</span></span><br><span class="line">  i = <span class="number">0x5f3759df</span> - (i &gt;&gt; <span class="number">1</span>);                 <span class="comment">// what the fuck?</span></span><br><span class="line">  y = * ( <span class="type">float</span> * ) &amp;i;</span><br><span class="line">  y = y * (threehalfs - ( x2 * y * y ) );    <span class="comment">// 1st iteration</span></span><br><span class="line">  y = y * (threehalfs - ( x2 * y * y ) );    <span class="comment">// 2nd iteration, this can be removed</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.bilibili.com/video/BV18j411i7bp">科普视频</a></p><p><a href="http://www.beyond3d.com/content/articles/8/">真正的作者</a></p><h3 id="归一化和单位向量">归一化和单位向量</h3><h3 id="三角形法则加减法">三角形法则（加减法）</h3><h3 id="点积">点积</h3><ul><li>投影的计算</li><li>是否共线</li></ul><h3 id="叉积">叉积</h3><ul><li>右手法则的原理</li><li>点在三角形的内/外？</li></ul><h2 id="线性插值-lerp">线性插值 (Lerp)</h2><h2 id="矩阵">矩阵</h2><h3 id="用矩阵表示点和向量">用矩阵表示点和向量</h3><h3 id="单位矩阵">单位矩阵</h3><h3 id="矩阵乘法">矩阵乘法</h3><h3 id="矩阵的转置">矩阵的转置</h3><h3 id="逆矩阵于逆矩阵的求法">逆矩阵于逆矩阵的求法</h3><p><a href="https://blog.csdn.net/daduzimama/article/details/120509856">逆矩阵的求法</a></p><h3 id="伴随矩阵">伴随矩阵</h3><h3 id="正交矩阵">正交矩阵</h3><h3 id="齐次坐标-来不及就不讲"><em>齐次坐标</em> (来不及就不讲)</h3>]]></content:encoded>
      
      
      
      
      <comments>https://rdququ.top/posts/90745bbc/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>引擎开发实战学习笔记</title>
      <link>https://rdququ.top/posts/b15b4e49/</link>
      <guid>https://rdququ.top/posts/b15b4e49/</guid>
      <pubDate>Tue, 14 Nov 2023 07:26:04 GMT</pubDate>
      
      <description>&lt;p&gt;记录</description>
      
      
      
      <content:encoded><![CDATA[<p>记录 <span id="more"></span></p><ol type="1"><li>EntryPoint</li><li>Logging</li></ol>]]></content:encoded>
      
      
      
      
      <comments>https://rdququ.top/posts/b15b4e49/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Component-Based &amp; Component-Oriented Programming</title>
      <link>https://rdququ.top/posts/c63a25c3/</link>
      <guid>https://rdququ.top/posts/c63a25c3/</guid>
      <pubDate>Sat, 11 Nov 2023 04:09:40 GMT</pubDate>
      
      <description>&lt;p&gt;一点关于 Component 的思考&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>一点关于 Component 的思考</p><span id="more"></span><h2 id="前置知识">前置知识</h2><h3 id="面向对象编程-object-oriented-programming">面向对象编程 Object Oriented Programming</h3><h4 id="继承">继承</h4><h5 id="实现继承">实现继承</h5><p>让派生类可以使用基类的接口和实现，而不需要重新编写相同的代码。目的是代码的复用。 但是实现继承会导致派生类和基类之间的强耦合，当基类的实现发生变化时，派生类也需要跟着变化。</p><h5 id="接口继承">接口继承</h5><p>接口继承是指派生类只继承基类的接口，而不继承基类的实现。目的是让更高层的调用者不需要关注具体细节，可以一视同仁的去处理他见到的所以对象。我们也会把这种思想叫做“归一化”，典型的就是<code>toString()</code>方法。</p><p>反过来也一样，高层的调用者不需要对底层的实现指手画脚，最好连告知都不需要告知他们。我们把这种策略叫做“封装”</p><h4 id="缺点">缺点</h4><ul><li>代码复用性相对差</li><li>实际开发中，对象缺少明显的父子继承关系</li><li>实现继承的强耦合性</li></ul><p>游戏世界的对象是绝对复杂的，再父子继承的过程中，我们几乎没办法找到一个父类或者祖父类让所有子类都心甘情愿的继承他。</p><p>下面可以举一个小栗子</p><p>我们有一个 <code>水陆空三栖核能魔法混动运兵器</code>，那么这个类该继承自谁呢？</p><p>或许你能搞定他的父类，但是你能搞定他的祖父类吗？战车？船只？还是飞机？</p><p>或许你会觉得这个例子太过刁钻了，但事实上，哪怕是现实世界的对象，纯粹的 OO 也会心有余而力不足。比如，弓骑兵到底是骑兵的子类还是弓手的子类？还有那个经久不衰的笑话，连裤袜倒是改继承自裤子还是袜子？虽然最高法告诉我们连裤袜就是连裤袜，但是对于一种编程范式来说，模糊和冗余是致命的。</p><p>这就是这节课我为什么要和大家谈面向组件开发。</p><h2 id="什么是面向组件编程-component-oriented-programming">什么是面向组件编程 Component-Oriented Programming</h2><h3 id="什么是组件">什么是组件</h3><p>组件的本质，就是把一些经常使用的功能或者行为抽离出来，封装成一个个独立的模块，在要使用的时候想乐高积木或者 Switch 的游戏卡带一样，组装起来或者插进我们想要构建功能的对象中就可以了。这种性质，我们也称为 PnP，即 Plug and Play, 即插即用。大家以后要熟悉这个词，在很多领域都会大量出现。</p><h2 id="另一种解决方案面向数据编程-data-oriented-programming">另一种解决方案——面向数据编程 Data-Oriented Programming</h2><h2 id="没有银弹">没有银弹</h2><p>"A":"a" "B":"b" "Sprite":4</p>]]></content:encoded>
      
      
      
      
      <comments>https://rdququ.top/posts/c63a25c3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>GAMES101Notes</title>
      <link>https://rdququ.top/posts/6206937d/</link>
      <guid>https://rdququ.top/posts/6206937d/</guid>
      <pubDate>Mon, 06 Nov 2023 13:51:16 GMT</pubDate>
      
      <description>&lt;p&gt;GAMES101Notes&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>GAMES101Notes</p><span id="more"></span><h2 id="leture-3-transform">Leture 3 Transform</h2><ul><li>Modeling -&gt;transformation, rotation, scaling eg. Camera &amp; IK</li><li>Viewing -&gt; (3D to 2D)projection</li></ul><h3 id="scale">Scale</h3><p><span class="math display">\[x&#39; = sx \\ y&#39; = sy\]</span></p><p><span class="math display">\[\begin{bmatrix}x&#39; \\y&#39; \\\end{bmatrix} =\begin{bmatrix}s &amp; 0 \\0 &amp; s \\\end{bmatrix}\begin{bmatrix}x \\y \\\end{bmatrix}\]</span></p><p><span class="math display">\[\begin{bmatrix}x&#39; \\y&#39; \\\end{bmatrix} =\begin{bmatrix}s_x &amp; 0 \\0 &amp; s_y \\\end{bmatrix}\begin{bmatrix}x \\y \\\end{bmatrix}\]</span></p><h3 id="reflection-matrix">Reflection Matrix</h3><p><span class="math display">\[x&#39; = -x \\y&#39; = -y\]</span></p><p><span class="math display">\[\begin{bmatrix}x&#39; \\y&#39; \\\end{bmatrix} =\begin{bmatrix}-1 &amp; 0 \\0 &amp; -1 \\\end{bmatrix}\begin{bmatrix}x \\y \\\end{bmatrix}\]</span></p><h3 id="shear-matrix">Shear Matrix</h3><p><span class="math display">\[x&#39; = x + ay \\y&#39; = y + bx\]</span></p><p><span class="math display">\[\begin{bmatrix}x&#39; \\y&#39; \\\end{bmatrix} =\begin{bmatrix}1 &amp; a \\b &amp; 1 \\\end{bmatrix}\begin{bmatrix}x \\y \\\end{bmatrix}\]</span></p><h3 id="rotateabount-origin00ccw-by-default绕原点逆时针">Rotate(abount origin<span class="math inline">\((0,0)\)</span>,CCW by default)『绕原点，逆时针』</h3><p><span class="math display">\[x&#39; = xcos\theta - ysin\theta \\y&#39; = xsin\theta + ycos\theta\]</span></p><p><span class="math display">\[\begin{bmatrix}x&#39; \\y&#39; \\\end{bmatrix} =\begin{bmatrix}cos\theta &amp; -sin\theta \\sin\theta &amp; cos\theta \\\end{bmatrix}\begin{bmatrix}x \\y \\\end{bmatrix}\]</span></p><p><span class="math display">\[R = \begin{bmatrix}cos\theta &amp; -sin\theta \\sin\theta &amp; cos\theta \\\end{bmatrix}\]</span></p><h3 id="linear-transform-matricesof-the-same-dimension相同">Linear Transform = Matrices(of the same dimension)『相同』</h3><p><span class="math display">\[x&#39; = ax + by \\y&#39; = cx + dy\]</span></p><p><span class="math display">\[\begin{bmatrix}x&#39; \\y&#39; \\\end{bmatrix} =\begin{bmatrix}a &amp; b \\c &amp; d \\\end{bmatrix}\begin{bmatrix}x \\y \\\end{bmatrix}\]</span></p><p><span class="math display">\[x&#39; = Mx\]</span></p><h3 id="translation">Translation</h3><p><span class="math display">\[x&#39; = x + t_x\\y&#39; = y + t_y\]</span></p><p><span class="math display">\[\begin{bmatrix}x&#39; \\y&#39; \\\end{bmatrix} =\begin{bmatrix}1 &amp; 0 \\0 &amp; 1 \\\end{bmatrix}\begin{bmatrix}x \\y \\\end{bmatrix} +\begin{bmatrix}t_x \\t_y \\\end{bmatrix}\]</span></p><p><span class="math display">\[\begin{bmatrix}x&#39; \\y&#39; \\\end{bmatrix} =\begin{bmatrix}a &amp; b \\c &amp; d \\\end{bmatrix}\begin{bmatrix}x \\y \\\end{bmatrix} +\begin{bmatrix}t_x \\t_y \\\end{bmatrix}\]</span></p><p>显然，平移不是线性变换</p><p>但是我们想要有一个大统一的概念可以描述这些变换</p><h3 id="homogeneous-coordinates齐次坐标">Homogeneous Coordinates『齐次坐标』</h3><p>Add a third coordinate <span class="math inline">\(w\)</span> to <span class="math inline">\((x,y)\)</span></p><ul><li>2D point: <span class="math inline">\(= (x,y,1)^T\)</span></li><li>2D vector: <span class="math inline">\(= (x,y,0)^T\)</span></li></ul><p>Maxtrix representation of translation</p><p><span class="math display">\[\begin{bmatrix}x&#39; \\y&#39; \\w&#39; \\\end{bmatrix} =\begin{bmatrix}1 &amp; 0 &amp; t_x \\0 &amp; 1 &amp; t_y \\0 &amp; 0 &amp; 1 \\\end{bmatrix} ·\begin{bmatrix}x \\y \\1 \\\end{bmatrix} =\begin{bmatrix}x + t_x \\y + t_y \\1 \\\end{bmatrix}\]</span></p><p><span class="math inline">\(w\)</span> 的意义是什么呢？</p><p>In homogeneous coordinates, <span class="math inline">\(\begin{bmatrix}x \\y \\w \\\end{bmatrix}\)</span> is the 2D point<span class="math inline">\(\begin{bmatrix}\frac{x}{w} \\\frac{y}{w} \\1\end{bmatrix}, w \neq 0\)</span></p><h3 id="d-transformations">2D transformations</h3><h4 id="scale-1">scale</h4><p><span class="math display">\[S(s_x,s_y) = \begin{bmatrix}s_x &amp; 0 &amp; 0 \\0 &amp; s_y &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span></p><p><span class="math display">\[S(s_x,s_y) = \begin{bmatrix}s_x &amp; 0 &amp; 0 \\0 &amp; s_y &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span></p><h4 id="rotate">rotate</h4><p><span class="math display">\[R(\theta) = \begin{bmatrix}cos\theta &amp; -sin\theta &amp; 0 \\sin\theta &amp; cos\theta &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span></p><h4 id="shear">shear</h4>$ H(a,b) =<span class="math display">\[\begin{bmatrix}1 &amp; a &amp; 0 \\b &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span><p>$</p><h4 id="translate">translate</h4>$ T(t_x,t_y) =<span class="math display">\[\begin{bmatrix}1 &amp; 0 &amp; t_x \\0 &amp; 1 &amp; t_y \\0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span><p>$</p><h3 id="inverse-transform">Inverse transform</h3><p>逆变换刚好对应逆矩阵</p><h2 id="lecture-4-transformation-cont">Lecture 4 Transformation Cont</h2><p><a href="https://blog.csdn.net/daduzimama/article/details/120509856">逆矩阵的求法</a></p><p>当一个矩阵的逆等同于他的伴随矩阵，那么这个矩阵是正交矩阵。</p><p>旋转矩阵是正交矩阵</p><h3 id="d-transformations-1">3D transformations</h3><ul><li>Scale $ S(s_x,s_y,s_z) =<span class="math display">\[\begin{bmatrix}s_x &amp; 0 &amp; 0 &amp; 0 \\0 &amp; s_y &amp; 0 &amp; 0 \\0 &amp; 0 &amp; s_z &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span>$</li><li>Translate $ T(t_x,t_y,t_z) =<span class="math display">\[\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; t_x \\0 &amp; 1 &amp; 0 &amp; t_y \\0 &amp; 0 &amp; 1 &amp; t_z \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span>$</li><li>Rotate(Around x-, y-, z-axis) $ R_x() =<span class="math display">\[\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; cos\theta &amp; -sin\theta &amp; 0 \\0 &amp; sin\theta &amp; cos\theta &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span>\ $ $ R_y() =<span class="math display">\[\begin{bmatrix}cos\theta &amp; 0 &amp; sin\theta &amp; 0 \\0 &amp; 1 &amp; 0 &amp; 0 \\-sin\theta &amp; 0 &amp; cos\theta &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span>\ $ $ R_z() =<span class="math display">\[\begin{bmatrix}cos\theta &amp; -sin\theta &amp; 0 &amp; 0 \\sin\theta &amp; cos\theta &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span>$</li></ul><h4 id="rodrigues-rotation-formula罗德里格斯旋转公式">Rodrigues' Rotation Formula『罗德里格斯旋转公式』</h4><p>Rotation by angle <span class="math inline">\(\alpha\)</span> around axis <span class="math inline">\(n\)</span></p>$ (,) = cos() + (1-cos())^T + sin()N\ N =<span class="math display">\[\begin{bmatrix}0 &amp; -n_z &amp; n_y \\n_z &amp; 0 &amp; -n_x \\-n_y &amp; n_x &amp; 0 \\\end{bmatrix}\]</span><p>$</p><h3 id="viewing-transformation观测变换">Viewing transformation『观测变换』</h3><h3 id="view-camera-transformation视图变换">View / Camera transformation『视图变换』</h3><h3 id="projection-transformation投影变换">Projection transformation『投影变换』</h3><h4 id="orthographic-projection正交投影">Orthographic projection『正交投影』</h4><ul><li>相机置于原点，面朝 -z 轴</li><li>丢掉 z 轴</li><li>Translate and scale to <span class="math inline">\([-1,1]^2\)</span></li></ul><h5 id="in-general">In general</h5><ul><li>We want to map a cuboid <span class="math inline">\([l,r] \times [b,t] \times [\boldsymbol f,\boldsymbol n]\)</span> to the "canonical" cube<span class="math inline">\([-1,1]^3\)</span></li></ul><h6 id="transformation-matrix">Transformation matrix</h6><p>Translate(center to origin) -&gt; Scale(length/width/height to 2)</p>$ M_{ortho} =<span class="math display">\[\begin{bmatrix}\frac{2}{r-l} &amp; 0 &amp; 0 &amp; 0 \\0 &amp; \frac{2}{t-b} &amp; 0 &amp; 0 \\0 &amp; 0 &amp; \frac{2}{\boldsymbol n-\boldsymbol f} &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span>·<span class="math display">\[\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; -\frac{r+l}{2} \\0 &amp; 1 &amp; 0 &amp; -\frac{t+b}{2} \\0 &amp; 0 &amp; 1 &amp; -\frac{\boldsymbol n+\boldsymbol f}{2} \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span>=<span class="math display">\[\begin{bmatrix}\frac{2}{r-l} &amp; 0 &amp; 0 &amp; -\frac{r+l}{r-l} \\0 &amp; \frac{2}{t-b} &amp; 0 &amp; -\frac{t+b}{t-b} \\0 &amp; 0 &amp; \frac{2}{\boldsymbol n-\boldsymbol f} &amp; -\frac{\boldsymbol n+\boldsymbol f}{\boldsymbol n-\boldsymbol f} \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span><p>$</p><h4 id="perspective-projection透视投影">Perspective projection『透视投影』</h4><ul><li>First "aquish" the frustum into a cuboid <span class="math inline">\((n \rightarrow n, f \rightarrow f)(M_{persp \rightarrow ortho})\)</span></li><li>Do orthographic projection</li></ul><ol type="1"><li><p>In order to find a transformation</p><ul><li>Find the relationship between transformed points <span class="math inline">\((x&#39;,y&#39;,z&#39;)\)</span> and original points <span class="math inline">\((x,y,z)\)</span></li><li><span class="math inline">\(y&#39; = \frac{n}{z}y\\ x&#39; = \frac{n}{z}x\)</span> --&gt; similar to <span class="math inline">\(y&#39;\)</span></li></ul></li><li><p>In homogeneous corrdinates</p></li></ol>$<span class="math display">\[\begin{bmatrix}x \\y \\z \\1 \\\end{bmatrix} \xrightarrow{M_{persp \rightarrow ortho}}\begin{bmatrix}\frac{n}{z}x \\\frac{n}{z}y \\unknown \\1 \\\end{bmatrix} \xlongequal{mult. by z}\begin{bmatrix}nx \\ny \\unknown \\z \\\end{bmatrix}\]</span><p>$</p><p>显然，我们可以逆推出 <span class="math inline">\(M_{persp \rightarrow ortho}\)</span> 长这样</p>$ M_{persp ortho} =<span class="math display">\[\begin{bmatrix} n &amp; 0 &amp; 0 &amp; 0 \\0 &amp; n &amp; 0 &amp; 0 \\? &amp; ? &amp; ? &amp; ? \\0 &amp; 0 &amp; 1 &amp; 0 \\\end{bmatrix}\]</span><p>$</p><p>近和远处的 <span class="math inline">\(z\)</span> 不会发生变化</p><p>把 z 代换成 n，n 是我们取得特殊定值</p>$<span class="math display">\[\begin{bmatrix}x \\y \\z \\1 \\\end{bmatrix}\]</span>=<span class="math display">\[\begin{bmatrix}nx \\ny \\unknown \\z \\\end{bmatrix} \xrightarrow{replace\space z\space with\space n}\begin{bmatrix}x \\y \\n \\1 \\\end{bmatrix} \rightarrow\begin{bmatrix}nx \\ny \\n^2 \\n \\\end{bmatrix}\]</span><p>$</p><p>我们现在要求解第三行，且我们知道 x 轴和 y 轴对 z 轴没有影响, 因为最终的结果中没有 x 和 y</p>$<span class="math display">\[\begin{bmatrix}0\space 0\space A\space B\end{bmatrix}\]</span>·<span class="math display">\[\begin{bmatrix}x \\y \\n \\1 \\\end{bmatrix}\]</span><p>= n^2 $</p><p>我们可以推出</p>$<span class="math display">\[\begin{bmatrix}0 &amp; 0 &amp; A &amp; B\end{bmatrix}\]</span>·<span class="math display">\[\begin{bmatrix}x \\y \\n \\1 \\\end{bmatrix}\]</span><p>= n^2  An + B = n^2 $</p><p>我们又知道任何点的 z 坐标在远平面上都不会变化，所以我们可以推出</p>$<span class="math display">\[\begin{bmatrix}0 \\0 \\f \\1 \\\end{bmatrix} \Rightarrow\begin{bmatrix}0 \\0 \\f \\1 \\\end{bmatrix}\]</span>==<span class="math display">\[\begin{bmatrix}0 \\0 \\f^2 \\f \\\end{bmatrix} \Rightarrow\]</span><p>Af + B = f^2 $</p><p>解得</p><p>$ A = n+f \ B = -nf $</p><p>所以</p>$ M_{persp ortho} =<span class="math display">\[\begin{bmatrix} n &amp; 0 &amp; 0 &amp; 0 \\0 &amp; n &amp; 0 &amp; 0 \\0 &amp; 0 &amp; n+f &amp; -nf \\0 &amp; 0 &amp; 1 &amp; 0 \\\end{bmatrix}\]</span><p>$</p>$ M_{persp} = M_{ortho} · M_{persp ortho} =<span class="math display">\[\begin{bmatrix}\frac{2}{r-l} &amp; 0 &amp; 0 &amp; -\frac{r+l}{r-l} \\0 &amp; \frac{2}{t-b} &amp; 0 &amp; -\frac{t+b}{t-b} \\0 &amp; 0 &amp; \frac{2}{\boldsymbol n-\boldsymbol f} &amp; -\frac{\boldsymbol n+\boldsymbol f}{\boldsymbol n-\boldsymbol f} \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span>·<span class="math display">\[\begin{bmatrix} n &amp; 0 &amp; 0 &amp; 0 \\0 &amp; n &amp; 0 &amp; 0 \\0 &amp; 0 &amp; n+f &amp; -nf \\0 &amp; 0 &amp; 1 &amp; 0 \\\end{bmatrix}\]</span>=<span class="math display">\[\begin{bmatrix}\frac{2n}{r-l} &amp; 0 &amp; \frac{r+l}{r-l} &amp; 0 \\0 &amp; \frac{2n}{t-b} &amp; \frac{t+b}{t-b} &amp; 0 \\0 &amp; 0 &amp; \frac{n+f}{n-f} &amp; \frac{2nf}{n-f} \\0 &amp; 0 &amp; 1 &amp; 0 \\\end{bmatrix}\]</span><p>$</p><h2 id="rasterizationtriangles光栅化">Rasterization(Triangles)光栅化</h2><p>定义 field of view(fovY)垂直的可视角度 和 aspect ratio(w/h)屏幕长宽比 <img data-src="垂直可视角度和屏幕长宽比.png" alt="垂直可视角度和屏幕长宽比" /> n:near, t:top, b:bottom, l:left, r:right</p><p>视口变换</p><p><span class="math display">\[\begin{bmatrix}x \\y \\z \\1 \\\end{bmatrix} =\begin{bmatrix}\frac{w}{2} &amp; 0 &amp; 0 &amp; \frac{w}{2} \\0 &amp; \frac{h}{2} &amp; 0 &amp; \frac{h}{2} \\0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{bmatrix}·\begin{bmatrix}x \\y \\z \\1 \\\end{bmatrix}\]</span></p><h3 id="sample-采样">Sample 『采样』</h3><ul><li>Sample if center of pixel is inside triangle</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">Inside</span>(<span class="params">tri,x,y</span>)</span> =&gt; Point(x,y) <span class="keyword">in</span> tri ? <span class="number">1</span> : <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> y = <span class="number">0</span>; y &lt; h; y++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> x = <span class="number">0</span>; x &lt; w; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        image[x][y] = Inside(tri,x + <span class="number">0.5f</span>,y + <span class="number">0.5f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">做叉积判断点 Q 是否在 tri 内</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">P0</span></span><br><span class="line"><span class="comment">|\</span></span><br><span class="line"><span class="comment">| \    *Q</span></span><br><span class="line"><span class="comment">|  \</span></span><br><span class="line"><span class="comment">|___\P2</span></span><br><span class="line"><span class="comment">P1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>采样率低 =&gt; 走样 =&gt; 锯齿...</p><h3 id="anti-aliasing反走样抗锯齿">Anti-aliasing『反走样/抗锯齿』</h3><p>采样之前做一个滤波(filtering)</p><ul><li>Frequency『频率』</li><li>Frequency domain『频域』</li></ul><h4 id="数字信号处理相关的前置知识">数字信号处理相关的前置知识</h4><p>傅里叶变换 =&gt; 把函数从时域转换到频域 <img data-src="时域到频域.png" alt="时域到频域" /></p><ul><li>Low-pass filter『低通滤波器』</li><li>High-pass filter『高通滤波器』</li><li>Band-pass filter『带通滤波器』</li><li>Band-stop filter『带阻滤波器』</li><li>Gaussian filter『高斯滤波器』</li><li>Box filter『盒子滤波器』 ...</li></ul><p>Filtering = Convolution『卷积』= Average『平均』= Blurring『模糊』</p><p>时域卷积 = 频域乘积</p><figure><img data-src="时域图到频谱图.png" alt="时域图到频谱图" /><figcaption aria-hidden="true">时域图到频谱图</figcaption></figure><p>采样是重复原始信号的频谱</p><ul><li>采样定理: 在进行模拟/数字信号的转换过程中，当采样频率fs.max大于信号中最高频率fmax的2倍时(fs.max&gt;2fmax)，采样之后的数字信号完整地保留了原始信号中的信息，一般实际应用中保证采样频率为信号最高频率的2.56～4倍；采样定理又称奈奎斯特定理。</li></ul><p><a href="https://zhuanlan.zhihu.com/p/74736706">采样定理，频谱混叠和傅里叶变换 深入理解</a></p><p>这篇文章很好地解释了为什么"对于一个连续的信号采样，采样后的频谱相当于将采样前的频谱进行延拓" <a href="https://www.projectrhea.org/rhea/index.php/2015_Fall_ECE_438_Boutin_A_visual_explanation_of_aliasing_and_repetition_with_the_DTFT_Erik_Swan">A visual explanation of aliasing and repetition with the DTFT</a></p><blockquote><p>时域采样得到的离散信号并不只代表这个时域信号，有无数多个频率不同的信号的采样结果是一样的，也就导致了频域上的周期延拓</p></blockquote><p>有无数个高频分量可以匹配相同的离散数据，因此离散信号的频域包含所有这些频率。 <img data-src="连续信号采样频谱拓展的解释.gif" alt="连续信号采样频谱拓展的解释" /></p><p>当延拓的图形重合的时候，我们就认定这时候发生了走样。</p><p>要反走样，最直接的办法就是增加采样率，在现实中的意义就是“换一个更好的分辨率更好的显示器”（让图形之间离得更远） 从算法/软件角度来说，我们也可以采用之前的在采样前添加滤波的方法。我们可以给图像添加一个低通滤波，把高频的信息去掉。（让图形更瘦）</p><h4 id="antialiasing-by-supersampling超采样msaa">Antialiasing By Supersampling『超采样』(MSAA)</h4><p>将一个像素近似认为更多的像素 =&gt; 给一个像素内部增加更多的采样点 =&gt; 工业界的做法</p><h4 id="fast-approximate-antialiasing快速近似反走样抗锯齿fxaa">Fast Approximate Antialiasing『快速近似反走样/抗锯齿』(FXAA)</h4><p>图像的后期处理 =&gt; 通过图像匹配的办法把存在锯齿的边界找到，并且更换成没有锯齿的边界 =&gt; 效率高</p><h4 id="temporal-antialiasing时域反走样抗锯齿taa">Temporal Antialiasing『时域反走样/抗锯齿』(TAA)</h4><p>静态场景中 =&gt; 复用上一帧感知的结果 =&gt; 相当于把 MSAA 对应的样本分布在了时间上，并且在当前帧没有引入任何额外操作</p><h3 id="z-buffering深度缓冲">Z-buffering『深度缓冲』</h3><h4 id="painters-algorithm画家算法">Painter's Algorithm『画家算法』</h4><h5 id="基本思想">基本思想</h5><p>先将画面中的物体按其距离观察点的远近进行排序，结果存放在一张线形表中。距观察点远者称其优先级高，放在表头,距观察点近者称其优先级低，放在表尾，这张表称为深度优先级表。</p><p>然后按照从表头到表尾的顺序逐个绘制物体。由于距观察者近的物体在表尾最后画出，它覆盖了远处的物体，最终在屏幕上产生了正确的遮挡关系。</p><h5 id="缺陷">缺陷</h5><figure><img data-src="画家算法的缺陷.png" alt="画家算法的缺陷" /><figcaption aria-hidden="true">画家算法的缺陷</figcaption></figure><h4 id="z-buffer">Z-Buffer</h4><ul><li>frame buffer 存贮当前看到的场景</li><li>depth buffer 存储每个像素所看到的几何物体最浅的深度的信息</li></ul><figure><img data-src="深度缓存.png" alt="深度缓存" /><figcaption aria-hidden="true">深度缓存</figcaption></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Initialize depth buffer to +∞</span><br><span class="line"></span><br><span class="line">During rasterization:</span><br><span class="line">  <span class="keyword">for</span>(each triangle T)</span><br><span class="line">    <span class="keyword">for</span>(each sample (x,y,z) in T)</span><br><span class="line">      <span class="keyword">if</span>(z &lt; zbuffer[x,y])<span class="comment">// 如果该像素的深度小于此坐标深度缓存记录的深度</span></span><br><span class="line">        zbuffer[x,y] = z;<span class="comment">//更新深度</span></span><br><span class="line">        framebuffer[x,y] = color;<span class="comment">//更新 rgb</span></span><br></pre></td></tr></table></figure><p>处理不了透明物体</p><h3 id="shading着色">Shading『着色』</h3><p>The process of applying a material to an object.</p><h4 id="blinnphong-reflection-model布林-冯反射模型">Blinn–Phong reflection model『布林-冯反射模型』</h4><p>经验模型</p><ul><li>Ambient『环境光』</li><li>Diffuse『漫反射』</li><li>Specular『镜面反射/高光』</li></ul><p>Compute light reflected toward camera at a specific <strong>shading point</strong> Inputs:</p><ul><li>Viewer direction，观察方向，使用v表示</li><li>Surface normal，法线方向，使用n表示</li><li>Light direction，光线方向，使用l(小写的L)表示</li></ul><figure><img data-src="shading_point.png" alt="shading_point" /><figcaption aria-hidden="true">shading_point</figcaption></figure><p>Shading is Local =&gt; 着色不考虑其他物体的影响，只考虑着色点自身，故而只有明暗，没有阴影</p><h5 id="diffuse-reflection">Diffuse Reflection</h5><p>从接收角度看： In general, light per unit area is proportional to the cosine of the angle between the light direction and the surface normal =&gt; <span class="math inline">\(\cos\theta=l\cdot n\)</span></p><p>从输出角度看 <img data-src="LightFalloff.png" alt="LightFalloff" /> 光的能量会在传播中被“稀释”，一个单位面积上接收到的光的能量和光线传播的距离的平方成反比 =&gt; <span class="math inline">\(I/r^2\)</span> =&gt; 球！</p><p>综合来看</p><p><span class="math display">\[L_d = k_d(I/r^2)max(0,\vec{n}\cdot\vec{l})\]</span></p><p><span class="math inline">\(L_d\)</span> is diffusely <span class="math inline">\(k_d\)</span> is diffuse coefficient(color) <span class="math inline">\(I/r^2\)</span> is energy arrived at the shading point <span class="math inline">\(max(0,\vec{n}\cdot\vec{l})\)</span> is energy recevied by the shading point</p><p>观察方向对漫反射像完全没有影响 =&gt; 因为反射是完全随机的，因此可以认为漫反射光在任何反射方向上的分布都是一样的</p><h5 id="specular-highlights">Specular highlights</h5><p><img data-src="Specular_Term0.png" alt="Specular_Term0" /> 观察方向接近反射方向的时候才能观察到高光像 <img data-src="Specular_Term.png" alt="Specular_Term" /></p><p>v close to mirror direction(观察方向接近反射方向) &lt;=&gt; half vector near normal(半程向量接近法线向量)</p><p><span class="math display">\[\vec{h} = bisector(\vec{v},\vec{l}) = \frac{\vec{l}+\vec{v}}{||\vec{l}+\vec{v}||}\]</span></p><p><span class="math display">\[\begin{alignat}{2}L_s = k_s(I/r^2)max(0, \cos\alpha)^p\\ = k_s(I/r^2)max(0,\vec{n}\cdot\vec{h})^p\end{alignat}\]</span></p><p><span class="math inline">\(\alpha\)</span> is the angle between <span class="math inline">\(\vec{h}\)</span> and <span class="math inline">\(\vec{n}\)</span> <span class="math inline">\(p\)</span> is the shininess coefficient =&gt; Increasing p narrows the reflection lobe 『增大 p 可以缩小反射波瓣』 =&gt; 取值范围(100,200)</p><h5 id="ambient-lighting">Ambient lighting</h5><p><span class="math display">\[L_a = k_a I_a\]</span></p><p>环境光可以被简单的视为一个常数，尤其是在 Blinn–Phong model 中，但实际上他比这复杂得多 <span class="math inline">\(L_a\)</span> is reflected ambient light <span class="math inline">\(k_a\)</span> is ambient coefficient</p><figure><img data-src="Ambient.png" alt="Ambient" /><figcaption aria-hidden="true">Ambient</figcaption></figure><h5 id="将所有的项都加起来">将所有的项都加起来</h5><p><span class="math display">\[\begin{alignat}{2}L &amp; = L_a + L_d + L_s \\&amp; = k_a I_a + k_d(I/r^2)max(0,\vec{n}\cdot\vec{l}) + k_s(I/r^2)max(0,\vec{n}\cdot\vec{h})^p\end{alignat}\]</span></p><p>参考： <a href="https://zhuanlan.zhihu.com/p/442023993">Blinn-Phong光照模型从定义到实现</a></p><h4 id="shading-frequency着色频率">Shading Frequency『着色频率』</h4><ul><li>每个平面做一次shading =&gt; Flat shading</li><li>每个顶点做一次shading =&gt; Gouraud shading</li><li>每个像素做一次shading =&gt; Phong shading</li></ul><h5 id="顶点法线">顶点法线</h5><p>下图展示了一个简单的求法 <img data-src="顶点法线.png" alt="顶点法线" /> 把目标顶点所关联的面的法线向量求和取平均，即可得到目标顶点的法线向量</p><p><span class="math display">\[N_v = \frac{\sum_{i=1}^n N_i}{||\sum_{i=1}^n N_i||}\]</span></p><p>如果对三角形面进行加权，可以得到更精确的计算结果</p><h5 id="像素法线">像素法线</h5><p>已经得知了顶点法线后，问题可以转化为如何得到三角形面内部的一个平滑过渡的法线(假设三角形面大于至少一个像素) =&gt; 重心坐标 + 归一化</p><h4 id="graphics-real-time-rendering-pipeline图形管线">Graphics (Real-time Rendering) Pipeline『图形管线』</h4><figure><img data-src="GraphicsPipeline.png" alt="GraphicsPipeline" /><figcaption aria-hidden="true">GraphicsPipeline</figcaption></figure><p><a href="/http://shadertoy.com/view/ld3Gz2">shader toy</a> GPU 高度并行化处理</p><h4 id="texture-mapping纹理映射">Texture Mapping『纹理映射』</h4><p>在纹理上定义一个坐标系(u,v)(就是我们常说的 UV)，然后把纹理坐标映射到纹理上 =&gt; u 和 v 的取值范围是[0,1]</p><p>纹理要设计好在上下左右重复的时候无缝衔接 =&gt; tiled =&gt; method eg. Wang tiling</p><h4 id="interpolation插值">Interpolation『插值』</h4><h5 id="barycentric-coordinates重心坐标">Barycentric Coordinates『重心坐标』</h5><figure><img data-src="image/GAMES101Notes/三角形里的重心坐标.png" title="三角形里的重心坐标" alt="三角形里的重心坐标" /><figcaption aria-hidden="true">三角形里的重心坐标</figcaption></figure><p>如果 <span class="math inline">\(\alpha,\beta,\gamma\)</span> 的和为1，那么点一定和三角形在同一平面，如果三者的值都大于0，那么点一定在三角形内。</p><p>原理的数学证明：</p><p>设笛卡尔坐标系下某一平面内三点<span class="math inline">\(A,B,C,P\)</span>.</p><p>向量<span class="math inline">\(\vec{OP}\)</span> 可以表示为 <span class="math inline">\(\vec{OC}+m\vec{CB}+n\vec{BA}=(1-m)\vec{OC}+(m-n)\vec{OB}+n\vec{OA}\)</span></p><p>故</p><p><span class="math inline">\(\alpha=n\\\beta=m-n\\\gamma=1-m\)</span></p><p>显然，<span class="math inline">\(\alpha+\beta+\gamma=1\)</span></p><p>在平面<span class="math inline">\(ABCP\)</span>内，向量<span class="math inline">\(\vec{OP}\)</span> 仍然可以表示为 <span class="math inline">\(\vec{OC}+m\vec{CB}+n\vec{BA}=(1-m)\vec{OC}+(m-n)\vec{OB}+n\vec{OA}\)</span></p><p>要让 P 在 ABC 内，显然要使 m 的取值范围取 (0,1)，n 的取值范围取 (0,m)</p><h2 id="参考资料">参考资料</h2><ol type="1"><li><a href="https://www.bilibili.com/video/BV1X7411F744">闫令祺-GAMES101</a></li><li><a href="https://zhuanlan.zhihu.com/p/74736706">采样定理，频谱混叠和傅里叶变换 深入理解</a></li><li><a href="https://www.projectrhea.org/rhea/index.php/2015_Fall_ECE_438_Boutin_A_visual_explanation_of_aliasing_and_repetition_with_the_DTFT_Erik_Swan">A visual explanation of aliasing and repetition with the DTFT</a></li><li><a href="https://zhuanlan.zhihu.com/p/442023993">Blinn-Phong光照模型从定义到实现</a></li><li><a href="/http://shadertoy.com/view/ld3Gz2">shader toy</a></li><li><a href="https://blog.csdn.net/qq_38065509/category_9873936.html">剑 来!'s 计算机图形学笔记</a></li><li><a href="https://zhuanlan.zhihu.com/p/144360079">计算机图形学补充1：重心坐标(barycentric coordinates)详解及其作用 - 知乎 (zhihu.com)</a></li></ol>]]></content:encoded>
      
      
      <category domain="https://rdququ.top/categories/%E5%AD%A6%E4%B9%A0%E5%90%91/">学习向</category>
      
      <category domain="https://rdququ.top/categories/%E5%AD%A6%E4%B9%A0%E5%90%91/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/">计算机图形学</category>
      
      
      <category domain="https://rdququ.top/tags/GAMES101Notes/">GAMES101Notes</category>
      
      
      <comments>https://rdququ.top/posts/6206937d/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>GAMES104Notes</title>
      <link>https://rdququ.top/posts/32cb02ce/</link>
      <guid>https://rdququ.top/posts/32cb02ce/</guid>
      <pubDate>Mon, 06 Nov 2023 04:49:57 GMT</pubDate>
      
      <description>&lt;p&gt;GAMES104Notes&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>GAMES104Notes</p><span id="more"></span><figure><img data-src="GAMES104_Zoo%20of%20Game%20Engines-1.png" alt="AMES104_Zoo of Game Engines-1" /><figcaption aria-hidden="true">AMES104_Zoo of Game Engines-1</figcaption></figure><figure><img data-src="GAMES104_Middlewares.png" alt="GAMES104_Middlewares" /><figcaption aria-hidden="true">GAMES104_Middlewares</figcaption></figure><h2 id="引擎的基本架构">引擎的基本架构</h2><p>自顶向底的五层架构</p><ul><li>Tool Layer 工具链和编辑环境</li><li>Function Layer 游戏逻辑设计</li><li>Resource Layer 处理存储不同种类的文件资源</li><li>Core Layer 构建功能</li><li>Platform Layer 硬件的运行环境，输入设备的差别，软件的发布平台</li></ul><h3 id="resource-layer">resource layer</h3><p>importing: resource -&gt; asset</p><p>全局唯一编号: GUID</p><p>Runtime Asset Manager</p><p>Manager Asset Life Cycle</p><h3 id="function-layer">Function Layer</h3><p>tick &amp; frame</p><p>Multi-threading</p><h3 id="core-layer">Core Layer</h3><p>Math Library</p><p>Math Efficiency eg. Quick and dirty hacks</p><ul><li>Carmack's 1/sqrt(x)</li><li>Magic number</li></ul><p>eg. SIMD<img data-src="SIMD-1.png" alt="Alt text" /></p><p>Data Structure and Containers</p><p>Memory Management</p><p>Foundation of Game Engine</p><h3 id="platform-layer">Platform Layer</h3><p>Target on Different Platform</p><p>Graphics API eg. Render Hardware Interface(RHI)</p><p>Hardware Architecture</p><h3 id="tool-layer">Tool Layer</h3><p>Allow Anyone to Create Game</p><p>Digital Content Creation(DCC)</p><h2 id="如何构建游戏世界">如何构建游戏世界</h2><h3 id="game-objectgo">game object(GO)</h3><h4 id="property">property</h4><h4 id="behavior">behavior</h4><h4 id="oop-vs.-component">OOP vs. Component</h4><p>OOP 也符合直觉，但是在复杂的游戏世界中并没有非常清晰的父子继承关系。</p><p>现在更多地使用 Component 的方式，将游戏对象的行为分解为多个组件，每个组件只负责一种行为。</p><h4 id="component-based-tick">Component-based Tick</h4><p>和曾经分GO Tick不同，现在是分Component Tick。由于 pipeline 效率更高</p><h4 id="go-间通信">GO 间通信</h4><ul><li>Hard Code</li><li>Event</li><li>uid</li></ul><h4 id="scene-management">Scene Management</h4><ol type="1"><li><p>No division &amp; Drived by grid</p></li><li><p>Spatial Data Structures</p><ul><li>Quadtree</li><li>Octree</li><li>Binary Space Partitioning(BSP)</li><li>Bounding Volume Hierarchy(BVH)</li><li>Scene Graph</li></ul></li></ol><h2 id="rendering">Rendering</h2><h3 id="basics-of-game-rendering">Basics of Game Rendering</h3><h4 id="gpu">GPU</h4><h5 id="simdsingle-instruction-multiple-data单指令多数据">SIMD(Single Instruction Multiple Data/单指令多数据)</h5><p><code>SMID_ADD c, a, b</code></p><h5 id="simtsingle-instruction-multiple-thread单指令多线程">SIMT(Single Instruction Multiple Thread/单指令多线程)</h5><p><code>SIMT_ADD c, a, b</code></p><h5 id="gpu-architecture">GPU Architecture</h5><ul><li>GPC(Graphics Processing Cluster)</li><li>SM(Streaming Multiprocessor)</li><li>Texture Units</li><li>CUDA Core</li><li>Warp</li></ul><figure><img data-src="GAMES101_GPU_Architecture.png" alt="GPU Architecture" /><figcaption aria-hidden="true">GPU Architecture</figcaption></figure><h5 id="data-flow-from-cpu-to-gpu">Data Flow From CPU to GPU</h5><ul><li>CPU and Main Memory</li><li>CPU to GPU</li><li>GPU and Video Memory</li></ul><p>尽可能让数据单向传输，从 CPU 到 GPU 尽可能不要从 GPU 里读数据</p><h5 id="be-aware-of-cache-efficiency">Be Aware of Cache Efficiency</h5><p>数据一定要放在一起为 Cache(缓存) 做准备</p><h5 id="gpu-bounds-and-performance">GPU Bounds and Performance</h5><h4 id="renderable">Renderable</h4><h5 id="mesh">Mesh</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span></span><br><span class="line">&#123;</span><br><span class="line">  Vector3 m_position;</span><br><span class="line">  <span class="comment">// other attributes</span></span><br><span class="line">  UByte4 m_color;</span><br><span class="line">  Vector3 m_normal;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mesh</span></span><br><span class="line">&#123;</span><br><span class="line">  Vertex m_vertex[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>Vertex Data<ul><li>Vertex declaration</li><li>Vertex buffer</li></ul></li><li>Index Data<ul><li>Index declaration</li><li>Index buffer</li></ul></li></ul><p>Triangle Strip 利好 Cache</p><h3 id="material-shader-and-lighting">Material, Shader, and Lighting</h3><h3 id="special-rendering">Special Rendering</h3><h3 id="pipeline">Pipeline</h3>]]></content:encoded>
      
      
      <category domain="https://rdququ.top/categories/%E5%AD%A6%E4%B9%A0%E5%90%91/">学习向</category>
      
      <category domain="https://rdququ.top/categories/%E5%AD%A6%E4%B9%A0%E5%90%91/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/">游戏引擎</category>
      
      
      <category domain="https://rdququ.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/">计算机图形学</category>
      
      <category domain="https://rdququ.top/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/">游戏引擎</category>
      
      <category domain="https://rdququ.top/tags/GAMES104/">GAMES104</category>
      
      
      <comments>https://rdququ.top/posts/32cb02ce/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
