<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>蛐蛐的游戏开发世界</title>
    <link>http://rdququ.top/</link>
    
    <atom:link href="http://rdququ.top/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>正在学习unity中</description>
    <pubDate>Mon, 21 Aug 2023 11:16:06 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Unity集换式卡牌游戏_Dictionry序列化成json</title>
      <link>http://rdququ.top/2023/08/21/Dictionry%E5%BA%8F%E5%88%97%E5%8C%96%E6%88%90json/</link>
      <guid>http://rdququ.top/2023/08/21/Dictionry%E5%BA%8F%E5%88%97%E5%8C%96%E6%88%90json/</guid>
      <pubDate>Mon, 21 Aug 2023 06:57:15 GMT</pubDate>
      
      <description>&lt;p&gt;在开始讲解这一章节前，我们需要了解，什么是 Json.&lt;/p&gt;
&lt;h2 id=&quot;Json&quot;&gt;&lt;a href=&quot;#Json&quot; class=&quot;headerlink&quot; title=&quot;Json&quot;&gt;&lt;/a&gt;Json&lt;/h2&gt;&lt;p&gt;他的全称是 JavaScript Object Notation 【JavaScript 对象表示法】&lt;br&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>在开始讲解这一章节前，我们需要了解，什么是 Json.</p><h2 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h2><p>他的全称是 JavaScript Object Notation 【JavaScript 对象表示法】<br> <span id="more"></span><br>JSON 是存储和交换文本信息的<code>语法</code>。类似 XML。json是基于<code>ECMAScript</code>语法，但这并不意味着 json 必须在 js 中使用，或者必须要产生什么联系， json 在 js 中的处理也并没有比其他语言占有更多优势。只是因为语法相似，而使得js开发者能更快的上手 json 而已。</p><p>JSON采用完全独立于任何程序语言的文本格式,但是也使用了类似于 C 语言家族的习惯（包括 C、C++、C#、Java、JavaScript、Perl、Python 等）。这些特性使 JSON 成为理想的数据交换语言。易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。  </p><h3 id="典型的-Json-数据"><a href="#典型的-Json-数据" class="headerlink" title="典型的 Json 数据"></a>典型的 Json 数据</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">对象：</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;火球术&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;cost&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Owner&quot;</span><span class="punctuation">:</span> <span class="string">&quot;法师&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">数组：</span><br><span class="line"><span class="punctuation">[</span><span class="string">&quot;hello&quot;</span><span class="punctuation">,</span><span class="number">3.1415</span><span class="punctuation">,</span><span class="string">&quot;json&quot;</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">数组嵌套对象：</span><br><span class="line"><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;admin&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">18</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;root&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">16</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">20</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><h3 id="Json-语法规则"><a href="#Json-语法规则" class="headerlink" title="Json 语法规则"></a>Json 语法规则</h3><ul><li>数据在 <code>键值对</code> 中</li><li>数据由逗号 , 分隔</li><li>使用斜杆 \ 来转义字符</li><li>大括号 {} 保存对象</li><li>中括号 [] 保存数组，数组可以包含多个对象</li></ul><h4 id="json-的值"><a href="#json-的值" class="headerlink" title="json 的值"></a>json 的值</h4><ul><li>数字（整数或浮点数）</li><li>字符串（在双引号中）</li><li>逻辑值（true 或 false）</li><li>数组（在中括号中）</li><li>对象（在大括号中）</li><li>null</li></ul><h2 id="JsonUtility"><a href="#JsonUtility" class="headerlink" title="JsonUtility"></a>JsonUtility</h2><p>JsonUtility 是 Unity 提供的一个工具类，用于序列化和反序列化 Json 数据。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="built_in">string</span> json = JsonUtility.ToJson(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line">myObject = JsonUtility.FromJson&lt;T&gt;(json);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 Json 文本中读取数据并将其反序列化到现有对象中。</span></span><br><span class="line">FromJsonOverwrite(<span class="built_in">string</span> text, <span class="built_in">object</span> objectToOverwrite)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ToJson(<span class="built_in">object</span> target, <span class="built_in">bool</span> prettyPrint)</span><br><span class="line">target：对象转换为 Json 数据文本</span><br><span class="line">prettyPrint：决定最终的 Json 数据文本是否是一个格式化后的数据文本。</span><br><span class="line">即是否使用 Json 文本的 Format 化。</span><br><span class="line"></span><br><span class="line">FromJson(<span class="built_in">string</span> text)</span><br><span class="line">将 Json 数据文本转存至类中 <span class="keyword">public</span> 或 附有 SerializeField 特性的字段上赋值。</span><br><span class="line">使用时无需管理值具体分配。其将基于字段命名自行匹配并赋值。</span><br><span class="line">此代码将创建一个新的 T 实例，并使用 JSON 数据设置该实例的值。如果 JSON 数据包含的某些值未映射到 T 中的字段，则序列化程序将忽略这些值。如果 JSON 数据缺少 T 中某些字段的值，则序列化程序会在返回的对象中保留这些字段的构造值。</span><br><span class="line"></span><br><span class="line">FromJsonOverwrite(<span class="built_in">string</span> text, <span class="built_in">object</span> objectToOverwrite)</span><br><span class="line">在现有对象上反序列化 JSON 数据，从而覆盖所有现有数据。</span><br><span class="line">使用时无需管理值具体分配。其将基于字段命名自行匹配并赋值。</span><br><span class="line">如果 JSON 数据不包含某个字段的值，则序列化程序不会更改该字段的值。</span><br><span class="line">JSON 序列化程序 API 支持 MonoBehaviour 和 ScriptableObject 子类以及普通结构和类。但是，将 JSON 反序列化为 MonoBehaviour 或 ScriptableObject 子类时，必须使用 FromJsonOverwrite 方法。如果尝试使用 FromJson，则 Unity 会抛出异常，因为不支持此行为。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>仅支持 MonoBehaviour &#x2F; ScriptableObject 继承类的序列化</li><li>仅支持 [Serializable] 的普通类与结构体</li><li>仅序列化 public 或 [SerializeField] 标签的字段  </li><li>在内部，此方法使用 Unity 序列化器；因此传入的对象必须受序列化器支持：它必须是 MonoBehaviour、ScriptableObject 或应用了 Serializable 属性的普通类&#x2F;结构。要包含的字段的类型必须受序列化器支持；不受支持的字段以及私有字段、静态字段和应用了 NonSerialized 属性的字段会被忽略。</li><li>支持 List、Array 数据类型，但不支持 Dictionary、Query、Stack 等集合</li><li>支持 Enum 枚举，但默认存储值为数值类型</li></ul><h2 id="字典的序列化和反序列化"><a href="#字典的序列化和反序列化" class="headerlink" title="字典的序列化和反序列化"></a>字典的序列化和反序列化</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SerializeDictionary</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">DicToJson</span>&lt;<span class="title">TKey</span>, <span class="title">TValue</span>&gt;(<span class="params">Dictionary&lt;TKey, TValue&gt; dic</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> JsonUtility.ToJson(<span class="keyword">new</span> SerializeDictionary&lt;TKey, TValue&gt;(dic));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">Dictionary</span>&lt;<span class="title">TKey</span>, <span class="title">TValue</span>&gt; <span class="title">DicFromJson</span>&lt;<span class="title">TKey</span>, <span class="title">TValue</span>&gt;(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> JsonUtility.FromJson&lt;SerializeDictionary&lt;TKey, TValue&gt;&gt;(str).ToDictionary();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SerializeDictionary</span>&lt;<span class="title">TKey</span>, <span class="title">TValue</span>&gt; : <span class="title">ISerializationCallbackReceiver</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    List&lt;TKey&gt; keys;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    List&lt;TValue&gt; values;</span><br><span class="line"></span><br><span class="line">    Dictionary&lt;TKey, TValue&gt; target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dictionary&lt;TKey, TValue&gt; <span class="title">ToDictionary</span>()</span> &#123; <span class="keyword">return</span> target; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SerializeDictionary</span>(<span class="params">Dictionary&lt;TKey, TValue&gt; target</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnBeforeSerialize</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        keys = <span class="keyword">new</span> List&lt;TKey&gt;(target.Keys);</span><br><span class="line">        values = <span class="keyword">new</span> List&lt;TValue&gt;(target.Values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnAfterDeserialize</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> count = Math.Min(keys.Count, values.Count);</span><br><span class="line">        target = <span class="keyword">new</span> Dictionary&lt;TKey, TValue&gt;(count);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            target.Add(keys[i], values[i]);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>本文作于2023-08-15，首发于个人博客<a href="https://rdququ.top/">https://rdququ.top/</a></p>]]></content:encoded>
      
      
      <category domain="http://rdququ.top/categories/%E6%95%99%E7%A8%8B%E5%90%91/">教程向</category>
      
      <category domain="http://rdququ.top/categories/%E6%95%99%E7%A8%8B%E5%90%91/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</category>
      
      <category domain="http://rdququ.top/categories/%E6%95%99%E7%A8%8B%E5%90%91/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/">Unity</category>
      
      <category domain="http://rdququ.top/categories/%E6%95%99%E7%A8%8B%E5%90%91/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/%E9%9B%86%E6%8D%A2%E5%BC%8F%E5%8D%A1%E7%89%8C%E6%B8%B8%E6%88%8F/">集换式卡牌游戏</category>
      
      
      <category domain="http://rdququ.top/tags/Unity/">Unity</category>
      
      <category domain="http://rdququ.top/tags/%E5%8D%A1%E7%89%8C%E6%B8%B8%E6%88%8F/">卡牌游戏</category>
      
      <category domain="http://rdququ.top/tags/%E6%95%99%E7%A8%8B%EF%BC%8CJson/">教程，Json</category>
      
      <category domain="http://rdququ.top/tags/%E5%AD%97%E5%85%B8/">字典</category>
      
      <category domain="http://rdququ.top/tags/%E5%BA%8F%E5%88%97%E5%8C%96/">序列化</category>
      
      
      <comments>http://rdququ.top/2023/08/21/Dictionry%E5%BA%8F%E5%88%97%E5%8C%96%E6%88%90json/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Unity集换式卡牌游戏_第4期_配表与读取你的卡牌</title>
      <link>http://rdququ.top/2023/08/15/%E7%AC%AC4%E6%9C%9F-%E9%85%8D%E8%A1%A8%E4%B8%8E%E8%AF%BB%E5%8F%96%E4%BD%A0%E7%9A%84%E5%8D%A1%E7%89%8C/</link>
      <guid>http://rdququ.top/2023/08/15/%E7%AC%AC4%E6%9C%9F-%E9%85%8D%E8%A1%A8%E4%B8%8E%E8%AF%BB%E5%8F%96%E4%BD%A0%E7%9A%84%E5%8D%A1%E7%89%8C/</guid>
      <pubDate>Tue, 15 Aug 2023 13:03:15 GMT</pubDate>
      
      <description>&lt;p&gt;在上一期中，我们制作了自己的第一张卡牌，并且通过&lt;code&gt;CardDisplay&lt;/code&gt;类中的&lt;code&gt;DisplayCard()&lt;/code&gt;方法展示了我们卡牌的属性。当时为了方便展示，我们直接在&lt;code&gt;CardDisplay&lt;/code&gt;中的&lt;code&gt;Start()&lt;/code&gt;里 new 了一张火球术出来&lt;br&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>在上一期中，我们制作了自己的第一张卡牌，并且通过<code>CardDisplay</code>类中的<code>DisplayCard()</code>方法展示了我们卡牌的属性。当时为了方便展示，我们直接在<code>CardDisplay</code>中的<code>Start()</code>里 new 了一张火球术出来<br> <span id="more"></span></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cardModel = <span class="keyword">this</span>.GetModel&lt;CardModel&gt;();</span><br><span class="line">        card =<span class="keyword">new</span> SpellCard(<span class="number">1</span>, <span class="string">&quot;Fireball&quot;</span>, <span class="string">&quot;Deals 5 damage&quot;</span>, <span class="number">5</span>, <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;Fire&quot;</span> &#125;);<span class="comment">//就是这句啦</span></span><br><span class="line">        DisplayCard();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然鹅，我们显然不能把我们所以的卡牌都以这样的方法 new 出来，我们需要一种更成熟，更方便的方法获取我们的卡牌————读配表。</p><h2 id="配表"><a href="#配表" class="headerlink" title="配表"></a>配表</h2><p>在实际开发中策划会不断地提出不同的需求，但是他们不会直接对代码进行操作，而是通过和程序的沟通间接完成，而将它们对数值的具体需求，忠实的向程序反映的桥梁就是数据表，一个典型的数据表可能是这样的：</p><table><thead><tr><th></th><th>主键</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>类型</td><td>INT</td><td>STRING</td><td>STRING</td></tr><tr><td>字段名</td><td>ID</td><td>Name</td><td>Desc</td></tr><tr><td></td><td>1</td><td>勇士</td><td>勇敢的战士，遵循你的召唤而降生</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p>当然，实际的表可能会比这复杂的多。程序需要做的，就是去读取这张表，并可能将他以另外某种形式储存起来。持久存储数据的方法有很多，CSV,Json,XML,二进制…今天我们主要介绍的，就是CSV文件的读取。  </p><h2 id="csv的读取"><a href="#csv的读取" class="headerlink" title="csv的读取"></a>csv的读取</h2><p>csv其实就是 <code>Comma-Separated Values</code> -&gt; 逗号分隔的值<br>想要新建一个 csv 文件，就用 Excel 把 xls 另存为 csv 文件即可。<br>在视频中，我们新建了一个 CardData 文件，我们是这样读取他的</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadCardsFromCsv</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       cardData = Resources.Load&lt;TextAsset&gt;(<span class="string">&quot;Data/cardData&quot;</span>);<span class="comment">//读取csv文件</span></span><br><span class="line">       <span class="built_in">string</span>[] dataRow = cardData.text.Split(<span class="string">&#x27;\n&#x27;</span>);<span class="comment">//按行分割</span></span><br><span class="line">       <span class="keyword">foreach</span>(<span class="keyword">var</span> row <span class="keyword">in</span> dataRow)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">string</span>[] rowArray = row.Split(<span class="string">&#x27;,&#x27;</span>);<span class="comment">//按列分割</span></span><br><span class="line">           <span class="keyword">if</span> (rowArray[<span class="number">0</span>] == <span class="string">&quot;类型&quot;</span>)<span class="comment">//跳过第一行</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (rowArray[<span class="number">0</span>] == <span class="string">&quot;MonsterCard&quot;</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               MonsterCard monsterCard = <span class="keyword">new</span> MonsterCard(<span class="built_in">int</span>.Parse(rowArray[<span class="number">1</span>]), rowArray[<span class="number">2</span>], rowArray[<span class="number">3</span>], <span class="built_in">int</span>.Parse(rowArray[<span class="number">4</span>]), rowArray[<span class="number">5</span>].Split(<span class="string">&#x27;;&#x27;</span>), <span class="built_in">int</span>.Parse(rowArray[<span class="number">9</span>]), <span class="built_in">int</span>.Parse(rowArray[<span class="number">10</span>]));</span><br><span class="line">               totalCards.Add(monsterCard);</span><br><span class="line">               Debug.Log(<span class="string">&quot;monsterCard.Name&quot;</span>+monsterCard.Name);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (rowArray[<span class="number">0</span>] == <span class="string">&quot;SpellCard&quot;</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               SpellCard spellCard = <span class="keyword">new</span> SpellCard(<span class="built_in">int</span>.Parse(rowArray[<span class="number">1</span>]), rowArray[<span class="number">2</span>], rowArray[<span class="number">3</span>], <span class="built_in">int</span>.Parse(rowArray[<span class="number">4</span>]), rowArray[<span class="number">5</span>].Split(<span class="string">&#x27;;&#x27;</span>));</span><br><span class="line">               totalCards.Add(spellCard);</span><br><span class="line">               Debug.Log(<span class="string">&quot;spellCard.Name&quot;</span> + spellCard.Name);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我们先用<code>/n</code>把文件分割成一行一行的字符串数组，再通过<code>,</code>如法炮制，把每一行都分割成对应 csv 表格的字符串数组，方便我们读取。跳过不需要读取的行， 我们按照事先标记的卡牌的种类，依次 new 出具体的 card，并把他们储存到 <code>List&lt;Card&gt;</code> 中去。 就这样，我们的卡牌的读取就顺利完成了，其实并没有什么难度，也适合自由发挥。<br>在视频的最后，我留下了 SkillData 没有读取，这里把读取方法一并写出。<br>我们新建了 Skill 类 和 SkillModel 类</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Skill</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">int</span> ID;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">string</span> Description;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">int</span> SkillValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> QFramework;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SkillModel</span> :<span class="title">AbstractModel</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> TextAsset skillData;</span><br><span class="line">    List&lt;Skill&gt; totalSkills = <span class="keyword">new</span> List&lt;Skill&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnInit</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        LoadSkillsFromCsv();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadSkillsFromCsv</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        skillData = Resources.Load&lt;TextAsset&gt;(<span class="string">&quot;Data/SkillData&quot;</span>);<span class="comment">//读取csv文件</span></span><br><span class="line">        <span class="built_in">string</span>[] dataRow = skillData.text.Split(<span class="string">&#x27;\n&#x27;</span>);<span class="comment">//按行分割</span></span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> row <span class="keyword">in</span> dataRow)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span>[] rowArray = row.Split(<span class="string">&#x27;,&#x27;</span>);<span class="comment">//按列分割</span></span><br><span class="line">            <span class="keyword">if</span> (rowArray[<span class="number">0</span>] == <span class="string">&quot;技能ID&quot;</span>)<span class="comment">//跳过第一行</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Skill skill = <span class="keyword">new</span> Skill();</span><br><span class="line">                skill.ID = <span class="built_in">int</span>.Parse(rowArray[<span class="number">0</span>]);</span><br><span class="line">                skill.Name = rowArray[<span class="number">1</span>];</span><br><span class="line">                skill.Description = rowArray[<span class="number">2</span>];</span><br><span class="line">                skill.SkillValue = <span class="built_in">int</span>.Parse(rowArray[<span class="number">5</span>]);      </span><br><span class="line">                totalSkills.Add(skill);</span><br><span class="line">                Debug.Log(<span class="string">&quot;读取了技能&quot;</span>+skill.Name+<span class="string">&quot; 技能ID: &quot;</span>+skill.ID+<span class="string">&quot; 技能描述: &quot;</span>+skill.Description+<span class="string">&quot; 技能数值: &quot;</span>+skill.SkillValue);</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，和上次我们写的 Card 颇有不同，也是想借此告诉大家，程序的设计方法千千万，不必拘泥于某一种写法，因地制宜才是妙招。</p><hr><p>本文作于2023-08-15，首发于个人博客<a href="https://rdququ.top/">https://rdququ.top/</a></p>]]></content:encoded>
      
      
      <category domain="http://rdququ.top/categories/%E6%95%99%E7%A8%8B%E5%90%91/">教程向</category>
      
      <category domain="http://rdququ.top/categories/%E6%95%99%E7%A8%8B%E5%90%91/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</category>
      
      <category domain="http://rdququ.top/categories/%E6%95%99%E7%A8%8B%E5%90%91/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/">Unity</category>
      
      <category domain="http://rdququ.top/categories/%E6%95%99%E7%A8%8B%E5%90%91/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/%E9%9B%86%E6%8D%A2%E5%BC%8F%E5%8D%A1%E7%89%8C%E6%B8%B8%E6%88%8F/">集换式卡牌游戏</category>
      
      
      <category domain="http://rdququ.top/tags/Unity/">Unity</category>
      
      <category domain="http://rdququ.top/tags/%E5%8D%A1%E7%89%8C%E6%B8%B8%E6%88%8F/">卡牌游戏</category>
      
      <category domain="http://rdququ.top/tags/%E6%95%99%E7%A8%8B/">教程</category>
      
      
      <comments>http://rdququ.top/2023/08/15/%E7%AC%AC4%E6%9C%9F-%E9%85%8D%E8%A1%A8%E4%B8%8E%E8%AF%BB%E5%8F%96%E4%BD%A0%E7%9A%84%E5%8D%A1%E7%89%8C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Unity集换式卡牌游戏_制作第一张卡牌</title>
      <link>http://rdququ.top/2023/08/12/Unity%E9%9B%86%E6%8D%A2%E5%BC%8F%E5%8D%A1%E7%89%8C%E6%B8%B8%E6%88%8F-%E5%88%B6%E4%BD%9C%E7%AC%AC%E4%B8%80%E5%BC%A0%E5%8D%A1%E7%89%8C/</link>
      <guid>http://rdququ.top/2023/08/12/Unity%E9%9B%86%E6%8D%A2%E5%BC%8F%E5%8D%A1%E7%89%8C%E6%B8%B8%E6%88%8F-%E5%88%B6%E4%BD%9C%E7%AC%AC%E4%B8%80%E5%BC%A0%E5%8D%A1%E7%89%8C/</guid>
      <pubDate>Sat, 12 Aug 2023 14:53:45 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;前期准备&quot;&gt;&lt;a href=&quot;#前期准备&quot; class=&quot;headerlink&quot; title=&quot;前期准备&quot;&gt;&lt;/a&gt;前期准备&lt;/h2&gt;&lt;p&gt;我们制作卡牌游戏之前，先得拿到一套可用的素材，这里我们使用的是&lt;a href=&quot;https://assetstore.unity.com/packages/2d/gui/2d-modular-cards-kit-demo-227623&quot;&gt;卡牌游戏素材&lt;/a&gt;。&lt;br&gt;在上方状态栏中，窗口下的资源商店中搜索&lt;code&gt;2D Modular Cards Kit Demo&lt;/code&gt;，点击下载即可。下载完成后，仍然是在窗口下的包管理器中，选择我的资产，下载后导入即可。&lt;br&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>我们制作卡牌游戏之前，先得拿到一套可用的素材，这里我们使用的是<a href="https://assetstore.unity.com/packages/2d/gui/2d-modular-cards-kit-demo-227623">卡牌游戏素材</a>。<br>在上方状态栏中，窗口下的资源商店中搜索<code>2D Modular Cards Kit Demo</code>，点击下载即可。下载完成后，仍然是在窗口下的包管理器中，选择我的资产，下载后导入即可。<br> <span id="more"></span><br><img src="/2023/08/12/Unity%E9%9B%86%E6%8D%A2%E5%BC%8F%E5%8D%A1%E7%89%8C%E6%B8%B8%E6%88%8F-%E5%88%B6%E4%BD%9C%E7%AC%AC%E4%B8%80%E5%BC%A0%E5%8D%A1%E7%89%8C/%E8%B5%84%E6%BA%90%E5%95%86%E5%BA%97%E5%92%8C%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8.png" alt="资源商店和包管理器"><br>导入好素材后，我们还需要处理一二。选择 Sprite Texture Folder 下的 Cards 在 Inspector 中，将 Texture Type 改为 Sprite(2D and UI)。Sprite Mode 改为 Multiple，点击 Sprite Editor，点击 Slice，选择 Type 为 Automatic 即可，点击 Slice，点击 Apply。 当然，这是简单且不完美的做法的做法。<br>更好的做法是，选择 Type 为 Grid By Cell Size，然后量体裁衣。但就这个素材，我已经量好了：<br>像素大小 X 94 Y 126<br>偏移 X 17 Y 6<br>填充 X 34 Y 0<br>大家直接用就行。<br>到这里，素材处理完了，我们还需要制作一下 TMP 可用的字体。<br>在 C:\Windows\Fonts 里有很多本机字体，我们可以直接使用。 再在网上找一个常用，就可以开始制作字体了。这里我们直说怎么最快的做出来，不加以详细阐释，大家感兴趣可以自行搜教程，或者我有空补写一个。<br>我的版本是 2021.3.12 这在最上面也能看得出来。<br><img src="/2023/08/12/Unity%E9%9B%86%E6%8D%A2%E5%BC%8F%E5%8D%A1%E7%89%8C%E6%B8%B8%E6%88%8F-%E5%88%B6%E4%BD%9C%E7%AC%AC%E4%B8%80%E5%BC%A0%E5%8D%A1%E7%89%8C/Unity%E7%89%88%E6%9C%AC.png" alt="Unity版本"><br>窗口 -&gt; TextMeshPro -&gt; Font Asset Creator<br>Source Font File 选择我们刚刚下载的字体，Character Set 选择 Characters from File,下方的 Characters File 选择你的字库, Atlas Resolution 选择 2048*2048 , padding 在 2-6左右, 然后点击 Generate Font Atlas 即可。<br>可以参考这篇文章：<a href="https://blog.csdn.net/qq_37454669/article/details/121128100">https://blog.csdn.net/qq_37454669/article/details/121128100</a><br>制作好字体，拖进你的Text一类的组件里的 Font Asset里，就可以使用了。</p><h2 id="制作第一张卡牌-UI"><a href="#制作第一张卡牌-UI" class="headerlink" title="制作第一张卡牌-UI"></a>制作第一张卡牌-UI</h2><p>终于做好前期准备了，来看UI吧。<br>这段看视频就好了，我就不写了（逃</p><h2 id="制作第一张卡牌-逻辑"><a href="#制作第一张卡牌-逻辑" class="headerlink" title="制作第一张卡牌-逻辑"></a>制作第一张卡牌-逻辑</h2><p>这边是有些要细说的点的<br>首先，我们新建一个 Card 脚本，把里面的东西都删掉，新建一个 Card 类。这个类我们放 Card 共有的一些属性，比如ID，Name，Description，Cost等等。还有卡牌可以发动的技能，我们也写上去。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Card</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ID;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Description;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Cost;</span><br><span class="line">    <span class="built_in">string</span>[] SpellType;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Card</span>(<span class="params"><span class="built_in">int</span> id, <span class="built_in">string</span> name, <span class="built_in">string</span> description, <span class="built_in">int</span> cost, <span class="built_in">string</span>[] spellType</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ID = id;</span><br><span class="line">        Name = name;</span><br><span class="line">        Description = description;</span><br><span class="line">        Cost = cost;</span><br><span class="line">        SpellType = spellType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpellType 这个属性，我们用来存储卡牌的技能。做成String[]是因为，一个卡牌可以有多个技能，比如一个卡牌可以是<code>[攻击, 防御]</code>，也可以是<code>[攻击, 防御, 治疗]</code>。同样，String也方便我们读表。<br>同样，一张卡也有不同的类型，比如怪兽卡，魔法卡，陷阱卡等等。我们可以用一个枚举来表示这些类型，也可以用子类，我这里没有使用枚举类型，并不是说枚举就不好，相反，枚举类型在某些时候更加高效，但是我这里用子类，是因为我想让大家看到子类的使用，同样，这里使用子类逻辑也会更清晰。如果我们未来卡牌种类有很多，使用子类也能避免枚举类型照顾太多属性的问题。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MonsterCard</span> : <span class="title">Card</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Health;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Attack;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MonsterCard</span>(<span class="params"><span class="built_in">int</span> id, <span class="built_in">string</span> name, <span class="built_in">string</span> description, <span class="built_in">int</span> cost,<span class="built_in">string</span>[] spellType, <span class="built_in">int</span> health, <span class="built_in">int</span> attack</span>) : <span class="title">base</span>(<span class="params">id, name, description, cost, spellType</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Health = health;</span><br><span class="line">        Attack = attack;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SpellCard</span> : <span class="title">Card</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpellCard</span>(<span class="params"><span class="built_in">int</span> id, <span class="built_in">string</span> name, <span class="built_in">string</span> description, <span class="built_in">int</span> cost,<span class="built_in">string</span>[] spellType</span>) : <span class="title">base</span>(<span class="params">id, name, description, cost, spellType</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们前面制作了卡牌的UI，那么我们也需要一个脚本来控制卡牌的展示逻辑。同样的，有时候我们在这里会使用一个静态的 UIManager 单例。但我像把他留在后面，所以这里我们就不用单例了。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> TMPro;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CardDisplay</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> TextMeshProUGUI nameText;</span><br><span class="line">    <span class="keyword">public</span> TextMeshProUGUI descriptionText;</span><br><span class="line">    <span class="keyword">public</span> TextMeshProUGUI costText;</span><br><span class="line">    <span class="keyword">public</span> TextMeshProUGUI healthText;</span><br><span class="line">    <span class="keyword">public</span> TextMeshProUGUI attackText;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Card card;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        card =<span class="keyword">new</span> SpellCard(<span class="number">1</span>, <span class="string">&quot;Fireball&quot;</span>, <span class="string">&quot;Deals 5 damage&quot;</span>, <span class="number">5</span>, <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;Fire&quot;</span> &#125;);</span><br><span class="line">        DisplayCard();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DisplayCard</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        nameText.text = card.Name;</span><br><span class="line">        descriptionText.text = card.Description;</span><br><span class="line">        costText.text = card.Cost.ToString();</span><br><span class="line">        <span class="keyword">if</span> (card.GetType() == <span class="keyword">typeof</span>(MonsterCard))</span><br><span class="line">        &#123;</span><br><span class="line">            MonsterCard monsterCard = (MonsterCard)card;</span><br><span class="line">            healthText.text = monsterCard.Health.ToString();</span><br><span class="line">            attackText.text = monsterCard.Attack.ToString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            healthText.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">            attackText.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用TMP一定要 using TMPro;<br>我们先声明一些 TextMeshProUGUI 然后在 Unity 里把他们拖进 CardDisplay.<br>同样，我们也需要声明一个 Card 类型的变量，用来存储我们的卡牌。在Start里，我们初始化一个卡牌，否则不方便演示， card也会变成一个野指针。这是我们要极力避免的。<br>随机我们开始编写 DisplayCard() 方法。这里的逻辑很好理解————就是’有的显示，没的隐藏’， 当然， 我后面使用 else 显然是不合时宜的，我后面会修改的。  </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MonsterCard monsterCard = (MonsterCard)card;</span><br></pre></td></tr></table></figure><p>也可以写作</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MonsterCard monsterCard = card <span class="keyword">as</span> MonsterCard;</span><br></pre></td></tr></table></figure><p>看起来会更优雅一点。<br>最好，不要忘记在Start()里面调用DisplayCard()方法，否则你的卡牌就不会显示了。</p><hr><p>本文作于2023-08-12，首发于个人博客<a href="https://rdququ.top/">https://rdququ.top/</a></p>]]></content:encoded>
      
      
      <category domain="http://rdququ.top/categories/%E6%95%99%E7%A8%8B%E5%90%91/">教程向</category>
      
      <category domain="http://rdququ.top/categories/%E6%95%99%E7%A8%8B%E5%90%91/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</category>
      
      <category domain="http://rdququ.top/categories/%E6%95%99%E7%A8%8B%E5%90%91/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/">Unity</category>
      
      <category domain="http://rdququ.top/categories/%E6%95%99%E7%A8%8B%E5%90%91/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/%E9%9B%86%E6%8D%A2%E5%BC%8F%E5%8D%A1%E7%89%8C%E6%B8%B8%E6%88%8F/">集换式卡牌游戏</category>
      
      
      <category domain="http://rdququ.top/tags/Unity/">Unity</category>
      
      <category domain="http://rdququ.top/tags/%E5%8D%A1%E7%89%8C%E6%B8%B8%E6%88%8F/">卡牌游戏</category>
      
      <category domain="http://rdququ.top/tags/%E6%95%99%E7%A8%8B/">教程</category>
      
      
      <comments>http://rdququ.top/2023/08/12/Unity%E9%9B%86%E6%8D%A2%E5%BC%8F%E5%8D%A1%E7%89%8C%E6%B8%B8%E6%88%8F-%E5%88%B6%E4%BD%9C%E7%AC%AC%E4%B8%80%E5%BC%A0%E5%8D%A1%E7%89%8C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JasonChatroom学习笔记</title>
      <link>http://rdququ.top/2023/08/11/JasonChatroom%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <guid>http://rdququ.top/2023/08/11/JasonChatroom%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Fri, 11 Aug 2023 15:06:05 GMT</pubDate>
      
      <description>&lt;p&gt;今天跟着博主 科技7C100 做一个简单的 chatroom.&lt;br&gt;在 Unity 前端页面，设置了 Scroll View 来显示聊天内容，一个 InputField 来输入信息，还有两个按钮用于链接和发送。&lt;br&gt;在设计脚本之前，我们需要了解网络编程的基础知识&lt;br&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>今天跟着博主 科技7C100 做一个简单的 chatroom.<br>在 Unity 前端页面，设置了 Scroll View 来显示聊天内容，一个 InputField 来输入信息，还有两个按钮用于链接和发送。<br>在设计脚本之前，我们需要了解网络编程的基础知识<br> <span id="more"></span></p><hr><p>以下内容摘自 <a href="http://www.cnblogs.com/skynet/">http://www.cnblogs.com/skynet/</a></p><h2 id="网络中进程之间如何通信"><a href="#网络中进程之间如何通信" class="headerlink" title="网络中进程之间如何通信"></a>网络中进程之间如何通信</h2><p>网络通信首要解决的问题是如何唯一标识一个进程，否则通信无从谈起！在本地可以通过进程 PID 来唯一标识一个进程，但是在网络中这是行不通的。其实 TCP&#x2F;IP 协议族已经帮我们解决了这个问题，网络层的 “ip 地址” 可以唯一标识网络中的主机，而传输层的“协议+端口”可以唯一标识主机中的应用程序（进程）。这样利用三元组（ ip 地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。</p><p>使用 TCP&#x2F;IP 协议的应用程序通常采用应用编程接口：UNIX BSD的套接字（socket）和 UNIX System V 的 TLI（已经被淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用程序都是采用 socket，而现在又是网络时代，网络中进程通信是无处不在，这就是我为什么说“一切皆 socket ”。</p><h2 id="什么是Socket"><a href="#什么是Socket" class="headerlink" title="什么是Socket"></a>什么是Socket</h2><p>socket起源于Unix，而Unix&#x2F;Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写 write&#x2F;read –&gt; 关闭 close”模式来操作。我的理解就是 Socket 就是该模式的一个实现，socket 即是一种特殊的文件，一些socket函数就是对其进行的操作（读&#x2F;写 IO、打开、关闭）</p><hr><h2 id="前端设计"><a href="#前端设计" class="headerlink" title="前端设计"></a>前端设计</h2><p>在Connect()方法中，我们这样设计  </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Connect</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">       socket = <span class="keyword">new</span> Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);</span><br><span class="line">       <span class="comment">//使用指定的地址族、套接字类型和协议初始化 Socket 类的新实例。</span></span><br><span class="line">       <span class="comment">//AddressFamily指定 Socket 类的实例可以使用的寻址方案;InterNetwork 是 IPV4 的地址</span></span><br><span class="line">       <span class="comment">//SocketType指定 Socket 类的实例表示的套接字类型；Stream支持可靠、双向、基于连接的字节流，而不重复数据，也不保留边界。 此类型的 Socket 与单个对方主机通信，并且在通信开始之前需要建立远程主机连接。 Stream 使用传输控制协议 (ProtocolType.Tcp) 和 AddressFamily。InterNetwork 地址族。</span></span><br><span class="line">       <span class="comment">//ProtocolType是指定 Socket 类支持的协议。</span></span><br><span class="line"></span><br><span class="line">       socket.Connect(<span class="keyword">new</span> IPEndPoint(IPAddress.Parse(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">10010</span>));</span><br><span class="line">       <span class="comment">//socket.Connect()与远程主机建立连接。</span></span><br><span class="line">       <span class="comment">//Connect(IPAddress, Int32)与远程主机建立连接。 主机由 IP 地址和端口号指定。</span></span><br><span class="line">       <span class="comment">//IPEndPoint提供 Internet 协议 (IP) 地址。这里是远程主机的 IP 地址。</span></span><br><span class="line">       <span class="comment">//10010是 port 远程主机的端口号。</span></span><br><span class="line"></span><br><span class="line">       socket.BeginReceive(buffer, <span class="number">0</span>, buffer.Length,<span class="number">0</span>, _ =&gt;&#123;&#125;, socket);</span><br><span class="line">       <span class="comment">//BeginReceive(Byte[], Int32, Int32, SocketFlags, AsyncCallback, Object)开始从连接的 Socket 中异步接收数据。</span></span><br><span class="line">       <span class="comment">// buffer</span></span><br><span class="line">       <span class="comment">// Byte[]</span></span><br><span class="line">       <span class="comment">// Byte 类型的数组，它是存储接收到的数据的位置。</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// offset</span></span><br><span class="line">       <span class="comment">// Int32</span></span><br><span class="line">       <span class="comment">// buffer 参数中存储所接收数据的位置，该位置从零开始计数。</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// size</span></span><br><span class="line">       <span class="comment">// Int32</span></span><br><span class="line">       <span class="comment">// 要接收的字节数。</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// socketFlags</span></span><br><span class="line">       <span class="comment">// SocketFlags</span></span><br><span class="line">       <span class="comment">// SocketFlags 值的按位组合。</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// callback</span></span><br><span class="line">       <span class="comment">// AsyncCallback</span></span><br><span class="line">       <span class="comment">// 一个 AsyncCallback 委托，它引用操作完成时要调用的方法。</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// state</span></span><br><span class="line">       <span class="comment">// Object</span></span><br><span class="line">       <span class="comment">// 一个用户定义的对象，其中包含接收操作的相关信息。 当操作完成时，此对象会被传递给 EndReceive(IAsyncResult) 委托。</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Recevie()是（同步阻塞方式）, 注意使用同步方法时，需要使用线程来开始方法，不然服务器不发送任何信息的话，Unity界面会卡死<br>这里使用使用BeginReceive（异步）</p><p>我们继续看Send的内部实现  </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Send</span>(<span class="params"><span class="built_in">string</span> data</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">       socket.Send(System.Text.Encoding.UTF8.GetBytes(data));</span><br><span class="line">       <span class="comment">//Socket.Send 方法将数据发送到连接的 Socket。</span></span><br><span class="line">       <span class="comment">//buffer </span></span><br><span class="line">       <span class="comment">//Byte[]</span></span><br><span class="line">       <span class="comment">//类型 Byte 的数组，其中包含要发送的数据。</span></span><br><span class="line">       <span class="comment">//Encoding表示字符编码</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里写一下回调方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReceiveCallback</span>(<span class="params">IAsyncResult ar</span>)<span class="comment">//接收数据回调</span></span></span><br><span class="line">   &#123;</span><br><span class="line">       Socket socket = (Socket)ar.AsyncState;<span class="comment">//获取当前的socket</span></span><br><span class="line">       <span class="built_in">int</span> length = socket.EndReceive(ar);<span class="comment">//获取接收到的数据长度</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">//错误示范：UIManager.Instance.connectText.text += System.Text.Encoding.UTF8.GetString(buffer, 0, length);//显示接收到的数据</span></span><br><span class="line">       <span class="comment">//原因：UIManager.Instance.connectText.text是在主线程中调用的，而socket.BeginReceive不会在Unity主线程中执行</span></span><br><span class="line">       <span class="comment">//下面是正确示范</span></span><br><span class="line">       GameManager.Instance.messageQueue.Enqueue(() =&gt;<span class="comment">//将接收到的数据放入消息队列中</span></span><br><span class="line">       &#123;</span><br><span class="line">           UIManager.Instance.connectText.text += System.Text.Encoding.UTF8.GetString(buffer, <span class="number">0</span>, length);<span class="comment">//显示接收到的数据</span></span><br><span class="line">       &#125;);</span><br><span class="line">       socket.BeginReceive(buffer, <span class="number">0</span>, buffer.Length, <span class="number">0</span>, ReceiveCallback, socket);<span class="comment">//再次接收数据</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>重要的知识点来了!<br>Unity里的UI组件或者是其他仅仅存活于Unity生命周期中的组件，只在Unity主线程内执行<br>由此引出了消息队列的妙用，请看GameManager.cs  </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Queue&lt;Action&gt; messageQueue = <span class="keyword">new</span> Queue&lt;Action&gt;();<span class="comment">//消息队列</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(messageQueue.Count&gt;<span class="number">0</span>)<span class="comment">//如果消息队列中有消息</span></span><br><span class="line">       &#123;</span><br><span class="line">           messageQueue<span class="comment">//消息队列</span></span><br><span class="line">           .Dequeue()<span class="comment">//从队列中取出消息</span></span><br><span class="line">           .Invoke();<span class="comment">//执行队列中的消息</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>到这里，我们的前端设计就基本完成了，来看看后端设计吧</p><h2 id="后端设计"><a href="#后端设计" class="headerlink" title="后端设计"></a>后端设计</h2><p>后端设计就是服务器端的设计，这里我们使用C#的Socket类来实现  </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Net.Sockets;</span><br><span class="line"><span class="keyword">using</span> System.Net;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChattingServer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Socket socket;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        socket = <span class="keyword">new</span> Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);</span><br><span class="line">        socket.Bind(<span class="keyword">new</span> IPEndPoint(IPAddress.Any, <span class="number">10010</span>));<span class="comment">//IPAddress.Any代表本机上的所有IP地址；socket.Bind(EndPoint) 方法使 Socket 与一个本地终结点相关联。</span></span><br><span class="line">        socket.Listen(<span class="number">0</span>);<span class="comment">//监听任意多个客户端</span></span><br><span class="line">        socket.BeginAccept(AcceptCallback, socket);</span><br><span class="line">        System.Console.WriteLine(<span class="string">&quot;Server is running...&quot;</span>);</span><br><span class="line">        System.Console.ReadLine();<span class="comment">//阻塞主线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有我们需要用到的回调函数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AcceptCallback</span>(<span class="params">System.IAsyncResult ar</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       Socket socket = ar.AsyncState <span class="keyword">as</span> Socket;<span class="comment">//获取传入的socket</span></span><br><span class="line">       Socket client = socket.EndAccept(ar);<span class="comment">//获取连接的客户端socket</span></span><br><span class="line">       System.Console.WriteLine(<span class="string">&quot;Client connected&quot;</span>);</span><br><span class="line">       ClientInfo clientInfo = <span class="keyword">new</span> ClientInfo(client);<span class="comment">//创建客户端信息</span></span><br><span class="line">       clientList.Add(clientInfo);<span class="comment">//添加到客户端列表</span></span><br><span class="line">       client.BeginReceive(clientInfo.readBuff, <span class="number">0</span>, <span class="number">1024</span>, <span class="number">0</span>, ReceiveCallback, clientInfo);<span class="comment">//开始接收数据</span></span><br><span class="line">       socket.BeginAccept(AcceptCallback, socket);<span class="comment">//再次监听</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReceiveCallback</span>(<span class="params">System.IAsyncResult ar</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       ClientInfo info = ar.AsyncState <span class="keyword">as</span> ClientInfo;<span class="comment">//获取传入的客户端信息</span></span><br><span class="line">       <span class="built_in">int</span> count = info.socket.EndReceive(ar);<span class="comment">//获取接收到的数据长度</span></span><br><span class="line">       <span class="keyword">foreach</span> (ClientInfo c <span class="keyword">in</span> clientList)<span class="comment">//遍历客户端列表</span></span><br><span class="line">       &#123;</span><br><span class="line">           c.socket.Send(info.readBuff,<span class="number">0</span>,count,<span class="number">0</span>);<span class="comment">//转发给所有客户端</span></span><br><span class="line">       &#125;</span><br><span class="line">       info.socket.BeginReceive(info.readBuff, <span class="number">0</span>, <span class="number">1024</span>, <span class="number">0</span>, ReceiveCallback, info);<span class="comment">//再次接收数据</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里建立了一个 ClientInfo 类用于管理数据和客户端 socket. 非常方便</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ClientInfo</span><span class="comment">//客户端信息</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">public</span> Socket socket;<span class="comment">//客户端socket</span></span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">byte</span>[] readBuff = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">1024</span>];<span class="comment">//接收缓冲区</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">ClientInfo</span>(<span class="params">Socket socket</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">this</span>.socket = socket;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>当然，聊天室不是一个人的网络备忘录，必然会出现多个客户端链接的情况，所以有必要new 一个 List 存储客户端信息。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;ClientInfo&gt; clientList = <span class="keyword">new</span> List&lt;ClientInfo&gt;();<span class="comment">//客户端列表</span></span><br></pre></td></tr></table></figure><hr><p>到这里，Jason网络聊天室的基本功能就实现了。</p><hr><p>本文作于2023-08-12，首发于个人博客<a href="https://rdququ.top/">https://rdququ.top/</a></p>]]></content:encoded>
      
      
      <category domain="http://rdququ.top/categories/%E8%AE%B0%E5%BD%95%E5%90%91/">记录向</category>
      
      <category domain="http://rdququ.top/categories/%E8%AE%B0%E5%BD%95%E5%90%91/Unity/">Unity</category>
      
      <category domain="http://rdququ.top/categories/%E8%AE%B0%E5%BD%95%E5%90%91/Unity/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</category>
      
      
      <category domain="http://rdququ.top/tags/Unity/">Unity</category>
      
      <category domain="http://rdququ.top/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/">服务端</category>
      
      <category domain="http://rdququ.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</category>
      
      <category domain="http://rdququ.top/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</category>
      
      <category domain="http://rdququ.top/tags/%E8%81%8A%E5%A4%A9%E5%AE%A4/">聊天室</category>
      
      
      <comments>http://rdququ.top/2023/08/11/JasonChatroom%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>导入Qframework框架</title>
      <link>http://rdququ.top/2023/08/11/%E5%AF%BC%E5%85%A5Qframework%E6%A1%86%E6%9E%B6/</link>
      <guid>http://rdququ.top/2023/08/11/%E5%AF%BC%E5%85%A5Qframework%E6%A1%86%E6%9E%B6/</guid>
      <pubDate>Fri, 11 Aug 2023 04:16:08 GMT</pubDate>
      
      <description>&lt;p&gt;QFramework是凉鞋大大开发的一款开箱即用的 Unity 开发框架，其内置了 Res Kit、UI Kit、Audio 以及常用的工具库&lt;br&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>QFramework是凉鞋大大开发的一款开箱即用的 Unity 开发框架，其内置了 Res Kit、UI Kit、Audio 以及常用的工具库<br> <span id="more"></span><br>Qframework 官方地址如下 <a href="https://qframework.cn/qf">https://qframework.cn/qf</a><br>Qframework 官方教程如下 <a href="https://www.gamepixedu.com/my/course/50">https://www.gamepixedu.com/my/course/50</a>  </p><h2 id="Unity如何导入Qframework"><a href="#Unity如何导入Qframework" class="headerlink" title="Unity如何导入Qframework"></a>Unity如何导入Qframework</h2><p>主体包地址： <a href="https://qframework.cn/qf/package/detail/17e600f8-c6fa-4fdf-a77e-843e28627e2f">https://qframework.cn/qf/package/detail/17e600f8-c6fa-4fdf-a77e-843e28627e2f</a><br>下载获取Unitypackage,导入项目中即可<br>这个包里面是由三部分组成的 QFramework.cs,Toolkits 和教程示例文件<br>如果只关心 QFramework 的架构实现，那么不需要导入 Toolkits 内的内容<br>在Unity中按下 CTRL+E 可以快捷唤出 QFramework 设置 </p><hr><p>首发于2023-08-11 </p><p>地址 ：<a href="https://rdququ.top/">https://rdququ.top/</a></p>]]></content:encoded>
      
      
      <category domain="http://rdququ.top/categories/%E8%B5%84%E6%96%99%E5%90%91/">资料向</category>
      
      <category domain="http://rdququ.top/categories/%E8%B5%84%E6%96%99%E5%90%91/Unity/">Unity</category>
      
      <category domain="http://rdququ.top/categories/%E8%B5%84%E6%96%99%E5%90%91/Unity/%E6%A1%86%E6%9E%B6/">框架</category>
      
      <category domain="http://rdququ.top/categories/%E8%B5%84%E6%96%99%E5%90%91/Unity/%E6%A1%86%E6%9E%B6/QFramework/">QFramework</category>
      
      
      <category domain="http://rdququ.top/tags/Unity/">Unity</category>
      
      <category domain="http://rdququ.top/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">环境配置</category>
      
      <category domain="http://rdququ.top/tags/QFramework/">QFramework</category>
      
      
      <comments>http://rdququ.top/2023/08/11/%E5%AF%BC%E5%85%A5Qframework%E6%A1%86%E6%9E%B6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>服了你了‘hexo-asset-image’</title>
      <link>http://rdququ.top/2023/08/07/%E6%9C%8D%E4%BA%86%E4%BD%A0%E4%BA%86%E2%80%98hexo-asset-image%E2%80%99/</link>
      <guid>http://rdququ.top/2023/08/07/%E6%9C%8D%E4%BA%86%E4%BD%A0%E4%BA%86%E2%80%98hexo-asset-image%E2%80%99/</guid>
      <pubDate>Mon, 07 Aug 2023 09:24:05 GMT</pubDate>
      
      <description>&lt;p&gt;今天写了下“Unity环境配置和外部工具食用指南”给新人，结果插入图片（引用本地文件）的时候出问题了，博客上怎么也显示不出来。博主就去查，发现是hexo-asset-image这个插件的bug。这个链接是解决方案&lt;a href=&quot;https://blog.csdn.net/xjm850552586/article/details/84101345&quot;&gt;https://blog.csdn.net/xjm850552586/article/details/84101345&lt;/a&gt;&lt;br&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>今天写了下“Unity环境配置和外部工具食用指南”给新人，结果插入图片（引用本地文件）的时候出问题了，博客上怎么也显示不出来。博主就去查，发现是hexo-asset-image这个插件的bug。这个链接是解决方案<a href="https://blog.csdn.net/xjm850552586/article/details/84101345">https://blog.csdn.net/xjm850552586/article/details/84101345</a><br> <span id="more"></span><br>其实正常读取文件应该这么写： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img example.jpg This is an example image %&#125;</span><br></pre></td></tr></table></figure><p>但是博主觉得麻烦，就打算抛弃hexo-asset-image了，转而投向hexo-renderer-marked的怀抱，直接下载他</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-marked</span><br></pre></td></tr></table></figure><p>站点配置文件也改一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br><span class="line">marked:</span><br><span class="line">  prependRoot: true</span><br><span class="line">  postAsset: true</span><br></pre></td></tr></table></figure><p>大功告成，图片正常显示了。<br>值得注意的是，markdown里链接本地图片是这么写的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](folder/image.jpg)</span><br></pre></td></tr></table></figure><p>但是由于hexo会把我们的图片和html文件放在一个文件夹，所以“folder&#x2F;”还是删掉吧，但是这样在md编辑器里我们就预览不了图片了，真是有得必有失啊。（至少vscode是这样的）博主还是找找vscode有没有相关插件吧。  </p><p><img src="/2023/08/07/%E6%9C%8D%E4%BA%86%E4%BD%A0%E4%BA%86%E2%80%98hexo-asset-image%E2%80%99/%E7%A4%BA%E4%BE%8B%E5%9B%BE.png" alt="示例图">  </p><hr><p>本文作于2023-08-07，首发于个人博客<a href="https://rdququ.top/">https://rdququ.top/</a></p>]]></content:encoded>
      
      
      <category domain="http://rdququ.top/categories/%E7%AD%94%E7%96%91%E5%90%91/">答疑向</category>
      
      <category domain="http://rdququ.top/categories/%E7%AD%94%E7%96%91%E5%90%91/Hexo/">Hexo</category>
      
      
      <category domain="http://rdququ.top/tags/vscode/">vscode</category>
      
      <category domain="http://rdququ.top/tags/%E5%9D%91/">坑</category>
      
      <category domain="http://rdququ.top/tags/Blog/">Blog</category>
      
      <category domain="http://rdququ.top/tags/markdown/">markdown</category>
      
      <category domain="http://rdququ.top/tags/hexo/">hexo</category>
      
      
      <comments>http://rdququ.top/2023/08/07/%E6%9C%8D%E4%BA%86%E4%BD%A0%E4%BA%86%E2%80%98hexo-asset-image%E2%80%99/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Unity环境配置和外部工具食用指南</title>
      <link>http://rdququ.top/2023/08/07/Unity%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%A4%96%E9%83%A8%E5%B7%A5%E5%85%B7%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/</link>
      <guid>http://rdququ.top/2023/08/07/Unity%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%A4%96%E9%83%A8%E5%B7%A5%E5%85%B7%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/</guid>
      <pubDate>Mon, 07 Aug 2023 06:07:15 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;怎么下载Unity&quot;&gt;&lt;a href=&quot;#怎么下载Unity&quot; class=&quot;headerlink&quot; title=&quot;怎么下载Unity&quot;&gt;&lt;/a&gt;怎么下载Unity&lt;/h2&gt;&lt;p&gt;Unity中国官网: &lt;a href=&quot;https://unity.cn/&quot;&gt;https://unity.cn/&lt;/a&gt;  &lt;/p&gt;
&lt;h3 id=&quot;注册Unity-ID&quot;&gt;&lt;a href=&quot;#注册Unity-ID&quot; class=&quot;headerlink&quot; title=&quot;注册Unity ID&quot;&gt;&lt;/a&gt;注册Unity ID&lt;/h3&gt;&lt;p&gt;无论是选择用邮箱还是用手机号码，Unity都会要求你接受手机验证码，这时候部分号码可能会接收不到验证码，如果连续三次出现这种情况，不要犹豫，换个号码就行，不需要使用接码平台。后续的登录使用邮箱就可以了。&lt;br&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="怎么下载Unity"><a href="#怎么下载Unity" class="headerlink" title="怎么下载Unity"></a>怎么下载Unity</h2><p>Unity中国官网: <a href="https://unity.cn/">https://unity.cn/</a>  </p><h3 id="注册Unity-ID"><a href="#注册Unity-ID" class="headerlink" title="注册Unity ID"></a>注册Unity ID</h3><p>无论是选择用邮箱还是用手机号码，Unity都会要求你接受手机验证码，这时候部分号码可能会接收不到验证码，如果连续三次出现这种情况，不要犹豫，换个号码就行，不需要使用接码平台。后续的登录使用邮箱就可以了。<br> <span id="more"></span></p><h3 id="下载Unity-Hub"><a href="#下载Unity-Hub" class="headerlink" title="下载Unity Hub"></a>下载Unity Hub</h3><p>点右上角的下载Unity,再点击页面中的绿色按钮“下载Unity Hub”，选择对应的版本即可。</p><h3 id="下载Unity"><a href="#下载Unity" class="headerlink" title="下载Unity"></a>下载Unity</h3><p>打开Hub,如果没有登录先登录。点击你的头像，再点击里面的管理许可证，拿到免费的个人版许可证。<br><img src="/2023/08/07/Unity%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%A4%96%E9%83%A8%E5%B7%A5%E5%85%B7%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/%E8%AE%B8%E5%8F%AF%E8%AF%81.png" alt="许可证" title="许可证"><br>中文设置：<br><img src="/2023/08/07/Unity%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%A4%96%E9%83%A8%E5%B7%A5%E5%85%B7%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/Hub%E4%B8%AD%E6%96%87.png" alt="Hub中文" title="Hub中文"><br>在此之后点击左侧边栏的安装，选择2022.3.4f1c1安装即可，也可以根据个人喜好选择其他版本，过高或者过低的版本可能会有各种不适配的问题。(其实可以多装几个版本，如果你的磁盘空间够大的话)<br>安装的页面，除了最下面的简体中文语言包可以勾选，其他都没必要勾，以后要用可以再额外安装。<br><img src="/2023/08/07/Unity%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%A4%96%E9%83%A8%E5%B7%A5%E5%85%B7%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/%E5%AE%89%E8%A3%85unity.png" alt="安装unity" title="安装unity"></p><h2 id="怎么配置Unity"><a href="#怎么配置Unity" class="headerlink" title="怎么配置Unity"></a>怎么配置Unity</h2><h3 id="VS2022"><a href="#VS2022" class="headerlink" title="VS2022"></a>VS2022</h3><p>学校里的课程教的使用vs2010啊，当然我们实际开发时不可能使用vs2010的。出于方便易上手考虑，先讲一下vs2022的Unity配置，非常简单，下载的时候勾选一下这个就行<br><img src="/2023/08/07/Unity%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%A4%96%E9%83%A8%E5%B7%A5%E5%85%B7%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/vs2022.png" alt="vs2022" title="vs2022"></p><h3 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h3><p>vscode是很强大的文本编辑器，这里我们也介绍一下。主要下载这些插件：<br><img src="/2023/08/07/Unity%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%A4%96%E9%83%A8%E5%B7%A5%E5%85%B7%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/vscode%E6%8F%92%E4%BB%B61.png" alt="vscode插件" title="vscode插件"><br><img src="/2023/08/07/Unity%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%A4%96%E9%83%A8%E5%B7%A5%E5%85%B7%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/vscode%E6%8F%92%E4%BB%B62.png" alt="vscode插件" title="vscode插件"><br><img src="/2023/08/07/Unity%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%A4%96%E9%83%A8%E5%B7%A5%E5%85%B7%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/vscode%E6%8F%92%E4%BB%B63.png" alt="vscode插件" title="vscode插件"><br>中文插件搜Chinese就行，不过多介绍</p><h3 id="配置Unity"><a href="#配置Unity" class="headerlink" title="配置Unity"></a>配置Unity</h3><p>先随便打开一个项目<br>看左上角的Edit，他下面有个Preferences，打开之后看图<br><img src="/2023/08/07/Unity%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%A4%96%E9%83%A8%E5%B7%A5%E5%85%B7%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/Unity%E8%AF%AD%E8%A8%80.png" alt="Unity语言" title="Unity语言"><br><img src="/2023/08/07/Unity%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%A4%96%E9%83%A8%E5%B7%A5%E5%85%B7%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/%E5%A4%96%E9%83%A8%E5%B7%A5%E5%85%B7.png" alt="外部工具" title="外部工具"><br>external script editor（就是第一个）选择你喜欢的就行（vs2022&#x2F;vscode） </p><hr><p>Unity环境配置好了，开启你的游戏开发之旅吧</p><hr><p>本文作于2023-08-07，首发于个人博客<a href="https://rdququ.top/">https://rdququ.top/</a></p>]]></content:encoded>
      
      
      <category domain="http://rdququ.top/categories/%E8%B5%84%E6%96%99%E5%90%91/">资料向</category>
      
      <category domain="http://rdququ.top/categories/%E8%B5%84%E6%96%99%E5%90%91/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">环境配置</category>
      
      <category domain="http://rdququ.top/categories/%E8%B5%84%E6%96%99%E5%90%91/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Unity/">Unity</category>
      
      
      <category domain="http://rdququ.top/tags/Unity/">Unity</category>
      
      <category domain="http://rdququ.top/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">环境配置</category>
      
      <category domain="http://rdququ.top/tags/vscode/">vscode</category>
      
      <category domain="http://rdququ.top/tags/vs2022/">vs2022</category>
      
      
      <comments>http://rdququ.top/2023/08/07/Unity%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%A4%96%E9%83%A8%E5%B7%A5%E5%85%B7%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>【制趣交流团】蛐蛐-南邮华夜《大战略游戏的叙事玩法设计》</title>
      <link>http://rdququ.top/2023/08/06/%E3%80%90%E5%88%B6%E8%B6%A3%E4%BA%A4%E6%B5%81%E5%9B%A2%E3%80%91%E8%9B%90%E8%9B%90-%E5%8D%97%E9%82%AE%E5%8D%8E%E5%A4%9C%E3%80%8A%E5%A4%A7%E6%88%98%E7%95%A5%E6%B8%B8%E6%88%8F%E7%9A%84%E5%8F%99%E4%BA%8B%E7%8E%A9%E6%B3%95%E8%AE%BE%E8%AE%A1%E3%80%8B/</link>
      <guid>http://rdququ.top/2023/08/06/%E3%80%90%E5%88%B6%E8%B6%A3%E4%BA%A4%E6%B5%81%E5%9B%A2%E3%80%91%E8%9B%90%E8%9B%90-%E5%8D%97%E9%82%AE%E5%8D%8E%E5%A4%9C%E3%80%8A%E5%A4%A7%E6%88%98%E7%95%A5%E6%B8%B8%E6%88%8F%E7%9A%84%E5%8F%99%E4%BA%8B%E7%8E%A9%E6%B3%95%E8%AE%BE%E8%AE%A1%E3%80%8B/</guid>
      <pubDate>Sun, 06 Aug 2023 15:35:30 GMT</pubDate>
      
      <description>&lt;p&gt;这个是博主2023年8月2号晚上8点到9点在吉比特制趣联盟的第22期制趣交流团上做的分享。主要分享了大战略游戏中独特的叙事玩法设计和一些叙事理论。&lt;br&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>这个是博主2023年8月2号晚上8点到9点在吉比特制趣联盟的第22期制趣交流团上做的分享。主要分享了大战略游戏中独特的叙事玩法设计和一些叙事理论。<br> <span id="more"></span></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://www.researchgate.net/publication/371984492_Managing_the_Plot_Structure_of_Character-based_Interactive_Narratives_in_Games">https://www.researchgate.net/publication/371984492_Managing_the_Plot_Structure_of_Character-based_Interactive_Narratives_in_Games</a></li><li><a href="https://www.researchgate.net/publication/228361928_Authoring_emergent_narrative-based_games">https://www.researchgate.net/publication/228361928_Authoring_emergent_narrative-based_games</a></li><li><a href="https://www.researchgate.net/publication/254006015_A_narrative_theory_of_games">https://www.researchgate.net/publication/254006015_A_narrative_theory_of_games</a><br>都是researchgate上面开源的文章，需要的可以自行下载。<br>下面放一下视频外链吧</li></ul><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=231893217&bvid=BV198411d7wd&cid=1224927176&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><hr><p>本文作于2023-08-06，首发于个人博客<a href="https://rdququ.top/">https://rdququ.top/</a></p>]]></content:encoded>
      
      
      <category domain="http://rdququ.top/categories/%E5%88%86%E4%BA%AB%E5%90%91/">分享向</category>
      
      <category domain="http://rdququ.top/categories/%E5%88%86%E4%BA%AB%E5%90%91/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E7%90%86%E8%AE%BA/">游戏设计理论</category>
      
      
      <category domain="http://rdququ.top/tags/%E5%A4%A7%E6%88%98%E7%95%A5/">大战略</category>
      
      <category domain="http://rdququ.top/tags/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/">游戏设计</category>
      
      <category domain="http://rdququ.top/tags/%E5%8F%99%E4%BA%8B/">叙事</category>
      
      
      <comments>http://rdququ.top/2023/08/06/%E3%80%90%E5%88%B6%E8%B6%A3%E4%BA%A4%E6%B5%81%E5%9B%A2%E3%80%91%E8%9B%90%E8%9B%90-%E5%8D%97%E9%82%AE%E5%8D%8E%E5%A4%9C%E3%80%8A%E5%A4%A7%E6%88%98%E7%95%A5%E6%B8%B8%E6%88%8F%E7%9A%84%E5%8F%99%E4%BA%8B%E7%8E%A9%E6%B3%95%E8%AE%BE%E8%AE%A1%E3%80%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>可恶的百度推送bug</title>
      <link>http://rdququ.top/2023/08/06/%E5%8F%AF%E6%81%B6%E7%9A%84%E7%99%BE%E5%BA%A6%E6%8E%A8%E9%80%81bug/</link>
      <guid>http://rdququ.top/2023/08/06/%E5%8F%AF%E6%81%B6%E7%9A%84%E7%99%BE%E5%BA%A6%E6%8E%A8%E9%80%81bug/</guid>
      <pubDate>Sun, 06 Aug 2023 11:20:33 GMT</pubDate>
      
      <description>&lt;p&gt;事情是这样的，这天博主吃着盐水鸭改着代码，突然发现&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo s&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;报错了，以下是报错信息&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>事情是这样的，这天博主吃着盐水鸭改着代码，突然发现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>报错了，以下是报错信息</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FATAL Something&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html</span><br><span class="line">TypeError: Cannot read properties of undefined (reading &#x27;count&#x27;)</span><br><span class="line">    at module.exports (H:\Blog\node_modules\hexo-baidu-url-submit\lib\generator.js:4:41)</span><br><span class="line">    at Hexo.tryCatcher (H:\Blog\node_modules\bluebird\js\release\util.js:16:23)</span><br><span class="line">    at Hexo.&lt;anonymous&gt; (H:\Blog\node_modules\bluebird\js\release\method.js:15:34)</span><br><span class="line">    at H:\Blog\node_modules\hexo\lib\hexo\index.js:407:22</span><br><span class="line">    at tryCatcher (H:\Blog\node_modules\bluebird\js\release\util.js:16:23)</span><br><span class="line">    at MappingPromiseArray._promiseFulfilled (H:\Blog\node_modules\bluebird\js\release\map.js:68:38)</span><br><span class="line">    at PromiseArray._iterate (H:\Blog\node_modules\bluebird\js\release\promise_array.js:115:31)</span><br><span class="line">    at MappingPromiseArray.init (H:\Blog\node_modules\bluebird\js\release\promise_array.js:79:10)</span><br><span class="line">    at MappingPromiseArray._asyncInit (H:\Blog\node_modules\bluebird\js\release\map.js:37:10)</span><br><span class="line">    at _drainQueueStep (H:\Blog\node_modules\bluebird\js\release\async.js:97:12)</span><br><span class="line">    at _drainQueue (H:\Blog\node_modules\bluebird\js\release\async.js:86:9)</span><br><span class="line">    at Async._drainQueues (H:\Blog\node_modules\bluebird\js\release\async.js:102:5)</span><br><span class="line">    at Async.drainQueues [as _onImmediate] (H:\Blog\node_modules\bluebird\js\release\async.js:15:14)</span><br><span class="line">    at process.processImmediate (node:internal/timers:476:21)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一眼就看到里面显眼的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(H:\Blog\node_modules\hexo-baidu-url-submit\lib\generator.js:4:41)</span><br></pre></td></tr></table></figure><p>于是上网去搜，果然发现了和博主一样的倒霉蛋<br>链接在这里<a href="https://github.com/hexojs/hexo/issues/2402">https://github.com/hexojs/hexo/issues/2402</a><br>看来确实是百度推送的插件有问题<br>于是博主一通操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm remove hexo-baidu-url-submit</span><br></pre></td></tr></table></figure><p>问题解决。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g --debug</span><br></pre></td></tr></table></figure><p>你定位问题的好帮手</p><hr><p>首发于2023-08-06 </p><p>地址 ：<a href="https://rdququ.top/">https://rdququ.top/</a></p>]]></content:encoded>
      
      
      <category domain="http://rdququ.top/categories/%E7%AD%94%E7%96%91%E5%90%91/">答疑向</category>
      
      <category domain="http://rdququ.top/categories/%E7%AD%94%E7%96%91%E5%90%91/Hexo/">Hexo</category>
      
      
      <category domain="http://rdququ.top/tags/%E5%9D%91/">坑</category>
      
      <category domain="http://rdququ.top/tags/Blog/">Blog</category>
      
      <category domain="http://rdququ.top/tags/%E7%99%BE%E5%BA%A6%E6%8E%A8%E9%80%81/">百度推送</category>
      
      
      <comments>http://rdququ.top/2023/08/06/%E5%8F%AF%E6%81%B6%E7%9A%84%E7%99%BE%E5%BA%A6%E6%8E%A8%E9%80%81bug/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>unity协程（corounines）学习理解兼迭代器学习，异步多任务处理</title>
      <link>http://rdququ.top/2023/08/05/unity%E5%8D%8F%E7%A8%8B%EF%BC%88corounines%EF%BC%89%E5%AD%A6%E4%B9%A0%E7%90%86%E8%A7%A3%E5%85%BC%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%8C%E5%BC%82%E6%AD%A5%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86/</link>
      <guid>http://rdququ.top/2023/08/05/unity%E5%8D%8F%E7%A8%8B%EF%BC%88corounines%EF%BC%89%E5%AD%A6%E4%B9%A0%E7%90%86%E8%A7%A3%E5%85%BC%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%8C%E5%BC%82%E6%AD%A5%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86/</guid>
      <pubDate>Sat, 05 Aug 2023 15:04:15 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;一-协程学习的前置知识&quot;&gt;&lt;a href=&quot;#一-协程学习的前置知识&quot; class=&quot;headerlink&quot; title=&quot;一.协程学习的前置知识&quot;&gt;&lt;/a&gt;一.协程学习的前置知识&lt;/h2&gt;&lt;h3 id=&quot;迭代器&quot;&gt;&lt;a href=&quot;#迭代器&quot; class=&quot;headerlink&quot; title=&quot;迭代器&quot;&gt;&lt;/a&gt;迭代器&lt;/h3&gt;&lt;p&gt;迭代器是一种用于简化循环结构的语法糖，它可以让我们通过一种更加简洁、优雅的方式来遍历一个集合或者执行一些需要多次迭代的操作。&lt;/p&gt;
&lt;p&gt;在Unity中，迭代器的基本语法是使用yield return语句。yield return语句用于暂停迭代器的执行，并返回一个值或对象。&lt;/p&gt;
&lt;p&gt;下面是一个使用迭代器的例子：&lt;br&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="一-协程学习的前置知识"><a href="#一-协程学习的前置知识" class="headerlink" title="一.协程学习的前置知识"></a>一.协程学习的前置知识</h2><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器是一种用于简化循环结构的语法糖，它可以让我们通过一种更加简洁、优雅的方式来遍历一个集合或者执行一些需要多次迭代的操作。</p><p>在Unity中，迭代器的基本语法是使用yield return语句。yield return语句用于暂停迭代器的执行，并返回一个值或对象。</p><p>下面是一个使用迭代器的例子：<br> <span id="more"></span></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">MyIterator</span>()</span> &#123;</span><br><span class="line">    Debug.Log(<span class="string">&quot;Start&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1.0f</span></span>)</span>;</span><br><span class="line">    Debug.Log(<span class="string">&quot;1 second later&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">2.0f</span></span>)</span>;</span><br><span class="line">    Debug.Log(<span class="string">&quot;2 seconds later&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-协程的入口"><a href="#二-协程的入口" class="headerlink" title="二.协程的入口"></a>二.协程的入口</h2><p>协程必须以IEnumerator开始，并且方法中必须包含关键字yield return，下面我们给出一个协程和普通程序的对比：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">PrintDebug</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//暂时挂起程序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintDebug</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时我们想要调用我们的协程就需要用到以下的代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StartCoroutine(PrintNum());</span><br></pre></td></tr></table></figure><h3 id="关键字yield-return"><a href="#关键字yield-return" class="headerlink" title="关键字yield return"></a>关键字yield return</h3><p>yield return的作用是将我们的程序暂时挂起，满足部分条件之后再执行</p><p>下面是一些例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//下一帧以后执行后续代码</span></span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//这里可以不是零，甚至可以是任意数字，效果同上</span></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="title">StartCoroutine</span>(<span class="params">MyCoroutine(<span class="number">1</span></span>))</span>;<span class="comment">//等待协程MyCoroutine(1)完成</span></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1</span></span>)</span>; <span class="comment">// 暂停协程1秒钟,受到DeletaTime影响</span></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSecondsRealtime</span>(<span class="params"><span class="number">1</span></span>)</span>;<span class="comment">//不受到DeletaTime影响</span></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForFixedUpdate</span>()</span>; <span class="comment">// 等待下一个FixedUpdate消息</span></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForEndOfFrame</span>()</span>; <span class="comment">// 等待下一个渲染帧的结束</span></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitUntil</span>(<span class="params">(</span>)</span> =&gt; oneSecond&gt;<span class="number">1</span>);<span class="comment">//等到某判断条件为真时</span></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitWhile</span>(<span class="params">(</span>)</span> =&gt; oneSecond&gt;<span class="number">1</span>);<span class="comment">//等到某判断条件为假时</span></span><br><span class="line"></span><br><span class="line">AsyncOperation <span class="keyword">async</span> = SceneManager.LoadSceneAsync(<span class="string">&quot;SceneName&quot;</span>);<span class="comment">//暂停协程，异步场景加载</span></span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">async</span>; <span class="comment">// 等待场景加载完成</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">break</span>;<span class="comment">//直接终止，类似于return操作</span></span><br></pre></td></tr></table></figure><p>不仅如此，你甚至能使用自定义的yield return，请看代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyYieldInstruction</span> : <span class="title">CustomYieldInstruction</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> isFinished = <span class="literal">false</span>; <span class="comment">// 是否完成的标志位</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> keepWaiting &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> !isFinished; <span class="comment">// 当未完成时，协程继续等待</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Finish</span>()</span> &#123;</span><br><span class="line">        isFinished = <span class="literal">true</span>; <span class="comment">// 设置完成标志位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>众所周知，自定义yield return类型需要满足以下两个条件：</p><ul><li><p>继承自Unity的CustomYieldInstruction类。</p></li><li><p>实现keepWaiting属性，该属性的返回值控制协程是否继续等待。</p></li></ul><p>在上面的示例中，MyYieldInstruction类继承自CustomYieldInstruction类，并实现了keepWaiting属性和Finish方法。在MyYieldInstruction类中，我们使用isFinished变量表示自定义的操作是否完成。在keepWaiting属性中，当isFinished为false时，协程将继续等待；当isFinished为true时，协程将不再等待，继续执行后面的代码。</p><p>以下的代码会告诉你该如何使用前面我们自定义的yield return</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">MyCoroutine</span>()</span> &#123;</span><br><span class="line">    Debug.Log(<span class="string">&quot;Start&quot;</span>);</span><br><span class="line">    MyYieldInstruction myYield = <span class="keyword">new</span> MyYieldInstruction();</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> myYield;</span><br><span class="line">    Debug.Log(<span class="string">&quot;Finish&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">MyCoroutine coroutine = StartCoroutine(MyCoroutine());</span><br><span class="line">coroutine.Stop(); <span class="comment">// 可以通过Stop方法提前终止协程</span></span><br></pre></td></tr></table></figure><p>值得注意的是，在使用自定义yield return类型时，需要特别注意协程的终止条件，以避免出现不可预期的结果。</p><h3 id="StartCoroutine语句"><a href="#StartCoroutine语句" class="headerlink" title="StartCoroutine语句"></a>StartCoroutine语句</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StartCoroutine(方法)；</span><br><span class="line">StartCoroutine(方法名)；</span><br></pre></td></tr></table></figure><p>StartCoroutine的返回值类型是IEnumerator</p><p>注意：StartCoroutine语句只能在MonoBehaviour派生类的方法中使用，因为协程依赖于Unity的消息循环机制。</p><h2 id="三-协程的结束"><a href="#三-协程的结束" class="headerlink" title="三.协程的结束"></a>三.协程的结束</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StopCoroutine(方法)；</span><br><span class="line">StopAllCoroutine()；</span><br></pre></td></tr></table></figure><h2 id="四-迭代器与协程的区别"><a href="#四-迭代器与协程的区别" class="headerlink" title="四.迭代器与协程的区别"></a>四.迭代器与协程的区别</h2><p>迭代器（Iterator）和协程（Coroutine）在Unity中都用于异步操作，但它们在实现和使用上有一些区别。</p><ol><li>实现方式不同</li></ol><p>迭代器是一种基于枚举器（Enumerator）实现的语法，通过yield return语句实现协程的暂停和恢复。在编写迭代器时，需要实现IEnumerator和IEnumerable接口，并实现MoveNext、Reset和Current等方法。</p><p>协程是一种基于IEnumerator实现的语法，通过StartCoroutine和yield return语句实现协程的启动和暂停。在编写协程时，需要定义一个返回值为IEnumerator类型的方法，并使用yield return语句来暂停协程的执行。</p><ol><li>使用方式不同</li></ol><p>迭代器通常用于实现可枚举类型的遍历，可以通过foreach语句进行遍历操作。在协程中，迭代器通常用于实现异步操作，例如延迟执行、动画效果等。</p><p>协程通常用于实现异步操作，可以通过StartCoroutine语句启动协程，并使用yield return语句实现协程的暂停和恢复。协程可以通过yield return语句实现延迟执行、分步执行、等待操作完成等功能。</p><ol><li>执行顺序不同</li></ol><p>迭代器的执行顺序是在同一线程中顺序执行，即在迭代器中的每个yield return语句执行完毕后，才会执行下一个yield return语句或方法的其他部分。</p><p>协程的执行顺序是异步的，即在协程执行过程中可以执行其他代码。协程的执行可以被暂停和恢复，可以实现延迟执行、动画效果、等待操作完成等功能。</p><hr><p>本文作于2023-03-19，首发于CSDN<br><a href="https://blog.csdn.net/jubunihuan/article/details/129652810">https://blog.csdn.net/jubunihuan/article/details/129652810</a></p>]]></content:encoded>
      
      
      <category domain="http://rdququ.top/categories/%E8%B5%84%E6%96%99%E5%90%91/">资料向</category>
      
      <category domain="http://rdququ.top/categories/%E8%B5%84%E6%96%99%E5%90%91/%E8%AF%AD%E6%B3%95/">语法</category>
      
      <category domain="http://rdququ.top/categories/%E8%B5%84%E6%96%99%E5%90%91/%E8%AF%AD%E6%B3%95/C/">C#</category>
      
      
      <category domain="http://rdququ.top/tags/Unity/">Unity</category>
      
      <category domain="http://rdququ.top/tags/C/">C#</category>
      
      <category domain="http://rdququ.top/tags/%E8%AF%AD%E6%B3%95/">语法</category>
      
      
      <comments>http://rdququ.top/2023/08/05/unity%E5%8D%8F%E7%A8%8B%EF%BC%88corounines%EF%BC%89%E5%AD%A6%E4%B9%A0%E7%90%86%E8%A7%A3%E5%85%BC%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%8C%E5%BC%82%E6%AD%A5%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
