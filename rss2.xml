<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>蛐蛐的软件开发世界</title>
    <link>https://rdququ.top/</link>
    
    <atom:link href="https://rdququ.top/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>正在学习unity中</description>
    <pubDate>Thu, 02 Nov 2023 05:13:05 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title></title>
      <link>https://rdququ.top/posts/0/</link>
      <guid>https://rdququ.top/posts/0/</guid>
      <pubDate>Tue, 31 Oct 2023 09:18:02 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;授课计划&quot;&gt;&lt;a href=&quot;#授课计划&quot; class=&quot;headerlink&quot; title=&quot;授课计划&quot;&gt;&lt;/a&gt;授课计划&lt;/h1&gt;&lt;h2 id=&quot;GamePlay-Programming-Expriences&quot;&gt;&lt;a href=&quot;#GamePlay-Progr</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="授课计划"><a href="#授课计划" class="headerlink" title="授课计划"></a>授课计划</h1><h2 id="GamePlay-Programming-Expriences"><a href="#GamePlay-Programming-Expriences" class="headerlink" title="GamePlay Programming Expriences"></a>GamePlay Programming Expriences</h2><h3 id="0-导论"><a href="#0-导论" class="headerlink" title="0.导论"></a>0.导论</h3><h3 id="1-游戏循环-时间和计算"><a href="#1-游戏循环-时间和计算" class="headerlink" title="1.游戏循环,时间和计算"></a>1.游戏循环,时间和计算</h3><h3 id="2-2D图形——渲染、精灵和简单应用"><a href="#2-2D图形——渲染、精灵和简单应用" class="headerlink" title="2.2D图形——渲染、精灵和简单应用"></a>2.2D图形——渲染、精灵和简单应用</h3><h3 id="3-游戏中的线性代数"><a href="#3-游戏中的线性代数" class="headerlink" title="3.游戏中的线性代数"></a>3.游戏中的线性代数</h3><h3 id="4-3D图形初探——坐标与世界变换"><a href="#4-3D图形初探——坐标与世界变换" class="headerlink" title="4.3D图形初探——坐标与世界变换"></a>4.3D图形初探——坐标与世界变换</h3><h3 id="5-3D图形再探——光照与着色"><a href="#5-3D图形再探——光照与着色" class="headerlink" title="5.3D图形再探——光照与着色"></a>5.3D图形再探——光照与着色</h3><h3 id="6-游戏输入——输入设备和输入系统"><a href="#6-游戏输入——输入设备和输入系统" class="headerlink" title="6.游戏输入——输入设备和输入系统"></a>6.游戏输入——输入设备和输入系统</h3><h3 id="7-声音和数字信号处理"><a href="#7-声音和数字信号处理" class="headerlink" title="7.声音和数字信号处理"></a>7.声音和数字信号处理</h3><h3 id="8-碰撞检测算法和数值积分法求解物理运动"><a href="#8-碰撞检测算法和数值积分法求解物理运动" class="headerlink" title="8.碰撞检测算法和数值积分法求解物理运动"></a>8.碰撞检测算法和数值积分法求解物理运动</h3><h3 id="9-有趣摄像机的实现与算法"><a href="#9-有趣摄像机的实现与算法" class="headerlink" title="9.有趣摄像机的实现与算法"></a>9.有趣摄像机的实现与算法</h3><h3 id="10-浅谈游戏AI-不止A-FSM和状态树"><a href="#10-浅谈游戏AI-不止A-FSM和状态树" class="headerlink" title="10.浅谈游戏AI, 不止A*, FSM和状态树"></a>10.浅谈游戏AI, 不止A*, FSM和状态树</h3><h3 id="11-UI设计，中间件和本地化"><a href="#11-UI设计，中间件和本地化" class="headerlink" title="11.UI设计，中间件和本地化"></a>11.UI设计，中间件和本地化</h3><h3 id="12-脚本语言和数据格式"><a href="#12-脚本语言和数据格式" class="headerlink" title="12.脚本语言和数据格式"></a>12.脚本语言和数据格式</h3><h3 id="13-网络游戏概述"><a href="#13-网络游戏概述" class="headerlink" title="13.网络游戏概述"></a>13.网络游戏概述</h3><h2 id="Unity-进阶"><a href="#Unity-进阶" class="headerlink" title="Unity 进阶"></a>Unity 进阶</h2><h2 id="UE5-3D-ARPG"><a href="#UE5-3D-ARPG" class="headerlink" title="UE5 3D ARPG"></a>UE5 3D ARPG</h2><h3 id="1-UE5界面介绍与基础建模"><a href="#1-UE5界面介绍与基础建模" class="headerlink" title="1.UE5界面介绍与基础建模"></a>1.UE5界面介绍与基础建模</h3><h3 id="2-熟悉蓝图脚本与EnhancedInputSystem"><a href="#2-熟悉蓝图脚本与EnhancedInputSystem" class="headerlink" title="2.熟悉蓝图脚本与EnhancedInputSystem"></a>2.熟悉蓝图脚本与EnhancedInputSystem</h3><h3 id="3-U-踏上UE的GamePlay架构"><a href="#3-U-踏上UE的GamePlay架构" class="headerlink" title="3.U++?踏上UE的GamePlay架构"></a>3.U++?踏上UE的GamePlay架构</h3><h3 id="4-骨骼绑定？射线追踪？教你使用AActor"><a href="#4-骨骼绑定？射线追踪？教你使用AActor" class="headerlink" title="4.骨骼绑定？射线追踪？教你使用AActor"></a>4.骨骼绑定？射线追踪？教你使用AActor</h3><h3 id="5-背包、血条——快来探索UE的前端UWdiget"><a href="#5-背包、血条——快来探索UE的前端UWdiget" class="headerlink" title="5.背包、血条——快来探索UE的前端UWdiget"></a>5.背包、血条——快来探索UE的前端UWdiget</h3><h3 id="6-狠狠存进来——UE数据表"><a href="#6-狠狠存进来——UE数据表" class="headerlink" title="6.狠狠存进来——UE数据表"></a>6.狠狠存进来——UE数据表</h3><h3 id="6-既然把Player讲的差不多了——那就开始我们的AI-Controller与行为树吧！"><a href="#6-既然把Player讲的差不多了——那就开始我们的AI-Controller与行为树吧！" class="headerlink" title="6.既然把Player讲的差不多了——那就开始我们的AI Controller与行为树吧！"></a>6.既然把Player讲的差不多了——那就开始我们的AI Controller与行为树吧！</h3><h3 id="7-特效环节——Niagara系统"><a href="#7-特效环节——Niagara系统" class="headerlink" title="7.特效环节——Niagara系统"></a>7.特效环节——Niagara系统</h3><h3 id="8-终于结束了GamePlay，那……开始我们的GAS与Game-Feature战斗吧"><a href="#8-终于结束了GamePlay，那……开始我们的GAS与Game-Feature战斗吧" class="headerlink" title="8.终于结束了GamePlay，那……开始我们的GAS与Game Feature战斗吧"></a>8.终于结束了GamePlay，那……开始我们的GAS与Game Feature战斗吧</h3>]]></content:encoded>
      
      
      
      
      <comments>https://rdququ.top/posts/0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>GamePlayProgrammingExpriences_系列课_第一讲_游戏循环，时间和对象</title>
      <link>https://rdququ.top/posts/6d5dfc5f/</link>
      <guid>https://rdququ.top/posts/6d5dfc5f/</guid>
      <pubDate>Mon, 30 Oct 2023 13:49:03 GMT</pubDate>
      
        
        
      <description>&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h2 id=&quot;课前的话&quot;&gt;&lt;a href=&quot;#课前的话&quot; class=&quot;headerlink&quot; title=&quot;课前的话&quot;&gt;&lt;/a&gt;课前的话&lt;/h2&gt;&lt;p&gt;今天我们要开的这节课，我把它取名叫做 GamePlay Programmin</description>
        
      
      
      
      <content:encoded><![CDATA[<span id="more"></span><h2 id="课前的话"><a href="#课前的话" class="headerlink" title="课前的话"></a>课前的话</h2><p>今天我们要开的这节课，我把它取名叫做 GamePlay Programming Expriences. 今天是第一节. 这是校科协游戏组的大课, 在这套课上, 我不打算专注讲 Unity, UE 或者 CoCos 等游戏引擎的使用, 也不打算精细的教学 C# 或者 C++ 的具体语法, 为什么呢? 原因就在上一句, 游戏引擎太多, 我们授课没有办法面面俱到, 程序语言已经有各个组负责了, 他们会对语法进行详细的教学. 在这套课上, 我想和大家成系统的聊聊游戏编程的算法和游戏设计的心得, 正如其名, 这套课是为了 GamePlay 程序员准备的, 我们不会花很大篇幅描述物理模拟, 图形渲染, 而是作为将他作为 GamePlay 程序员(或许还有技术策划,真是新颖的方向)的入门基础课, 游戏运行的基本逻辑, 良好的输入交互, 游戏功能的实现算法(AI…A*啦,FSM啦,感知,群居..),游戏数学, 2D和3D渲染基础, 物理模拟计算, 摄像机控制, UI设计, 脚本语言(Lua, javaScript…),最后还会聊点网络编程.</p><p>看起来饼画得很大,乐, 看起来有点多, 我们计划讲两个学期,这是作为游戏组的大课, 我们在课上会尽量使用 Lua 风格的伪代码, 或许还会夹杂了C# 和 Java, 当然考虑到学校课程的设计, 同时也会给出一份 C/C++ 的代码以供参考. 本课程如果遇到示例, 将会使用 Unity 游戏引擎展示,若有不便之处,还请见谅.</p><p>在每节课结束之后,我们会布置一些小题目作为课后的作业,当然这是选做的.届时我会在QQ群里面发布作业,大家感兴趣去做一下就好. 在布置一周后我会在B站上公布解析视频.</p><p>如果大家对 Unity 和 C# 特别感兴趣, 或者觉得我大课上讲的太简单,可以来找我听小课,小课基本上会提前一天在群里通知时间和地点,大家可以关注华夜工作室和校科协游戏组群. 我还有一个小课授课前瞻群,群里会投票决定下节小课讲什么, 程序设计能力很强的同学可以向我提交作品入群.</p><p>当然,大课和小课都会把录播放出来,所以上面的要求也都不是强制的.</p><p>好,我们开始今天的课程吧</p><h2 id="游戏循环-loop"><a href="#游戏循环-loop" class="headerlink" title="游戏循环 loop"></a>游戏循环 loop</h2><p>游戏循环是游戏的核心控制流程，它是游戏的主线程，它负责游戏的运行，它是游戏的心脏。</p><p>在这个循环里，程序不断地去处理玩家的输入，更新游戏世界，然后生成输出（生成到屏幕上的我们会叫作渲染，游戏手柄等的震动也算是生成输出）。</p><p>这是非常经典而传统的游戏循环，你可以在任何游戏中见到他。想想看你再玩马里奥的时候，当你当你按下方向键，马里奥就会向你想要的方向移动，当你踩到龟壳上面的时候，龟壳会飞出去，或许你的手柄也会震动一下。</p><p>每次迭代游戏循环称为一帧，大部分游戏的帧率在 30-60 帧之间，也就是说，游戏循环每秒会执行 30-60 次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while game is running:</span><br><span class="line">    process inputs</span><br><span class="line">    update game world</span><br><span class="line">    generate outputs</span><br><span class="line">loop</span><br></pre></td></tr></table></figure><p>当然，循环的每一步都没有他们本身看上去的那么简单，每一步都有许多细节不容忽视。</p><h3 id="process-inputs"><a href="#process-inputs" class="headerlink" title="process inputs"></a>process inputs</h3><p>就像 process inputs，他意味着在循环的开始，你需要检查各种各样的设备的输入，键鼠，手柄，麦克风甚至还有触摸屏，陀螺仪，摄像机，GPS。有些是由你游戏中某些功能或者特色决定的，而另一些则来自玩家方便或者高品质游玩的需求。</p><p>他们的输入的类型也是多样的。如果你接触过 Unity 的 InputSystem, 那么或许你会更好的理解这一点。我们键盘的WASD，又或者手柄的遥感，他们都是Vector2的输入，而键盘，手柄，鼠标乃至触摸屏的点击，都是 Trigger 或者 Boolean 类型的， 这取决与他们是 Down, Up, Click 又或者是长按，双击。再打个比方，陀螺仪的输入可能是 Vector3的。输入系统的设备和输入的类型都是纷繁多样的，任何外部的输入都要在这一阶段被转换成计算机可以理解的数据结构。</p><h3 id="update-game-world"><a href="#update-game-world" class="headerlink" title="update game world"></a>update game world</h3><p>结束玩家的输入后，就来到或许是大家最关心的一部分了，更新游戏世界。是的，谁不想通过代码构筑一个属于自己的美妙世界呢，或许每个程序员写下第一行 Hello World 的时候，都会自豪于即将成为一个小小代码世界的上帝。然而，一个游戏世界的构筑显然不会像 Hello World 那么简单， 他需要构筑世界的<code>实例</code>和<code>法则</code>，这听来有点像炼金术师又或者魔法师，当然，也许游戏程序员在某种程度上就是在没有魔力的世界里施法的人。好了让我们回到构筑世界的具体方法上来，我们通常把构筑世界的实例称为<code>Game Object</code>, 他们是构成游戏世界的最基本的物质元素和法则的载体。这个我们后半节课会详细讲解。而<code>法则</code>也不难理解，那是世界运转的基本原理，或许他的本质是计算，而在宏观上的体现可以是物理模拟，游戏玩法，甚至是游戏的时间与空间。想象一下吧，在一款玩家可以肆意控制重力的世界，那里的法则就是<code>重力会不定期改变</code>，又或者是<code>雨世界</code>中精彩的生态系统，<code>Minecraft</code>里的方块世界和史蒂夫能锤爆钻石的手，游戏的<code>法则</code>是塑造你的游戏世界的基准线，而你将用代码去实现他。</p><p>上面讲了很多，但是简单概括一下就是一句</p><blockquote><p>更新所有已激活且需要更新的对象</p></blockquote><p>其中，<code>更新</code>就是<code>法则</code>, <code>对象</code>就是<code>实例</code></p><h3 id="generate-outputs"><a href="#generate-outputs" class="headerlink" title="generate outputs"></a>generate outputs</h3><p>在很多情境中，生成输出是最耗费计算量的一步。想想看最常见的输出是什么？…<br>2D和3D的渲染，最简单的3D渲染在计算三角形顶点和颜色的时候计算量都是一个天文数字。（这里讲的比较模糊，这节课有空就细讲，没空就下一节课讲）。当然，输出也不知图形渲染，音视频，手柄的力回馈，甚至是网络数据的发送，都是输出的一部分。</p><p>讲了这么多，或许我可以给出一个小游戏（Flappy Bird）的例子，让大家更好的理解游戏循环。请看伪代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">while Bird is alive:</span><br><span class="line">    // process inputs</span><br><span class="line">    InputDeviceData j = grap raw data from input device</span><br><span class="line"></span><br><span class="line">    // update game world</span><br><span class="line">    update bird.position based on j</span><br><span class="line">    foreach pipe in pipes</span><br><span class="line">        if pipe is out of screen</span><br><span class="line">            move pipe to the right out of screen</span><br><span class="line">        else</span><br><span class="line">            if bird collides with pipe</span><br><span class="line">                kill bird</span><br><span class="line">            else</span><br><span class="line">                update pipe.position</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    loop</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // generate outputs</span><br><span class="line">    draw graphics</span><br><span class="line">    play aduio</span><br><span class="line">loop</span><br></pre></td></tr></table></figure><h3 id="多线程下的游戏循环"><a href="#多线程下的游戏循环" class="headerlink" title="多线程下的游戏循环"></a>多线程下的游戏循环</h3><p>不同于早期游戏开发紧巴巴的硬件条件，2005年左右，多核处理器(CPU)开始普及，多线程编程也开始流行起来。在多线程的环境下，游戏循环的结构会有所不同，我们会把游戏循环分为两个线程，一个是游戏逻辑线程，另一个是渲染线程。游戏逻辑线程负责处理玩家的输入，更新游戏世界，而渲染线程则负责把游戏世界渲染到屏幕上。这样做的好处是，游戏逻辑线程和渲染线程可以并行执行，这样就可以充分利用多核处理器的优势，提高游戏的性能。</p><p>请你设想，在早期的单核处理器上，程序需要先花费 20ms 在逻辑运算上用来更新游戏世界，而后还需要花费 30ms 在渲染上，这样一来，游戏的帧率就只有 20FPS了。20帧的游戏，相信对于绝大多数玩家来说都是不可接受的，所以当年的游戏程序员绞劲脑汁开发出了大量极为优秀的优化算法————这点我们暂且不展开说，来提升游戏的帧率。然而，如果我们再新建一条渲染线程用来处理图形计算，那么游戏逻辑和图形渲染就可以并行执行，最终的帧率是 33.3FPS,卓越的提升！</p><p>没错，现代的游戏引擎也是这么做的，无论是 Unity 还是 UE</p><p>下面简单展示一下 Unity 的多线程渲染的基本逻辑</p><p>CPU 计算出什么需要渲染 -&gt; 渲染命令从主线程传给渲染线程 -&gt; 渲染线程生成渲染指令并提交给图形驱动 -&gt; GPU 执行渲染指令 -&gt; 显示器显示</p><p>很有意思，对吧？</p><p>当然，这里似乎有些问题</p><p>同学们，我们设想一下，主线程消耗20ms，渲染线程消耗30ms，如果主线程不等待渲染线程，那么到每3帧主线程就会领先渲染线程整整1帧，而为了追赶上主线程，渲染线程就要每4帧丢弃一帧（只保留1，2，3帧）的渲染，这会导致什么呢？</p><p>相信很多同学已经能报出答案了，画面卡顿。  </p><p>那么看起来我们只能让主线程等待渲染线程了吗？</p><p>难道没有其他更好的办法了吗？</p><p>有。我们有一个经典的解决办法：让渲染进程的执行比主线程慢一帧。<br>但是这种方法是有代价的，玩家的输入需要更久才能体现到画面上，这对 FPS，格斗，竞速等品类的即时竞技游戏来说是致命的。</p><p>当然，现在的多线程渲染方案也提出了不少新法门。比如 Unity 的<code>帧同步队列</code>技术。<br>我不太清楚同学们对数据结构有多少了解，所以我这里只做简单的解释。<br>前面我们多线程渲染的基本逻辑可以简化成这个样子：</p><p>主线程 -&gt; 渲染线程 -&gt; GPU -&gt; 显示器</p><p>主线程不断向GPU下达渲染指令，显然可以类比为生产者，而GPU不断读取着渲染指令，自然是链中的消费者。渲染指令会抵达一个循环队列(RingBuffer).</p><p>简单介绍一下循环队列的工作方式：<br>循环队列的实现，实际上是靠 Head 指针和 Tail 指针的原子操作来实现的。也就是说，生产者线程写入循环队列时，会原子地去后移 Tail 指针；消费者线程读取循环队列时，会原子地去后移 Head 指针。当 Tail 指针再次超过 Head 指针，则说明队列满了，则需要阻塞生产者线程。</p><ul><li>RingBuffer 在写满的时候会阻塞主线程，等待渲染线程。</li><li>RingBuffer 在读空的时候会阻塞渲染线程，等待主线程。</li></ul><p>多线程渲染的基础知识太多了，我这里只是简单的介绍一下，如果同学们对这方面感兴趣，可以自行搜索资料或者线下找我沟通。</p><h3 id="视窗消息泵-Windows-message-pump"><a href="#视窗消息泵-Windows-message-pump" class="headerlink" title="视窗消息泵 Windows message pump"></a>视窗消息泵 Windows message pump</h3><p>值得注意的是，在 Windows 平台中，本身逻辑的循环等，游戏还要处理来自 Windows 系统的指令。处理这段来自 Windows 指令的代码就被叫做 <code>message pump</code>。<code>message pump</code>从 Windows 消息队列中取出消息，然后分发给游戏程序的窗口。基本的逻辑是：</p><blockquote><p>先处理来自 Windows 的消息，然后在处理引擎（如果你的游戏并不依托某个引擎也是这样）的任务</p></blockquote><p>下面给出一段经典的消息泵的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Msg msg;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">PeekMessage</span>(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, PM_REMOVE))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.message == WM_QUIT)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">        <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do game stuff</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这带来了一个有趣的现象，当你移动（或者其他什么操作）你游戏的窗体的时候，游戏会卡住不动。比如 <code>Slay the Spire</code> 这款游戏是用 <code>Java</code> 语言，<code>libGDX</code> 框架开发的，不过在 <code>犹格索托斯的庭院</code> 上的实验没有起效，或许这说明了 Unity 并没有默认内置/启用这一段代码，需要开发者自行实现/开启。</p><p>对这点我还没有深入研究，希望大家搞明白后可以来和我分享。</p><h4 id="Windows-API-解释"><a href="#Windows-API-解释" class="headerlink" title="Windows API 解释"></a>Windows API 解释</h4><ul><li><code>PeekMessage</code>: 从消息队列中取出消息，但是不会阻塞</li><li>TranslateMessage: 将消息转换为字符消息</li><li>DispatchMessage: 将消息分发给窗口过程</li><li>PM_REMOVE: 从消息队列中移除消息</li><li>WM_QUIT: 指示终止应用程序</li></ul><h3 id="回调驱动框架-Callback-driven-framework"><a href="#回调驱动框架-Callback-driven-framework" class="headerlink" title="回调驱动框架 Callback-driven framework"></a>回调驱动框架 Callback-driven framework</h3><p>大多数游戏引擎的子系统或者第三方游戏中间套件都是以<code>library</code>的方式构成的。请注意，这里要和 Unity Project 文件夹中的 <code>Library</code> 文件夹区分开，前者是指一组可被程序员调用的函数和类，后者是指项目的缓存文件夹。</p><p>而另外一些游戏引擎或是中间套件，则是基于 <code>framework</code> 的。或许你可以把框架视为一套半完成的应用程序，你需要也仅能在框架的留白下自定义你的代码或者覆写代码预设的某些行为。但在控制流中，你的程序并不能取得主导地位，大部分流的控制权限被框架牢牢的攥在手中，你只能取得少量的控制。当然，对开源引擎如“Godot”，或者代码可访问的引擎如“Unreal Engine”来说，你当然可以通过自己修改引擎的框架来达成自己自定义程序流程的目的，不过一来这种方法相对危险且对程序员的水平要求很高，并且对“Unity”一类的引擎来说是做不到的。</p><p>简单的来说，<code>library</code> 是你调用他，而 <code>framework</code> 是他调用你。</p><p>具体的说，<code>library</code> 仅仅是提供了一些库函数供你调用，其灵活性强，侵入性低，不主导控制流，往往针对某个特殊的功能提供解决状态；而 <code>framework</code> 灵活性较差，侵入性强，主导控制流，能够为游戏开发提供一整套的解决方案。</p><p>在基于 <code>framework</code> 的游戏引擎中，主游戏循环已经为我们准备好了，他们的调度有一套严谨的顺序，只不过在我们编写回调方法 <code>callback function</code> 去覆写他们之前，他们什么也做不了。</p><p>下面给出简单的回调驱动的伪代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while (true)</span><br><span class="line">    foreach activeObject in activeObjects</span><br><span class="line">        activeObject.start()</span><br><span class="line">        activeObject.update()</span><br><span class="line">        activeObject.end()</span><br><span class="line">    loop</span><br><span class="line">loop</span><br></pre></td></tr></table></figure><p>虽然只是一段可以说是简陋的示例，但大家有没有觉得很眼熟？没错，这就是 Unity 的 <code>MonoBehaviour</code> 的生命周期。Unity 有着相当丰富的声明周期函数，他们的本质是事件函数(<code>event functions</code>), 或者说回调(<code>callback</code>)。这是一个非常经典的回调驱动的框架。</p><h2 id="时间和游戏"><a href="#时间和游戏" class="headerlink" title="时间和游戏"></a>时间和游戏</h2><p>现在大多数游戏都会有时间进程(progression of time)的概念。无论是 minecraft 中的日夜交替，还是 moba 游戏中对局时长，甚至是回合制游戏中的回合数，都依赖着时间进展的管理。这是从 gameplay 的角度来说的。在游戏实现的技术层面，或者无论是游戏循环还是渲染循环，也都离不开游戏时间的处理。</p><h3 id="真实时间"><a href="#真实时间" class="headerlink" title="真实时间"></a>真实时间</h3><p>真实事件顾名思义，就是真实世界流逝的时间，然而他的计算并不容易。显然我们不能直接调用C语言的标准库函数<code>time()</code>来获取真实时间，这个函数返回的是从1970年1月1日0时0分0秒到现在的秒数，这个数值是一个相当大的整数，而我们需要的是一个足够小的浮点数。毕竟，考虑到游戏中每帧仅耗时数十毫秒，这样的测量分辨率着实太粗糙了。</p><p>所以，我们该如何解决这个问题呢？（下面的 CPU 版本都以 Pentium 为例）</p><p>答案是使用 CPU 的高分辨率计时器来测量真实时间。这种计时器通常会实现为硬件寄存器，其它以64位无符号整型数的格式，记录了自CPU上电以来所经过的时钟周期数。Intel Pentium 以来所有 x86 处理器上都存在一个叫做 “Time Stamp Counter” 的 64 位寄存器。没错，他们就是上文所说的计时器和硬件寄存器。</p><p>在 3GHz 的 Pentium 上，其 Time Stamp Counter 每周期递增一次，也就是说每秒 30 亿次。分辨率是其每秒递增次数的倒数，即 $1/3GHz=3.33*10^{-10}s=0.333ns$。</p><p>在 Pentium 及其以上的 CPU 中，提供了一条机器指令RDTSC（Read Time Stamp Counter）来读取这个时间戳的数字，并将其保存在EDX:EAX寄存器对中。不过C++语言本身是不直接支持汇编指令的，所以我们需要使用内联汇编来调用这条指令。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">get_tsc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> a, d;</span><br><span class="line">    <span class="function">__asm__ <span class="title">volatile</span><span class="params">(<span class="string">&quot;rdtsc&quot;</span> : <span class="string">&quot;=a&quot;</span>(a), <span class="string">&quot;=d&quot;</span>(d))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> (d &lt;&lt; <span class="number">32</span>) | a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我们也可以用_emit伪指令直接嵌入该指令的机器码形式0X0F、0X31</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">unsigned</span> __int64 <span class="title">GetCycleCount</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">__asm _emit <span class="number">0x0F</span> </span><br><span class="line">__asm _emit <span class="number">0x31</span> </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>如果你使用 MSVC, 你也可以这么写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrin.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">get_tsc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __rdtsc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多核CPU或者“休眠”操作系统或乱序执行等带来的不精确的时间测量"><a href="#多核CPU或者“休眠”操作系统或乱序执行等带来的不精确的时间测量" class="headerlink" title="多核CPU或者“休眠”操作系统或乱序执行等带来的不精确的时间测量"></a>多核CPU或者“休眠”操作系统或乱序执行等带来的不精确的时间测量</h4><p>CPU 再也不是从前“单打独斗”的时代了，现在的 CPU 一般都是多核的，而且还有超线程技术，这就意味着，我们不能再简单的使用 Time Stamp Counter 来测量时间了。这超级好理解，假如你的CPU时四核的，他们开始工作的事件都不一样，你该听谁的？</p><p>不光如此，现在的操作系统都有节能模式，休眠模式，这些都会导致 CPU 的时钟频率发生变化，时钟频率变化，Time Stamp Counter 的递增速度也会变化，我们测量的结果自然也不准了。</p><p>再比如，现代的 CPU 为了提高性能，会对指令进行乱序执行，这也就意味着，我们测量的时间可能是乱序执行的时间，而不是我们想要的真实时间。</p><p>当然，后来的 CPU 都提供了一个新的指令，叫做 <code>RDTSCP</code>，这个指令会在读取时间戳的同时，读取一个标志位，这个标志位会在所有指令执行完毕后才会被置位，这样我们就可以保证测量的时间是正确的了。不过他的开销显然更大，耗时差不多是<code>RDTSC</code> 的两倍。</p><p>新版本的 CPU 也对上述的三个问题打了不同程度的补丁，这里也不详细展开了。</p><p>当然，在 Windows 平台上，也可以使用更加傻瓜式的方法来测量时间，比如调用 Windows API QueryPerformanceCounter 和 QueryPerformanceFrequency。不过为了跨平台和可拓展性，游戏引擎中是否要使用 QueryPerformanceCounter 和 QueryPerformanceFrequency 还有待商榷。</p><h3 id="游戏时间"><a href="#游戏时间" class="headerlink" title="游戏时间"></a>游戏时间</h3><p>在大多数情况下，游戏时间和真实事件时一致的，但这并不绝对，因为无论是从技术角度还是设计层面上考虑，游戏时间都是一个相对独立的概念。</p><p>如果我们提出一个时间流速的概念，也许会更便于大家理解。或者我们把它叫做时间缩放，这无所谓，只是个名字。</p><h4 id="时间缩放"><a href="#时间缩放" class="headerlink" title="时间缩放"></a>时间缩放</h4><p>好了，让我们来分类讨论。</p><p>当时间缩放为 1 的时候，游戏时间和真实时间是一致的，这是最常见的情况。在游戏 <code>60 Seconds</code> 中，游戏说好给你60s准备应对危机，他就的确只给了你60s，1s不多1s不少。</p><p>当时间缩放为 0 的时候，游戏时间就停止了，几乎所有游戏都会设置一个暂停功能。</p><p>当时间缩放大于 0 而小于 1 的时候，帅气的 <code>子弹时间</code>就出现了。除了玩家，几乎所有对象的时间都被减速了，又或者虽然玩家的时间同样被锁死了流速，但是他却凭借高超的技艺在危机前化险为夷或者大杀四方。在塞尔达传说系列游戏中，这种效果也被称为<code>林克时间</code>。</p><h3 id="增量时间与固定时间"><a href="#增量时间与固定时间" class="headerlink" title="增量时间与固定时间"></a>增量时间与固定时间</h3><p>前面我们说过，游戏的帧率是指以多快的时间向玩家展示一连串帧。帧率的单位是赫兹 Hz, 即每秒的执行次数，当然也可以用每秒帧数 FPS 来表示游戏的帧率。在传统上，电影的帧率是 24FPS，而游戏的帧率则是 30FPS 或者 60FPS。</p><h3 id="全局时间和局部时间"><a href="#全局时间和局部时间" class="headerlink" title="全局时间和局部时间"></a>全局时间和局部时间</h3><h2 id="游戏对象"><a href="#游戏对象" class="headerlink" title="游戏对象"></a>游戏对象</h2><h3 id="游戏对象的类型"><a href="#游戏对象的类型" class="headerlink" title="游戏对象的类型"></a>游戏对象的类型</h3><h3 id="游戏对象的生命周期"><a href="#游戏对象的生命周期" class="headerlink" title="游戏对象的生命周期"></a>游戏对象的生命周期</h3><h3 id="游戏“对象”一定是面向对象吗？"><a href="#游戏“对象”一定是面向对象吗？" class="headerlink" title="游戏“对象”一定是面向对象吗？"></a>游戏“对象”一定是面向对象吗？</h3><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>1.<a href="https://developer.unity.cn/projects/5ff9c6b0edbc2a60edd4807c">Unity 2020.2 优化了 Time.deltaTime，以实现更流畅的游戏体验</a><br>2.<a href="https://zhuanlan.zhihu.com/p/591218281">Unity多线程渲染概述</a><br>3.<a href="https://www.cnblogs.com/SunWentao/archive/2008/10/20/1315313.html">使用CPU时间戳进行高精度计时</a><br>4.<a href="http://taggedwiki.zubiaga.org/new_content/6fda7324cd6ec352ca95609d6ff5615a">Time Stamp Counter</a><br>5.<a href="http://www.wangkaixuan.tech/?p=901">细说RDTSC的坑</a></p>]]></content:encoded>
      
      
      <category domain="https://rdququ.top/categories/GamePlay-Programming-Expriences/">GamePlay Programming Expriences</category>
      
      
      <category domain="https://rdququ.top/tags/GamePlay-Programming-Expriences/">GamePlay Programming Expriences</category>
      
      
      <comments>https://rdququ.top/posts/6d5dfc5f/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>数据结构与算法_前缀、中缀、后缀表达式</title>
      <link>https://rdququ.top/posts/29455a3d/</link>
      <guid>https://rdququ.top/posts/29455a3d/</guid>
      <pubDate>Mon, 23 Oct 2023 10:30:13 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;中缀表达式&quot;&gt;&lt;a href=&quot;#中缀表达式&quot; class=&quot;headerlink&quot; title=&quot;中缀表达式&quot;&gt;&lt;/a&gt;中缀表达式&lt;/h2&gt;&lt;p&gt;中缀表达式就是我们通常所写的表达式，如：$1 + 2 &lt;em&gt; 3$，$1 + (2 + 3) &lt;/em&gt; 4 - 5$，$1 + 2 &lt;em&gt; (3 + 4 &lt;/em&gt; (5 + 6))$ 等等。&lt;/p&gt;
&lt;h2 id=&quot;后缀表达式及其求值方法&quot;&gt;&lt;a href=&quot;#后缀表达式及其求值方法&quot; class=&quot;headerlink&quot; title=&quot;后缀表达式及其求值方法&quot;&gt;&lt;/a&gt;后缀表达式及其求值方法&lt;/h2&gt;&lt;p&gt;后缀表达式又称为逆波兰表达式，它的特点是运算符在操作数的后面，如：$1 2 3 &lt;em&gt; +$，$1 2 3 + 4 &lt;/em&gt; + 5 -$，$1 2 3 4 5 6 + &lt;em&gt; + &lt;/em&gt; +$ 等等。&lt;/p&gt;
&lt;h3 id=&quot;后缀表达式的求值方法&quot;&gt;&lt;a href=&quot;#后缀表达式的求值方法&quot; class=&quot;headerlink&quot; title=&quot;后缀表达式的求值方法&quot;&gt;&lt;/a&gt;后缀表达式的求值方法&lt;/h3&gt;&lt;p&gt;后缀表达式的求值方法是：从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h2><p>中缀表达式就是我们通常所写的表达式，如：$1 + 2 <em> 3$，$1 + (2 + 3) </em> 4 - 5$，$1 + 2 <em> (3 + 4 </em> (5 + 6))$ 等等。</p><h2 id="后缀表达式及其求值方法"><a href="#后缀表达式及其求值方法" class="headerlink" title="后缀表达式及其求值方法"></a>后缀表达式及其求值方法</h2><p>后缀表达式又称为逆波兰表达式，它的特点是运算符在操作数的后面，如：$1 2 3 <em> +$，$1 2 3 + 4 </em> + 5 -$，$1 2 3 4 5 6 + <em> + </em> +$ 等等。</p><h3 id="后缀表达式的求值方法"><a href="#后缀表达式的求值方法" class="headerlink" title="后缀表达式的求值方法"></a>后缀表达式的求值方法</h3><p>后缀表达式的求值方法是：从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。</p><span id="more"></span><p>例如：$1 2 3 * +$ 的求值过程如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">读入字符</th><th style="text-align:center">当前栈</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">读入 1，进栈</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">1 2</td><td style="text-align:center">读入 2，进栈</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">1 2 3</td><td style="text-align:center">读入 3，进栈</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">1 6</td><td style="text-align:center">读入 <em>，出栈 3 和 2，计算 2 </em> 3 = 6，将 6 进栈</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">7</td><td style="text-align:center">读入 +，出栈 6 和 1，计算 1 + 6 = 7，将 7 进栈</td></tr></tbody></table></div><h3 id="C-实现后缀表达式的求值"><a href="#C-实现后缀表达式的求值" class="headerlink" title="C++ 实现后缀表达式的求值"></a>C++ 实现后缀表达式的求值</h3><p>用C++实现后缀表达式的求值。要求有简单的控制台UI，并且要对用户的危险行为进行检查和警告。控制台输出的语句要求是中英文对照，并且在用户进行错误操作的时候告知他进行了什么错误操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOperator</span><span class="params">(<span class="type">char</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">performOperation</span><span class="params">(<span class="type">char</span> op, <span class="type">double</span> operand1, <span class="type">double</span> operand2)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">evaluatePostfixExpression</span><span class="params">(<span class="type">const</span> string&amp; postfix, <span class="type">double</span>&amp; result)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;欢迎使用后缀表达式计算器！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入一个后缀表达式，使用空格分隔操作数和操作符，输入&#x27;q&#x27;退出：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        string input;</span><br><span class="line">        <span class="built_in">getline</span>(cin, input);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (input == <span class="string">&quot;q&quot;</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;感谢使用后缀表达式计算器，再见！&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查输入中的非法字符</span></span><br><span class="line">        <span class="type">bool</span> validInput = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : input) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isspace</span>(c) &amp;&amp; !<span class="built_in">isdigit</span>(c) &amp;&amp; !<span class="built_in">isOperator</span>(c)) &#123;</span><br><span class="line">                validInput = <span class="literal">false</span>;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;错误：输入包含非法字符 &#x27;&quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (validInput) &#123;</span><br><span class="line">            <span class="type">double</span> result;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">evaluatePostfixExpression</span>(input, result)) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;结果： &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;错误：无效的后缀表达式&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入另一个后缀表达式，或输入&#x27;q&#x27;退出：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOperator</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;*&#x27;</span> || c == <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">performOperation</span><span class="params">(<span class="type">char</span> op, <span class="type">double</span> operand1, <span class="type">double</span> operand2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> operand1 + operand2;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> operand1 - operand2;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> operand1 * operand2;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> (operand2 != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> operand1 / operand2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;错误：除数不能为零&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;错误：未知的操作符 &#x27;&quot;</span> &lt;&lt; op &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">evaluatePostfixExpression</span><span class="params">(<span class="type">const</span> string&amp; postfix, <span class="type">double</span>&amp; result)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">double</span>&gt; operandStack;</span><br><span class="line"></span><br><span class="line">    <span class="function">istringstream <span class="title">iss</span><span class="params">(postfix)</span></span>;</span><br><span class="line">    string token;</span><br><span class="line">    <span class="keyword">while</span> (iss &gt;&gt; token) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(token[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="type">double</span> operand = <span class="built_in">stod</span>(token);</span><br><span class="line">            operandStack.<span class="built_in">push</span>(operand);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isOperator</span>(token[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (operandStack.<span class="built_in">size</span>() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;错误：操作数不足&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">double</span> operand2 = operandStack.<span class="built_in">top</span>();</span><br><span class="line">            operandStack.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">double</span> operand1 = operandStack.<span class="built_in">top</span>();</span><br><span class="line">            operandStack.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">double</span> result = <span class="built_in">performOperation</span>(token[<span class="number">0</span>], operand1, operand2);</span><br><span class="line">            operandStack.<span class="built_in">push</span>(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;错误：无效的标记 &#x27;&quot;</span> &lt;&lt; token &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (operandStack.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">        result = operandStack.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;错误：操作数不足或操作符过多&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-实现后缀表达式的求值-1"><a href="#C-实现后缀表达式的求值-1" class="headerlink" title="C 实现后缀表达式的求值"></a>C 实现后缀表达式的求值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_STACK_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable : 4996)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈结构和操作</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> data[MAX_STACK_SIZE];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initialize</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Stack* <span class="built_in">stack</span>, <span class="type">double</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;top &lt; MAX_STACK_SIZE - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;data[++<span class="built_in">stack</span>-&gt;top] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;错误：栈已满\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">pop</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;错误：栈为空\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isOperator</span><span class="params">(<span class="type">char</span> c)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">performOperation</span><span class="params">(<span class="type">char</span> op, <span class="type">double</span> operand1, <span class="type">double</span> operand2)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">evaluatePostfixExpression</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* postfix, <span class="type">double</span>* result)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;欢迎使用后缀表达式计算器！\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个后缀表达式，使用空格分隔操作数和操作符，输入&#x27;q&#x27;退出：\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> input[<span class="number">100</span>];</span><br><span class="line">        fgets(input, <span class="keyword">sizeof</span>(input), <span class="built_in">stdin</span>);</span><br><span class="line">        input[<span class="built_in">strcspn</span>(input, <span class="string">&quot;\n&quot;</span>)] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 去掉换行符</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input, <span class="string">&quot;q&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;感谢使用后缀表达式计算器，再见！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查输入中的非法字符</span></span><br><span class="line">        <span class="type">int</span> validInput = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; input[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isspace</span>(input[i]) &amp;&amp; !<span class="built_in">isdigit</span>(input[i]) &amp;&amp; !isOperator(input[i])) &#123;</span><br><span class="line">                validInput = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;错误：输入包含非法字符 &#x27;%c&#x27;\n&quot;</span>, input[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (validInput) &#123;</span><br><span class="line">            <span class="type">double</span> result;</span><br><span class="line">            <span class="keyword">if</span> (evaluatePostfixExpression(input, &amp;result)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;结果： %g\n&quot;</span>, result);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;错误：无效的后缀表达式\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入另一个后缀表达式，或输入&#x27;q&#x27;退出：\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isOperator</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;*&#x27;</span> || c == <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">performOperation</span><span class="params">(<span class="type">char</span> op, <span class="type">double</span> operand1, <span class="type">double</span> operand2)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> operand1 + operand2;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> operand1 - operand2;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> operand1 * operand2;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> (operand2 != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> operand1 / operand2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;错误：除数不能为零\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;错误：未知的操作符 &#x27;%c&#x27;\n&quot;</span>, op);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">evaluatePostfixExpression</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* postfix, <span class="type">double</span>* result)</span> &#123;</span><br><span class="line">    Stack operandStack;</span><br><span class="line">    initialize(&amp;operandStack);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* token = strtok((<span class="type">char</span>*)postfix, <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (token != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(token[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="type">double</span> operand = atof(token);</span><br><span class="line">            push(&amp;operandStack, operand);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isOperator(token[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (operandStack.top &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;错误：操作数不足\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">double</span> operand2 = pop(&amp;operandStack);</span><br><span class="line">            <span class="type">double</span> operand1 = pop(&amp;operandStack);</span><br><span class="line">            <span class="type">double</span> result = performOperation(token[<span class="number">0</span>], operand1, operand2);</span><br><span class="line">            push(&amp;operandStack, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;错误：无效的标记 &#x27;%s&#x27;\n&quot;</span>, token);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        token = strtok(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (operandStack.top == <span class="number">0</span>) &#123;</span><br><span class="line">        *result = operandStack.data[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;错误：操作数不足或操作符过多\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后缀表达式的转换方法-中缀转后缀"><a href="#后缀表达式的转换方法-中缀转后缀" class="headerlink" title="后缀表达式的转换方法(中缀转后缀)"></a>后缀表达式的转换方法(中缀转后缀)</h3><p>将中缀表达式转换为后缀表达式的方法是：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，若是符号，则判断其与栈顶符号的优先级，是右括号或优先级不高于栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。</p><p>例如：$1 + (2 + 3) * 4 - 5$ 的转换过程如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">读入字符</th><th style="text-align:center">当前栈</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">读入 1，输出</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">+</td><td style="text-align:center">读入 +，进栈</td></tr><tr><td style="text-align:center">(</td><td style="text-align:center">+ (</td><td style="text-align:center">读入 (，进栈</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">+ ( 2</td><td style="text-align:center">读入 2，输出</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">+ ( +</td><td style="text-align:center">读入 +，进栈</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">+ ( + 3</td><td style="text-align:center">读入 3，输出</td></tr><tr><td style="text-align:center">)</td><td style="text-align:center">+</td><td style="text-align:center">读入 )，依次出栈 + 和 (，输出</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">*</td><td style="text-align:center">读入 *，进栈</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">* 4</td><td style="text-align:center">读入 4，输出</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">读入 -，进栈</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">- 5</td><td style="text-align:center">读入 5，输出</td></tr><tr><td style="text-align:center">空</td><td style="text-align:center">-</td><td style="text-align:center">依次出栈 - 和 *，输出</td></tr></tbody></table></div><p>转换后的后缀表达式为：$1 2 3 + 4 * + 5 -$。</p><h3 id="C-实现中缀表达式转后缀表达式"><a href="#C-实现中缀表达式转后缀表达式" class="headerlink" title="C++ 实现中缀表达式转后缀表达式"></a>C++ 实现中缀表达式转后缀表达式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getOperatorPrecedence</span><span class="params">(<span class="type">char</span> op)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOperator</span><span class="params">(<span class="type">char</span> c)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">infixToPostfix</span><span class="params">(<span class="type">const</span> string&amp; infix)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;欢迎使用中缀表达式转后缀表达式程序！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入一个中缀表达式，输入&#x27;q&#x27;退出：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        string infixExpression;</span><br><span class="line">        <span class="built_in">getline</span>(cin, infixExpression);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (infixExpression == <span class="string">&quot;q&quot;</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;感谢使用中缀表达式转后缀表达式程序，再见！&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string postfixExpression = <span class="built_in">infixToPostfix</span>(infixExpression);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;后缀表达式：&quot;</span> &lt;&lt; postfixExpression &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入另一个中缀表达式，或输入&#x27;q&#x27;退出：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getOperatorPrecedence</span><span class="params">(<span class="type">char</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOperator</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;*&#x27;</span> || c == <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">infixToPostfix</span><span class="params">(<span class="type">const</span> string&amp; infix)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; operatorStack;</span><br><span class="line">    string postfixExpression;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : infix) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(c)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c) || <span class="built_in">isalpha</span>(c)) &#123;</span><br><span class="line">            postfixExpression += c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isOperator</span>(c)) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!operatorStack.<span class="built_in">empty</span>() &amp;&amp;</span><br><span class="line">                <span class="built_in">getOperatorPrecedence</span>(operatorStack.<span class="built_in">top</span>()) &gt;= <span class="built_in">getOperatorPrecedence</span>(c)) &#123;</span><br><span class="line">                postfixExpression += operatorStack.<span class="built_in">top</span>();</span><br><span class="line">                operatorStack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            operatorStack.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            operatorStack.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!operatorStack.<span class="built_in">empty</span>() &amp;&amp; operatorStack.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                postfixExpression += operatorStack.<span class="built_in">top</span>();</span><br><span class="line">                operatorStack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!operatorStack.<span class="built_in">empty</span>() &amp;&amp; operatorStack.<span class="built_in">top</span>() == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                operatorStack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;错误：括号不匹配&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;错误：无效的字符 &#x27;&quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!operatorStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (operatorStack.<span class="built_in">top</span>() == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;错误：括号不匹配&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        postfixExpression += operatorStack.<span class="built_in">top</span>();</span><br><span class="line">        operatorStack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> postfixExpression;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-实现中缀表达式转后缀表达式-1"><a href="#C-实现中缀表达式转后缀表达式-1" class="headerlink" title="C 实现中缀表达式转后缀表达式"></a>C 实现中缀表达式转后缀表达式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_STACK_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈结构和操作</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> data[MAX_STACK_SIZE];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initialize</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isFull</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == MAX_STACK_SIZE - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Stack* <span class="built_in">stack</span>, <span class="type">char</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isFull(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;data[++<span class="built_in">stack</span>-&gt;top] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;错误：栈已满\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">pop</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;错误：栈为空\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">peek</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getOperatorPrecedence</span><span class="params">(<span class="type">char</span> op)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">isOperator</span><span class="params">(<span class="type">char</span> c)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">infixToPostfix</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* infix, <span class="type">char</span>* postfix)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;欢迎使用中缀表达式转后缀表达式程序！\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个中缀表达式，输入&#x27;q&#x27;退出：\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> infixExpression[<span class="number">100</span>];</span><br><span class="line">        fgets(infixExpression, <span class="keyword">sizeof</span>(infixExpression), <span class="built_in">stdin</span>);</span><br><span class="line">        infixExpression[<span class="built_in">strcspn</span>(infixExpression, <span class="string">&quot;\n&quot;</span>)] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 去掉换行符</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(infixExpression, <span class="string">&quot;q&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;感谢使用中缀表达式转后缀表达式程序，再见！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> postfixExpression[<span class="number">100</span>];</span><br><span class="line">        infixToPostfix(infixExpression, postfixExpression);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;后缀表达式：%s\n&quot;</span>, postfixExpression);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入另一个中缀表达式，或输入&#x27;q&#x27;退出：\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getOperatorPrecedence</span><span class="params">(<span class="type">char</span> op)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isOperator</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;*&#x27;</span> || c == <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">infixToPostfix</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* infix, <span class="type">char</span>* postfix)</span> &#123;</span><br><span class="line">    Stack operatorStack;</span><br><span class="line">    initialize(&amp;operatorStack);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (infix[i] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(infix[i])) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isdigit</span>(infix[i]) || <span class="built_in">isalpha</span>(infix[i])) &#123;</span><br><span class="line">            postfix[j++] = infix[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isOperator(infix[i])) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!isEmpty(&amp;operatorStack) &amp;&amp; getOperatorPrecedence(peek(&amp;operatorStack)) &gt;= getOperatorPrecedence(infix[i])) &#123;</span><br><span class="line">                postfix[j++] = pop(&amp;operatorStack);</span><br><span class="line">            &#125;</span><br><span class="line">            push(&amp;operatorStack, infix[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (infix[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            push(&amp;operatorStack, infix[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (infix[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!isEmpty(&amp;operatorStack) &amp;&amp; peek(&amp;operatorStack) != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                postfix[j++] = pop(&amp;operatorStack);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isEmpty(&amp;operatorStack) &amp;&amp; peek(&amp;operatorStack) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                pop(&amp;operatorStack); <span class="comment">// 弹出 &#x27;(&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;错误：括号不匹配\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;错误：无效的字符 &#x27;%c&#x27;\n&quot;</span>, infix[i]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(&amp;operatorStack)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (peek(&amp;operatorStack) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;错误：括号不匹配\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        postfix[j++] = pop(&amp;operatorStack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postfix[j] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 添加字符串终止符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前缀表达式及其求值方法"><a href="#前缀表达式及其求值方法" class="headerlink" title="前缀表达式及其求值方法"></a>前缀表达式及其求值方法</h2><p>前缀表达式又称为波兰表达式，它的特点是运算符在操作数的前面，如：$+ 1 <em> 2 3$，$- + 1 </em> + 2 3 4 5$，$+ 1 <em> 2 + 3 </em> 4 + 5 6$ 等等。</p><h3 id="前缀表达式的求值方法"><a href="#前缀表达式的求值方法" class="headerlink" title="前缀表达式的求值方法"></a>前缀表达式的求值方法</h3><p>前缀表达式的求值方法是：从右到左遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。</p><p>例如：$+ 1 * 2 3$ 的求值过程如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">读入字符</th><th style="text-align:center">当前栈</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">读入 3，进栈</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">3 2</td><td style="text-align:center">读入 2，进栈</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">6</td><td style="text-align:center">读入 <em>，出栈 2 和 3，计算 2 </em> 3 = 6，将 6 进栈</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">6 1</td><td style="text-align:center">读入 1，进栈</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">7</td><td style="text-align:center">读入 +，出栈 1 和 6，计算 1 + 6 = 7，将 7 进栈</td></tr></tbody></table></div><h3 id="C-实现前缀表达式的求值"><a href="#C-实现前缀表达式的求值" class="headerlink" title="C++ 实现前缀表达式的求值"></a>C++ 实现前缀表达式的求值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOperator</span><span class="params">(<span class="type">const</span> string&amp; token)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isNumeric</span><span class="params">(<span class="type">const</span> string&amp; token)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">evaluatePrefixExpression</span><span class="params">(<span class="type">const</span> vector&lt;string&gt;&amp; tokens)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;欢迎使用前缀表达式求值程序！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入前缀表达式，操作符和操作数之间用空格分隔，支持+、-、*、/：&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;输入 q 退出程序&quot;</span> &lt;&lt; endl;</span><br><span class="line">        string input;</span><br><span class="line">        <span class="built_in">getline</span>(cin, input);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (input == <span class="string">&quot;q&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 用户输入了&quot;q&quot;，退出程序</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">istringstream <span class="title">iss</span><span class="params">(input)</span></span>;</span><br><span class="line">        vector&lt;string&gt; tokens;</span><br><span class="line"></span><br><span class="line">        string token;</span><br><span class="line">        <span class="keyword">while</span> (iss &gt;&gt; token) &#123;</span><br><span class="line">            tokens.<span class="built_in">push_back</span>(token);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tokens.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;错误：输入为空，请重新输入表达式。&quot;</span> &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;输入 q 退出程序&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 继续下一次循环</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> result = <span class="built_in">evaluatePrefixExpression</span>(tokens);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isnan</span>(result)) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;表达式结果为：&quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;错误：无法计算表达式结果，请检查表达式是否正确。&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;感谢使用前缀表达式求值程序！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOperator</span><span class="params">(<span class="type">const</span> string&amp; token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (token == <span class="string">&quot;+&quot;</span> || token == <span class="string">&quot;-&quot;</span> || token == <span class="string">&quot;*&quot;</span> || token == <span class="string">&quot;/&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isNumeric</span><span class="params">(<span class="type">const</span> string&amp; token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : token) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(c) &amp;&amp; c != <span class="string">&#x27;.&#x27;</span> &amp;&amp; c != <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">evaluatePrefixExpression</span><span class="params">(<span class="type">const</span> vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">double</span>&gt; operandStack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = tokens.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">const</span> string&amp; token = tokens[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isNumeric</span>(token)) &#123;</span><br><span class="line">            operandStack.<span class="built_in">push</span>(<span class="built_in">stod</span>(token));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isOperator</span>(token)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (operandStack.<span class="built_in">size</span>() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;错误：操作数不足，无法进行操作。&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">return</span> NAN;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">double</span> operand1 = operandStack.<span class="built_in">top</span>();</span><br><span class="line">            operandStack.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">double</span> operand2 = operandStack.<span class="built_in">top</span>();</span><br><span class="line">            operandStack.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (token == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">                operandStack.<span class="built_in">push</span>(operand1 + operand2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">                operandStack.<span class="built_in">push</span>(operand1 - operand2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">                operandStack.<span class="built_in">push</span>(operand1 * operand2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (operand2 == <span class="number">0</span>) &#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;错误：除数为零，无法进行除法操作。&quot;</span> &lt;&lt; endl;</span><br><span class="line">                    <span class="keyword">return</span> NAN;</span><br><span class="line">                &#125;</span><br><span class="line">                operandStack.<span class="built_in">push</span>(operand1 / operand2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;错误：无效的表达式元素 \&quot;&quot;</span> &lt;&lt; token &lt;&lt; <span class="string">&quot;\&quot;，请检查表达式是否正确。&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> NAN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (operandStack.<span class="built_in">size</span>() != <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;错误：操作数和操作符数量不匹配，无法计算表达式结果。&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> NAN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> operandStack.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-实现前缀表达式的求值-1"><a href="#C-实现前缀表达式的求值-1" class="headerlink" title="C 实现前缀表达式的求值"></a>C 实现前缀表达式的求值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EXPRESSION_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable : 4996)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isOperator</span><span class="params">(<span class="type">const</span> <span class="type">char</span> token)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isNumeric</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* token)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">evaluatePrefixExpression</span><span class="params">(<span class="type">const</span> <span class="type">char</span>** tokens, <span class="type">int</span> numTokens)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;欢迎使用前缀表达式求值程序！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入前缀表达式，操作符和操作数之间用空格分隔，支持+、-、*、/：\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入 q 退出程序。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> input[MAX_EXPRESSION_SIZE];</span><br><span class="line">        fgets(input, <span class="keyword">sizeof</span>(input), <span class="built_in">stdin</span>);</span><br><span class="line">        input[<span class="built_in">strcspn</span>(input, <span class="string">&quot;\n&quot;</span>)] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 移除末尾的换行符</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input, <span class="string">&quot;q&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 用户输入了&quot;q&quot;，退出程序</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* delimiters = <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="type">char</span>* token = strtok(input, delimiters);</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* tokens[MAX_EXPRESSION_SIZE];</span><br><span class="line">        <span class="type">int</span> numTokens = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (token != <span class="literal">NULL</span> &amp;&amp; numTokens &lt; MAX_EXPRESSION_SIZE) &#123;</span><br><span class="line">            tokens[numTokens] = token;</span><br><span class="line">            numTokens++;</span><br><span class="line">            token = strtok(<span class="literal">NULL</span>, delimiters);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (numTokens == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;错误：输入为空，请重新输入表达式。\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入 q 退出程序。\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 继续下一次循环</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> result = evaluatePrefixExpression(tokens, numTokens);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isnan(result)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;表达式结果为：%g\n&quot;</span>, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;错误：无法计算表达式结果，请检查表达式是否正确。\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;感谢使用前缀表达式求值程序！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isOperator</span><span class="params">(<span class="type">const</span> <span class="type">char</span> token)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (token == <span class="string">&#x27;+&#x27;</span> || token == <span class="string">&#x27;-&#x27;</span> || token == <span class="string">&#x27;*&#x27;</span> || token == <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isNumeric</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* token)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; token[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(token[i]) &amp;&amp; token[i] != <span class="string">&#x27;.&#x27;</span> &amp;&amp; token[i] != <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">evaluatePrefixExpression</span><span class="params">(<span class="type">const</span> <span class="type">char</span>** tokens, <span class="type">int</span> numTokens)</span> &#123;</span><br><span class="line">    <span class="type">double</span> operandStack[MAX_EXPRESSION_SIZE];</span><br><span class="line">    <span class="type">int</span> top = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = numTokens - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* token = tokens[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isNumeric(token)) &#123;</span><br><span class="line">            operandStack[++top] = atof(token);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isOperator(token[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (top &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;错误：操作数不足，无法进行操作。\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> NAN;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">double</span> operand1 = operandStack[top--];</span><br><span class="line">            <span class="type">double</span> operand2 = operandStack[top--];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (token[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                operandStack[++top] = operand1 + operand2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                operandStack[++top] = operand1 - operand2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                operandStack[++top] = operand1 * operand2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> (operand2 == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;错误：除数为零，无法进行除法操作。\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> NAN;</span><br><span class="line">                &#125;</span><br><span class="line">                operandStack[++top] = operand1 / operand2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;错误：无效的操作符 \&quot;%s\&quot;，请检查表达式是否正确。\n&quot;</span>, token);</span><br><span class="line">                <span class="keyword">return</span> NAN;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;错误：无效的表达式元素 \&quot;%s\&quot;，请检查表达式是否正确。\n&quot;</span>, token);</span><br><span class="line">            <span class="keyword">return</span> NAN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (top != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;错误：操作数和操作符数量不匹配，无法计算表达式结果。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> NAN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> operandStack[top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前缀表达式的转换方法-中缀转前缀"><a href="#前缀表达式的转换方法-中缀转前缀" class="headerlink" title="前缀表达式的转换方法(中缀转前缀)"></a>前缀表达式的转换方法(中缀转前缀)</h3><p>将中缀表达式转换为前缀表达式的方法是：从右到左遍历中缀表达式的每个数字和符号，若是数字就输出，若是符号，则判断其与栈顶符号的优先级，是右括号或优先级不高于栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出前缀表达式为止。</p><p>例如：$1 + (2 + 3) * 4 - 5$ 的转换过程如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">读入字符</th><th style="text-align:center">当前栈</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">5</td><td style="text-align:center">5</td><td style="text-align:center">读入 5，进栈</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">读入 -，进栈</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">- 4</td><td style="text-align:center">读入 4，进栈</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">*</td><td style="text-align:center">读入 *，进栈</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">+</td><td style="text-align:center">读入 +，进栈</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">+ 3</td><td style="text-align:center">读入 3，进栈</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">+</td><td style="text-align:center">读入 +，进栈</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">+ 2</td><td style="text-align:center">读入 2，进栈</td></tr><tr><td style="text-align:center">(</td><td style="text-align:center">+ (</td><td style="text-align:center">读入 (，进栈</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">+ ( 1</td><td style="text-align:center">读入 1，输出</td></tr><tr><td style="text-align:center">空</td><td style="text-align:center">+</td><td style="text-align:center">依次出栈 + 和 (，输出</td></tr></tbody></table></div><p>转换后的前缀表达式为：$- * + 1 2 3 4 5$。</p><h3 id="C-实现中缀表达式转前缀表达式"><a href="#C-实现中缀表达式转前缀表达式" class="headerlink" title="C++ 实现中缀表达式转前缀表达式"></a>C++ 实现中缀表达式转前缀表达式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getOperatorPrecedence</span><span class="params">(<span class="type">char</span> op)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOperator</span><span class="params">(<span class="type">char</span> token)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOperand</span><span class="params">(<span class="type">char</span> token)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">infixToPrefix</span><span class="params">(<span class="type">const</span> string&amp; infixExpression)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;欢迎使用中缀表达式转前缀表达式程序！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入中缀表达式或输入 &#x27;q&#x27; 退出：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        string input;</span><br><span class="line">        <span class="built_in">getline</span>(cin, input);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (input == <span class="string">&quot;q&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 用户输入了&#x27;q&#x27;，退出程序</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string prefixExpression = <span class="built_in">infixToPrefix</span>(input);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!prefixExpression.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;前缀表达式为：&quot;</span> &lt;&lt; prefixExpression &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;错误：无法转换表达式，请检查表达式是否正确。&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;感谢使用中缀表达式转前缀表达式程序！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getOperatorPrecedence</span><span class="params">(<span class="type">char</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOperator</span><span class="params">(<span class="type">char</span> token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (token == <span class="string">&#x27;+&#x27;</span> || token == <span class="string">&#x27;-&#x27;</span> || token == <span class="string">&#x27;*&#x27;</span> || token == <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOperand</span><span class="params">(<span class="type">char</span> token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isalnum</span>(token);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">infixToPrefix</span><span class="params">(<span class="type">const</span> string&amp; infixExpression)</span> </span>&#123;</span><br><span class="line">    string prefixExpression;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; operatorStack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转中缀表达式，方便从右到左处理</span></span><br><span class="line">    string reversedInfix = infixExpression;</span><br><span class="line">    <span class="built_in">reverse</span>(reversedInfix.<span class="built_in">begin</span>(), reversedInfix.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> token : reversedInfix) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isOperand</span>(token)) &#123;</span><br><span class="line">            prefixExpression = token + prefixExpression;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isOperator</span>(token)) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!operatorStack.<span class="built_in">empty</span>() &amp;&amp; <span class="built_in">getOperatorPrecedence</span>(token) &lt; <span class="built_in">getOperatorPrecedence</span>(operatorStack.<span class="built_in">top</span>())) &#123;</span><br><span class="line">                prefixExpression = operatorStack.<span class="built_in">top</span>() + prefixExpression;</span><br><span class="line">                operatorStack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            operatorStack.<span class="built_in">push</span>(token);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            operatorStack.<span class="built_in">push</span>(token);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!operatorStack.<span class="built_in">empty</span>() &amp;&amp; operatorStack.<span class="built_in">top</span>() != <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                prefixExpression = operatorStack.<span class="built_in">top</span>() + prefixExpression;</span><br><span class="line">                operatorStack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!operatorStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                operatorStack.<span class="built_in">pop</span>(); <span class="comment">// 弹出匹配的右括号</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 括号不匹配</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!operatorStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (operatorStack.<span class="built_in">top</span>() == <span class="string">&#x27;(&#x27;</span> || operatorStack.<span class="built_in">top</span>() == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 括号不匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">        prefixExpression = operatorStack.<span class="built_in">top</span>() + prefixExpression;</span><br><span class="line">        operatorStack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prefixExpression;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-实现中缀表达式转前缀表达式-1"><a href="#C-实现中缀表达式转前缀表达式-1" class="headerlink" title="C 实现中缀表达式转前缀表达式"></a>C 实现中缀表达式转前缀表达式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable : 4996)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> arr[MAX_SIZE];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(Stack* s)</span> &#123;</span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Stack s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isFull</span><span class="params">(Stack s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.top == MAX_SIZE - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Stack* s, <span class="type">char</span> ch)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(*s)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack overflow!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;arr[++(s-&gt;top)] = ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">pop</span><span class="params">(Stack* s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(*s)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack underflow!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;arr[(s-&gt;top)--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">peek</span><span class="params">(Stack s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.arr[s.top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isOperator</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ch == <span class="string">&#x27;+&#x27;</span> || ch == <span class="string">&#x27;-&#x27;</span> || ch == <span class="string">&#x27;*&#x27;</span> || ch == <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">precedence</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">infixToPrefix</span><span class="params">(<span class="type">char</span>* infix, <span class="type">char</span>* prefix)</span> &#123;</span><br><span class="line">    Stack operators;</span><br><span class="line">    initStack(&amp;operators);</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">strlen</span>(infix) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">char</span> ch = infix[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) || (ch &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;z&#x27;</span>) || (ch &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;Z&#x27;</span>)) &#123;</span><br><span class="line">            prefix[j++] = ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            push(&amp;operators, ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!isEmpty(operators) &amp;&amp; peek(operators) != <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                prefix[j++] = pop(&amp;operators);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isEmpty(operators) &amp;&amp; peek(operators) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                pop(&amp;operators);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isOperator(ch)) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!isEmpty(operators) &amp;&amp; precedence(ch) &lt;= precedence(peek(operators))) &#123;</span><br><span class="line">                prefix[j++] = pop(&amp;operators);</span><br><span class="line">            &#125;</span><br><span class="line">            push(&amp;operators, ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(operators)) &#123;</span><br><span class="line">        prefix[j++] = pop(&amp;operators);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prefix[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    _strrev(prefix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> infix[MAX_SIZE], prefix[MAX_SIZE];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入中缀表达式[不要留空格] (输入q退出): &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, infix);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(infix, <span class="string">&quot;q&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;退出计算器。\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        infixToPrefix(infix, prefix);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;前缀表达式: %s\n&quot;</span>, prefix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://rdququ.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</category>
      
      
      <category domain="https://rdququ.top/tags/C%E8%AF%AD%E8%A8%80-C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">C语言,C++,数据结构与算法</category>
      
      
      <comments>https://rdququ.top/posts/29455a3d/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>DiffusionModel原理学习笔记</title>
      <link>https://rdququ.top/posts/aa051d3a/</link>
      <guid>https://rdququ.top/posts/aa051d3a/</guid>
      <pubDate>Thu, 19 Oct 2023 08:41:53 GMT</pubDate>
      
      <description>&lt;p&gt;去噪自动编码器&lt;/p&gt;
&lt;p&gt;Diffusion model 是一种深度生成模型（无监督生成模型），它属于：&lt;br&gt;机器学习 -&amp;gt; 无监督学习 -&amp;gt; 概率模型 -&amp;gt; 生成模型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;DM归属.png&quot; alt=&quot;分类图&quot;&gt;&lt;/p&gt;
&lt;p&gt;概率模型是为了求得数据的后验概率$P(Y|X)$或者联合验概率$P(X,Y)$&lt;br&gt;对于监督学习而言，判别模型主要是求后验概率，也就是通过输入的特征X去求标签信息Y。生成模型主要是未了求得联合概率，对于X，求出X与不同标签之间的联合概率，取最大的那个标签作为预测结果。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>去噪自动编码器</p><p>Diffusion model 是一种深度生成模型（无监督生成模型），它属于：<br>机器学习 -&gt; 无监督学习 -&gt; 概率模型 -&gt; 生成模型</p><p><img src="DM归属.png" alt="分类图"></p><p>概率模型是为了求得数据的后验概率$P(Y|X)$或者联合验概率$P(X,Y)$<br>对于监督学习而言，判别模型主要是求后验概率，也就是通过输入的特征X去求标签信息Y。生成模型主要是未了求得联合概率，对于X，求出X与不同标签之间的联合概率，取最大的那个标签作为预测结果。</p><span id="more"></span><h3 id="隐空间和隐变量-latent-space-hidden-variables"><a href="#隐空间和隐变量-latent-space-hidden-variables" class="headerlink" title="隐空间和隐变量 (latent space/hidden variables)"></a>隐空间和隐变量 (latent space/hidden variables)</h3><p><img src="隐变量.png" alt="间接"></p><p>a 直接到 b 比较困难，所以可以通过间接变量 c 来实现。</p><h3 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h3><p><img src="autoencoder.png" alt="autoencoder"></p><p><img src="diffusion.png" alt="diffusion"> </p><p>$X_0$ 是原始的输入图像，$X_T$ 是 total noise</p><p>在从右往左的过程中的每一步都会给样本增加一个小的满足高斯分布的噪声，整个过程为一个一阶马尔可夫过程，这是一个正向扩散过程，如果把它反过来，也就是从左往右看上图，那么就是一个反向扩散过程。</p><p>正向分布的时候添加的噪声都是符合高斯分布的，那么这些噪声合并后仍然是处于高斯分布的。但是当我们逆推这一过程的时候，除非我们拥有整体数据集合，不然我们是没有办法直接求解的，通常来说我们会训练一个模型 $p<em>θ$来预测反向扩散过程的条件概率 $q(x</em>{t-1}|x<em>t)$.<br>通过这个模型，我们输入 $X_t$ 和 $t$ 可以预测出 $X</em>{t-1}$ 的条件概率分布(如果正向扩散每步增加的噪声够小,它可以被视为高斯分布)的均值 $μ<em>θ(x_t,t)$和方差 $\sum</em>θ(x<em>t,t)$，基于预测值,我们可以从 $x</em>{t-1}$的高斯分布 $p<em>θ(x</em>{t-1}|x<em>t)$中采样出 $X</em>{t-1}$ 的值，从而得到 $x_{t-1}$ 的一个可能的取值,后面以此类推,我们就可以逐步去噪生成一张图片.</p><p>这个模型在 DDPM 中是 U-net 网络 PixelCNN++.</p><p>简单来说,这里的反向传播,或者说是 decoder,又或者说是生成器,其实就是在简单的拟合正向部分的逆过程的每一小步.</p><p>当然,训练我们的噪声预测器需要大量的数据集,不过这仍然不值得担心,因为正向传播的每一步我们都是在给图像逐步加噪,我们可以轻松地获取从0到T每个过程的所有样本.<br><img src="UNet.png" alt="UNet"><br>上面这张图非常清晰的展现了 U-net 的训练.</p>]]></content:encoded>
      
      
      
      
      <comments>https://rdququ.top/posts/aa051d3a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>有限状态机的Unity_C#实现</title>
      <link>https://rdququ.top/posts/1f1f5f6a/</link>
      <guid>https://rdququ.top/posts/1f1f5f6a/</guid>
      <pubDate>Wed, 20 Sep 2023 02:28:51 GMT</pubDate>
      
      <description>&lt;p&gt;今天读了 &lt;code&gt;Game Programming Patterns&lt;/code&gt; 的 &lt;code&gt;State&lt;/code&gt; 章节.深感改模式对我目前代码优化的帮助巨大.于是决定写个demo来实现一下&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>今天读了 <code>Game Programming Patterns</code> 的 <code>State</code> 章节.深感改模式对我目前代码优化的帮助巨大.于是决定写个demo来实现一下</p><span id="more"></span><p>文章中是用<code>C++</code>作为描述语言的,而对于使用 Unity 引擎, C# 语言的我来说,需要做一些适应性的修改.</p><p>这个<code>demo</code>主要涉及的是玩家控制</p><h2 id="FSM-有限状态机"><a href="#FSM-有限状态机" class="headerlink" title="FSM(有限状态机)"></a>FSM(有限状态机)</h2><h3 id="为什么要使用有限状态机"><a href="#为什么要使用有限状态机" class="headerlink" title="为什么要使用有限状态机"></a>为什么要使用有限状态机</h3><p>在回答这个问题之前,不妨想一想你自己之前是如何实现玩家控制的,就以跳跃为例</p><p>或许你会这样写</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Jump</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//跳跃</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然这个函数有个大问题,只要按下空格键,你就会一直往上跳,最后你的角色就飞了起来,这当然不是你想要的.最简单的修补办法是给他添加上一个<code>isJumping</code>或者<code>isOnGround</code>的布尔判断</p><p>再然后,你又想给你的角色添加一个冲刺的功能,如果你什么也不做,神奇的玩家或许会对冲刺中按下跳跃键后发生的事情感到啼笑皆非,这时候你又需要添加一个<code>isDashing</code>的布尔判断.然而实际开发中的需求可不会像上面的例子一样简单,你也不想你的代码里全是各种<code>if else</code>吧.</p>]]></content:encoded>
      
      
      
      
      <comments>https://rdququ.top/posts/1f1f5f6a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Game Programming Patterns_Prototype原型模式</title>
      <link>https://rdququ.top/posts/cb3ccb51/</link>
      <guid>https://rdququ.top/posts/cb3ccb51/</guid>
      <pubDate>Mon, 18 Sep 2023 15:05:27 GMT</pubDate>
      
      <description>&lt;p&gt;如果给你一个需求  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你需要设计出一群不同种类的可怖的怪物,让他们在英雄前进的道路上阻挡他们&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你会则表明怎么做呢?&lt;br&gt;或许当你刚接触游戏开发的时候,你会这样做&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>如果给你一个需求  </p><blockquote><p>你需要设计出一群不同种类的可怖的怪物,让他们在英雄前进的道路上阻挡他们</p></blockquote><p>你会则表明怎么做呢?<br>或许当你刚接触游戏开发的时候,你会这样做</p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Monster</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 代码……</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ghost</span> : <span class="keyword">public</span> Monster &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demon</span> : <span class="keyword">public</span> Monster &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sorcerer</span> : <span class="keyword">public</span> Monster &#123;&#125;;</span><br></pre></td></tr></table></figure><p>每一种怪物都有自己的类.为了让这些家伙降临到这个世界,或许你还会给他们精心设计独属于他们自己的生产者类(spawner).事实上,这是一种相当暴力的解决方案,每个怪物都有自己的生产者类,这构成了一种平行的类的结构.</p><p><img src="image.png" alt="Alt text"></p><blockquote><p>图上这个带尾巴的小三角形是继承的意思</p></blockquote><p>下面是该方案一种实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spawner</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Spawner</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Monster* <span class="title">spawnMonster</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GhostSpawner</span> : <span class="keyword">public</span> Spawner</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Monster* <span class="title">spawnMonster</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Ghost</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemonSpawner</span> : <span class="keyword">public</span> Spawner</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Monster* <span class="title">spawnMonster</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Demon</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  You get the idea...</span></span><br></pre></td></tr></table></figure><p>如果你和你的学长/前辈一起共事,那么作为经验丰富的代码世界的造物主,他肯定会想方设法阻止你 <code>&quot;这种代码很难维护.&quot;&quot;如果有策划设计了一千种怪物,那么你要专门为这个项目撰写一本字典吗?&quot;</code>显然,以这种方法创世,第七天肯定没法放假.</p><h2 id="一个更好的方法"><a href="#一个更好的方法" class="headerlink" title="一个更好的方法"></a>一个更好的方法</h2><p>前人给出了一个比上面的实现更具性价比的解决方案 <code>设计模式</code>.</p><blockquote><p>关键思路是<code>一个对象可以产出与它自己相近的对象</code>。 如果你有一个恶灵，你可以制造更多恶灵。 如果你有一个恶魔，你可以制造其他恶魔。 任何怪物都可以被视为<code>原型</code>怪物，产出其他版本的自己。</p></blockquote><p>为了实现这个功能,我们可以给基类<code>Monster</code>添加一个抽象方法<code>clone</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Monster</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Monster</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Monster* <span class="title">clone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Other stuff...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后,我们可以让每个怪物都实现这个方法,并且返回一个与它自己的类和状态都完全一样的新对象.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ghost</span> : <span class="keyword">public</span> Monster &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Ghost</span>(<span class="type">int</span> health, <span class="type">int</span> speed)</span><br><span class="line">  : <span class="built_in">health_</span>(health),</span><br><span class="line">    <span class="built_in">speed_</span>(speed)</span><br><span class="line">  &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Monster* <span class="title">clone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Ghost</span>(health_, speed_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> health_;</span><br><span class="line">  <span class="type">int</span> speed_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在,我们不再需要再给每个怪物都添加上他们自己的生产者类了,我们大可以写一个<code>Spawner</code>类,它可以接受一个<code>Monster</code>对象,并且使用<code>clone</code>方法来产生新的怪物.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Spawner</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Spawner</span>(Monster* prototype)</span><br><span class="line">  : <span class="built_in">prototype_</span>(prototype)</span><br><span class="line">  &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Monster* <span class="title">spawnMonster</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prototype_-&gt;<span class="built_in">clone</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Monster* prototype_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>重要的是</strong>,或者说他和抽离内部实现的接口思想有很大不同的一点是,他内部是存有<code>template</code>的,模板是怎样的,克隆出来的怪物就是怎样的.</p><p><img src="image-1.png" alt="Alt text"></p><p>书上举了一个很直观的例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Monster* ghostPrototype = <span class="keyword">new</span> <span class="built_in">Ghost</span>(<span class="number">15</span>, <span class="number">3</span>);</span><br><span class="line">Spawner* ghostSpawner = <span class="keyword">new</span> <span class="built_in">Spawner</span>(ghostPrototype);</span><br></pre></td></tr></table></figure><p>这段代码创建了一个恶灵的原型实例,然后创建了这个实例的生产者. 巧妙的是,我们只需要更改这个模板鬼魂的状态,就可以创建出各种各样的鬼魂.</p><p>看起来一切都搞定了</p><p>吗?</p><p>不说每个<code>clone</code>方法仍然需要我们自己去实现,这些工作量不比给每个怪物都写一个生产者类少多少,也不说实际程序开发中会遇到的不同的语义漏洞</p><blockquote><p>做深层拷贝还是浅层拷贝呢？换言之，如果恶魔拿着叉子，克隆恶魔也要克隆叉子吗？</p></blockquote><p>就说这种方法的前提就很难达成,在现代的游戏引擎上工作,还有谁会给每个怪物都设计一个自己的类?</p><h2 id="生产函数"><a href="#生产函数" class="headerlink" title="生产函数"></a>生产函数</h2><p>哪怕我们必须要为每个怪物都添加上一个独立的类,那么给给每个怪物都添加上一个分离的生产者类也并非上上之选,我们可以使用一个更加简单的方法,那就是使用一个生产函数.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Monster* <span class="title">spawnGhost</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Ghost</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面给出新方法的实现,可以看看这和上面的方法有什么区别?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Monster* (*SpawnCallback)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spawner</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Spawner</span>(SpawnCallback spawn)</span><br><span class="line">  : <span class="built_in">spawn_</span>(spawn)</span><br><span class="line">  &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Monster* <span class="title">spawnMonster</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">spawn_</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  SpawnCallback spawn_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>很显然,函数指针嘛,生产者类不需要再存储一个怪物对象了,它只需要储存一个函数指针就可以做到和之前一样的事情了.后面是构筑生产者的代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spawner* ghostSpawner = <span class="keyword">new</span> <span class="built_in">Spawner</span>(spawnGhost);</span><br></pre></td></tr></table></figure><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>模板没什么好说的,这是一个C++程序员必须掌握的一个编程方法.在另一些语言中其思想被推广为泛型<strong>T</strong></p><p>模板和许多高级语言中的继承或者接口不一样,这些机制大多是运行时才确定的(比如成员函数只有在运行时才知道调用哪个),所以被叫做<strong>运行时多态</strong>,而模板则是一种<strong>编译时多态</strong>,编译器在编译的时候就知道调用哪个函数了.代价是目标代码会多一点.</p><p>那么事情就很清楚了,如果我们把生产者类当作模板中的<code>T</code>(类型参数),我们就能实现这样一段代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Spawner</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Spawner</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Monster* <span class="title">spawnMonster</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpawnerFor</span> : <span class="keyword">public</span> Spawner</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Monster* <span class="title">spawnMonster</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">T</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以这样使用它</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spawner* ghostSpawner = <span class="keyword">new</span> <span class="built_in">SpawnerFor</span>&lt;Ghost&gt;();</span><br></pre></td></tr></table></figure><h2 id="第一公民类型"><a href="#第一公民类型" class="headerlink" title="第一公民类型"></a>第一公民类型</h2><p>在C++中，类型不是第一公民,所以我们需要进行一些小改动,不过在此之前,我们需要讨论一下什么是第一公民/第二公民</p><p>第一公民类型是指可以被当作参数传递,可以被当作返回值返回,可以被当作容器的元素的类型的类型.比如说,在C++中,函数不是第一公民类型,所以我们不能把函数当作参数传递给另一个函数,也不能把函数当作返回值返回,也不能把函数当作容器的元素的类型.</p><p>我们熟悉的 char, int, float等都是第一公民类型,不能满足的上述条件的,就是第二公民了.</p>]]></content:encoded>
      
      
      <category domain="https://rdququ.top/categories/Game-Programming-Patterns/">Game Programming Patterns</category>
      
      <category domain="https://rdququ.top/categories/Design-Patterns-Revisited/">Design Patterns Revisited</category>
      
      <category domain="https://rdququ.top/categories/Prototype-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/">Prototype(原型模式)</category>
      
      
      <category domain="https://rdququ.top/tags/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">游戏设计模式</category>
      
      <category domain="https://rdququ.top/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/">原型模式</category>
      
      <category domain="https://rdququ.top/tags/C/">C++</category>
      
      
      <comments>https://rdququ.top/posts/cb3ccb51/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>简单的无限地图实现</title>
      <link>https://rdququ.top/posts/c8583f8a/</link>
      <guid>https://rdququ.top/posts/c8583f8a/</guid>
      <pubDate>Sun, 17 Sep 2023 15:46:44 GMT</pubDate>
      
      <description>&lt;p&gt;突然想写一个类吸血鬼幸存者的 &lt;code&gt;demo&lt;/code&gt;, 想了一下无限地图挺重要的,于是就设计了一个简单的无限地图实现,感觉性能一般般,过两天找一下类似的代码比对一下性能,这个功能实现还是很简单的,今天记录一下.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>突然想写一个类吸血鬼幸存者的 <code>demo</code>, 想了一下无限地图挺重要的,于是就设计了一个简单的无限地图实现,感觉性能一般般,过两天找一下类似的代码比对一下性能,这个功能实现还是很简单的,今天记录一下.</p><span id="more"></span><h2 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a>数学原理</h2><p>呢讲到无限地图算法,首先就要考虑他的数学原理.我实现的这个方法也是目前应用比较广,实现起来也是最简单的那种了.</p><p><img src="image.png" alt="Alt text"></p><p>在这张图上,我们给出了原点$O$,橙色框所框中的是以玩家出生点为原点渲染出来的第一块地图,我们可以记为$M(0,0)$,图中还给出了框的长和宽$X$和$Y$,这里的红框和绿框的大小是相同的,他的的焦点,也是相交的几条边的中点.</p><p>玩家的视野范围,即摄像机所捕获的范围是不大于橙色框的<br>我们通过矩形的四个点就可以确定所需要渲染出的地图区块,比如说当玩家在所示绿框中活动的时候,我们就需要渲染出$M(0,0),M(1,0),M(1,1),M(0,1)$这四块地图</p><p>整张地图所需要记录的只是以$X$为X轴上的单位长度和以$Y$为Y轴上的单位长度组成的点阵图,当玩家处于任意四个点组成的举行范围内时,我们只需要把以这四个点为中点,以$X$和$Y$为长和宽的标准地图就可以了.</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>首先我们定义一个结构体来储存我们的地图信息</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 地图数据</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> MapData</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> MapUnit map;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个结构体中有三个成员,<code>map</code>是一个<code>MapUnit</code>类型的变量,<code>X</code>和<code>Y</code>分别是以<code>X</code>和<code>Y</code>为单位长度的坐标.</p><p>下面放一下<code>MapUnit</code>的定义</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MapUnit</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> MapData _myData;</span><br><span class="line">    <span class="keyword">private</span> MapUnit _mapUnit;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MapManager.Instance.mapList.Add(_myData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (MapManager.Instance.checkPlayerPosition(transform))</span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MapData <span class="title">GetMyData</span>(<span class="params"><span class="built_in">int</span> _X, <span class="built_in">int</span> _Y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _myData = <span class="keyword">new</span> MapData()</span><br><span class="line">        &#123;</span><br><span class="line">            map = _mapUnit,</span><br><span class="line">            X = _X,</span><br><span class="line">            Y = _Y</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> _myData;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MapManager.Instance.mapList.Remove(_myData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也很简单,这个类有两个成员字段,分别存贮自己的地图数据和自己的脚本,他还有一个方法,用来获取自己的地图数据.<br>在<code>Start</code>方法中,我们把自己的地图数据添加到<code>MapManager</code>的<code>mapList</code>中,在<code>Update</code>方法中,地图会自行检测自己是否在玩家的视野范围内,如果是,就销毁自己,在<code>OnDestroy</code>方法中,他会把自己的地图数据从<code>MapManager</code>的<code>mapList</code>中移除.</p><p>最后来看一下地图管理类的实现</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> Unity.Mathematics;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MapManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MapManager Instance;</span><br><span class="line">    <span class="keyword">private</span> GameObject _player;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> _playerLive;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _mapX;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _mapY;</span><br><span class="line">    <span class="keyword">public</span> GameObject mapPrefabs;</span><br><span class="line">    <span class="keyword">public</span> Transform grid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;MapData&gt; mapList = <span class="keyword">new</span> List&lt;MapData&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Instance = <span class="keyword">this</span>;</span><br><span class="line">        _mapX = <span class="number">18</span>;</span><br><span class="line">        _mapY = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_playerLive)</span><br><span class="line">        &#123;</span><br><span class="line">            ConrtolAutoMap();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 获取玩家对象</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;player&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetPlayer</span>(<span class="params">GameObject player</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _player = player;</span><br><span class="line">        _playerLive = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 自动检查玩家身边的地图,并自动加载未加载地图</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConrtolAutoMap</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> x = _player.transform.position.x;</span><br><span class="line">        <span class="keyword">var</span> y = _player.transform.position.y;</span><br><span class="line">        <span class="built_in">int</span> X = (<span class="built_in">int</span>)x / _mapX;</span><br><span class="line">        <span class="built_in">int</span> Y = (<span class="built_in">int</span>)y / _mapY;</span><br><span class="line">        <span class="built_in">int</span> XX = x &gt; <span class="number">0</span> ? X + <span class="number">1</span> : X - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> YY = y &gt; <span class="number">0</span> ? Y + <span class="number">1</span> : Y - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!CheckMapLive(X, Y))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> newMap = Instantiate(mapPrefabs, <span class="keyword">new</span> Vector3(X * _mapX, Y * _mapY), quaternion.identity,grid);</span><br><span class="line">            newMap.GetComponent&lt;MapUnit&gt;().GetMyData(X, Y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!CheckMapLive(XX, Y))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> newMap = Instantiate(mapPrefabs, <span class="keyword">new</span> Vector3((XX) * _mapX, Y * _mapY), quaternion.identity,grid);</span><br><span class="line">            newMap.GetComponent&lt;MapUnit&gt;().GetMyData(XX, Y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!CheckMapLive(X, YY))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> newMap = Instantiate(mapPrefabs, <span class="keyword">new</span> Vector3(X * _mapX, (YY) * _mapY), quaternion.identity,grid);</span><br><span class="line">            newMap.GetComponent&lt;MapUnit&gt;().GetMyData(X, YY);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!CheckMapLive(XX, YY))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> newMap = Instantiate(mapPrefabs, <span class="keyword">new</span> Vector3((XX) * _mapX, (YY) * _mapY), quaternion.identity,grid);</span><br><span class="line">            newMap.GetComponent&lt;MapUnit&gt;().GetMyData(XX, YY);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 检查目标地点是否存在地图单元</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;x_target&quot;&gt;</span>坐标x<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;y_target&quot;&gt;</span>坐标y<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>存在返回true<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">CheckMapLive</span>(<span class="params"><span class="built_in">int</span> x_target, <span class="built_in">int</span> y_target</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> target =</span><br><span class="line">            <span class="keyword">from</span> m <span class="keyword">in</span> mapList</span><br><span class="line">            <span class="keyword">where</span> m.X == x_target &amp;&amp; m.Y == y_target</span><br><span class="line">            <span class="keyword">select</span> m.map;</span><br><span class="line">        <span class="keyword">return</span> target.Any();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 检查地图块是否已经超出了玩家的区块范围</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;t&quot;&gt;</span>地图的Transform<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>如果地图快已经超出了玩家的区块范围,则返回true<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">checkPlayerPosition</span>(<span class="params">Transform t</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> math.abs(t.position.x - _player.transform.position.x) &gt; _mapX ||</span><br><span class="line">               math.abs(t.position.y - _player.transform.position.y) &gt; _mapY</span><br><span class="line">            ? <span class="literal">true</span></span><br><span class="line">            : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        mapList.Clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然,写的有点蠢,不过好歹能用,生成不同地图的方法也很简单,多做几个预制体,生成的时候写一个随机方法就可以了.</p><p>过两天把这个优化一下.</p><hr>]]></content:encoded>
      
      
      <category domain="https://rdququ.top/categories/%E8%AE%B0%E5%BD%95%E5%90%91/">记录向</category>
      
      <category domain="https://rdququ.top/categories/%E8%AE%B0%E5%BD%95%E5%90%91/Unity/">Unity</category>
      
      
      <category domain="https://rdququ.top/tags/Unity/">Unity</category>
      
      <category domain="https://rdququ.top/tags/C/">C#</category>
      
      <category domain="https://rdququ.top/tags/%E6%97%A0%E9%99%90%E5%9C%B0%E5%9B%BE/">无限地图</category>
      
      
      <comments>https://rdququ.top/posts/c8583f8a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>简单的事件中心</title>
      <link>https://rdququ.top/posts/63fcc5fa/</link>
      <guid>https://rdququ.top/posts/63fcc5fa/</guid>
      <pubDate>Sat, 16 Sep 2023 12:44:41 GMT</pubDate>
      
      <description>&lt;p&gt;下面给出一个简单的事件中心的实现&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>下面给出一个简单的事件中心的实现</p><span id="more"></span><p>首先是事件类型</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 事件类型</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> EventType</span><br><span class="line">&#123;</span><br><span class="line">    Speed,Frozen,Pause,UnPause,Dash,GameOver</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后是事件中心</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 事件中心，负责注册、发布事件</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventCenter</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EventCenter _instance = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EventCenter Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                _instance = <span class="keyword">new</span> EventCenter();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> _instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Dictionary&lt;EventType, List&lt;Action&gt;&gt; eventDict = <span class="keyword">new</span> Dictionary&lt;EventType, List&lt;Action&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EventCenter</span>()</span> &#123; &#125;<span class="comment">//私有构造函数，防止外部实例化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 订阅事件</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventType&quot;&gt;</span>事件类型<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventHandler&quot;&gt;</span>事件处理方法<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SubscribeEvent</span>(<span class="params">EventType eventType, Action eventHandler</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventDict.ContainsKey(eventType))</span><br><span class="line">        &#123;</span><br><span class="line">            eventDict[eventType].Add(eventHandler);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;Action&gt; list = <span class="keyword">new</span> List&lt;Action&gt;();</span><br><span class="line">            list.Add(eventHandler);</span><br><span class="line">            eventDict.Add(eventType, list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 取消订阅事件</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventType&quot;&gt;</span>事件类型<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventHandler&quot;&gt;</span>事件处理方法<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveSubscribedEvent</span>(<span class="params">EventType eventType, Action eventHandler</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(eventDict.ContainsKey(eventType))</span><br><span class="line">        &#123;</span><br><span class="line">            eventDict[eventType].Remove(eventHandler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 发布事件</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventType&quot;&gt;</span>事件类型<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PublishEvent</span>(<span class="params">EventType eventType</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventDict.ContainsKey(eventType))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (Action handler <span class="keyword">in</span> eventDict[eventType])</span><br><span class="line">            &#123;</span><br><span class="line">                handler?.Invoke();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content:encoded>
      
      
      <category domain="https://rdququ.top/categories/%E4%BB%A3%E7%A0%81%E5%BA%93/">代码库</category>
      
      <category domain="https://rdququ.top/categories/%E4%BB%A3%E7%A0%81%E5%BA%93/Unity/">Unity</category>
      
      
      <category domain="https://rdququ.top/tags/%E4%BA%8B%E4%BB%B6-Unity-C/">事件,Unity,C#</category>
      
      
      <comments>https://rdququ.top/posts/63fcc5fa/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Unity中空判断与Destroy实现</title>
      <link>https://rdququ.top/posts/da6ffe54/</link>
      <guid>https://rdququ.top/posts/da6ffe54/</guid>
      <pubDate>Sat, 16 Sep 2023 04:59:37 GMT</pubDate>
      
      <description>&lt;p&gt;以往我在做空判断的时候，都是这样写的：&lt;/p&gt;
&lt;figure class=&quot;highlight csharp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (gameobject != &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;或者是&lt;/p&gt;
&lt;figure class=&quot;highlight csharp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (gameobject == &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最近换了Rider， 他给我来了句提示&lt;code&gt;与 &amp;#39;null&amp;#39; 的比较开销较大&lt;/code&gt;,奇奇怪怪，我换成了  &lt;code&gt;if(gameobject)&lt;/code&gt; 就没有这些提示了，那么这两种写法到底有什么区别呢？&lt;br&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>以往我在做空判断的时候，都是这样写的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (gameobject != <span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p>或者是</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (gameobject == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>最近换了Rider， 他给我来了句提示<code>与 &#39;null&#39; 的比较开销较大</code>,奇奇怪怪，我换成了  <code>if(gameobject)</code> 就没有这些提示了，那么这两种写法到底有什么区别呢？<br> <span id="more"></span></p><p>要讨论这两个问题，还真不是很简单，我们首先要了解<code>Object</code>,这里的<code>Object</code>是<code>System.Object</code>，也是<code>UnityEngine.Object</code>。</p><p><code>System.Object</code>大家都很好理解，我们来看看<code>UnityEngine.Object</code>吧。</p><p><code>UnityEngine.Object</code>继承自<code>system.Object</code>，是<code>Unity</code>所涉及所有物体的基类。</p><p>但是他们也有区别，不得不谈的就是<code>销毁</code>和<code>空判断</code>。</p><blockquote><p>这是最常见的问题，在UnityEngine中我们销毁一个对象时，使用“==”操作符与null比较结果为true，但是可以发现，我们还是可以引用这个变量，这主要是由于UnityEngine的==操作符在销毁后即将Object置位null，但是对象本身需要被GC后才能达到真正意义上的销毁，也就是System.Object中的null；</p><p>这里涉及到了托管的问题，如果不了解也不要紧，我可以告诉你从 UnityEngine.Object 继承的对象，包括托管和非托管两部分，当调用 Destroy 时，销毁的只是非托管部分，托管部分只能通过 C# 的垃圾回收器进行回收。</p></blockquote><p>什么意思呢，我们直接来看<code>Destroy</code>会更清晰一点</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span>   <span class="doctag">&lt;para&gt;</span>Removes a GameObject, component or asset.<span class="doctag">&lt;/para&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;obj&quot;&gt;</span>The object to destroy.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;t&quot;&gt;</span>The optional amount of time to delay before destroying the object.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">[<span class="meta">NativeMethod(Name = <span class="string">&quot;Scripting::DestroyObjectFromScripting&quot;</span>, IsFreeFunction = true, ThrowsException = true)</span>]</span><br><span class="line">[<span class="meta">MethodImpl(MethodImplOptions.InternalCall)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Destroy</span>(<span class="params">Object obj, [DefaultValue(<span class="string">&quot;0.0F&quot;</span></span>)] <span class="built_in">float</span> t)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span>   <span class="doctag">&lt;para&gt;</span>Removes a GameObject, component or asset.<span class="doctag">&lt;/para&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;obj&quot;&gt;</span>The object to destroy.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;t&quot;&gt;</span>The optional amount of time to delay before destroying the object.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">[<span class="meta">ExcludeFromDocs</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Destroy</span>(<span class="params">Object obj</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">float</span> t = <span class="number">0.0f</span>;</span><br><span class="line">  Object.Destroy(obj, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Unity 自己的文档讲的很清楚了， 我们来看“了解托管堆”这一节</p><blockquote><p>垃圾回收器定期运行（<strong>注意：</strong>具体运行时间视平台而定）。这时将扫描堆上的所有对象，将任何不再引用的对象标记为删除。然后会删除未引用的对象，从而释放内存。</p></blockquote><p>Unity 用了一种很讨巧的方法，他们把 <code>destroy</code> 掉的内存标记为 <code>&#39;null&#39;</code>，事实上，这些内存并没有被回收，而是在等待 C# 的 <code>GC</code> 把他们回收掉。</p><p>我们再来看看<code>Unity</code>对于<code>==</code>的重载</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="keyword">operator</span> ==(Object x, Object y) =&gt; Object.CompareBaseObjects(x, y);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="keyword">operator</span> !=(Object x, Object y) =&gt; !Object.CompareBaseObjects(x, y);</span><br></pre></td></tr></table></figure><p>还有其对布尔类型的重载</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">bool</span>(<span class="params">Object exists</span>)</span> =&gt; !Object.CompareBaseObjects(exists, (Object) <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>可以发现<code>CompareBaseObjects</code>方法的实现也是绕不开的，我们来看看</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">CompareBaseObjects</span>(<span class="params">Object lhs, Object rhs</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">bool</span> flag1 = (<span class="built_in">object</span>) lhs == <span class="literal">null</span>;</span><br><span class="line">      <span class="built_in">bool</span> flag2 = (<span class="built_in">object</span>) rhs == <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (flag2 &amp; flag1)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (flag2)</span><br><span class="line">        <span class="keyword">return</span> !Object.IsNativeObjectAlive(lhs);</span><br><span class="line">      <span class="keyword">return</span> flag1 ? !Object.IsNativeObjectAlive(rhs) : lhs.m_InstanceID == rhs.m_InstanceID;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看到这里，其实我们已经对之前的问题有了回答了</p><p><code>UnityEngine.Object</code>中的布尔类型重载和<code>==</code>运算符重载，他们都是通过<code>CompareBaseObjects</code>来实现的<br>他们俩本质上都是采用了 <code>Unity</code> 层面上的检查。</p><p>对于这点，我们也可以证明</p><p>请看方法<code>IsNativeObjectAlive</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsNativeObjectAlive</span>(<span class="params">Object o</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> (o.GetCachedPtr() != IntPtr.Zero)</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     <span class="keyword">return</span> !(o <span class="keyword">is</span> MonoBehaviour) &amp;&amp; !(o <span class="keyword">is</span> ScriptableObject) &amp;&amp; Object.DoesObjectWithInstanceIDExist(o.GetInstanceID());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>Unity</code> 先调用<code>o.GetCachedPtr()</code> 方法检查目标对象的本机指针是否还存在, 要知道 <code>IntPtr</code> 并非 <code>Unity</code> 自己鼓捣出来的玩意， 他是<code>.NET Framework</code>和 <code>.NET Core</code>中的一个特殊的结构体，用于表示目标对象的本地指针. 如果本地指针不存在，那么就会调用<code>Object.DoesObjectWithInstanceIDExist</code>方法，这个方法会检查目标对象的实例ID是否存在,如果存在具有给定实例ID的对象，则返回 true.</p><p>通过这种方法实现的空判断,实质上开销是特别大的,有些人会使用<code>System.Object.ReferenceEquals</code>,比如这样</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(System.Object.ReferenceEquals(gameobject, <span class="literal">null</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// TODO something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做,在性能上确实是有很大提升的,但是读到这里的朋友估计已经猜到我要讲什么了.<br>在执行<code>destroy</code>方法后,目标对象实质上并没有被回收,他只是被打上了一个<code>&#39;tag&#39;</code>的标签,而变量仍然在指向着堆对象.为什么<code>==</code>可以呢,因为<code>Unity</code>已经把他重载了.</p><hr>]]></content:encoded>
      
      
      <category domain="https://rdququ.top/categories/%E8%AE%B0%E5%BD%95%E5%90%91/">记录向</category>
      
      <category domain="https://rdququ.top/categories/%E8%AE%B0%E5%BD%95%E5%90%91/Unity/">Unity</category>
      
      <category domain="https://rdququ.top/categories/%E8%AE%B0%E5%BD%95%E5%90%91/Unity/GC/">GC</category>
      
      
      <category domain="https://rdququ.top/tags/GC-Unity-%E5%86%85%E5%AD%98-C-%E7%A9%BA%E5%BC%95%E7%94%A8%E5%88%A4%E6%96%AD-Destroy/">GC,Unity,内存,C#,空引用判断,Destroy</category>
      
      
      <comments>https://rdququ.top/posts/da6ffe54/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Unity文件读写方法之StreamingAssets</title>
      <link>https://rdququ.top/posts/fc36bd86/</link>
      <guid>https://rdququ.top/posts/fc36bd86/</guid>
      <pubDate>Sat, 26 Aug 2023 07:27:35 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;StreamingAssets-文件夹&quot;&gt;&lt;a href=&quot;#StreamingAssets-文件夹&quot; class=&quot;headerlink&quot; title=&quot;StreamingAssets 文件夹&quot;&gt;&lt;/a&gt;StreamingAssets 文件夹&lt;/h2&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="StreamingAssets-文件夹"><a href="#StreamingAssets-文件夹" class="headerlink" title="StreamingAssets 文件夹"></a>StreamingAssets 文件夹</h2>]]></content:encoded>
      
      
      
      
      <comments>https://rdququ.top/posts/fc36bd86/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
