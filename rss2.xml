<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>蛐蛐的软件开发世界</title>
    <link>http://rdququ.top/</link>
    
    <atom:link href="http://rdququ.top/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>正在学习unity中</description>
    <pubDate>Fri, 22 Sep 2023 16:06:07 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>有限状态机的Unity_C#实现</title>
      <link>http://rdququ.top/posts/1f1f5f6a/</link>
      <guid>http://rdququ.top/posts/1f1f5f6a/</guid>
      <pubDate>Wed, 20 Sep 2023 02:28:51 GMT</pubDate>
      
      <description>&lt;p&gt;今天读了 &lt;code&gt;Game Programming Patterns&lt;/code&gt; 的 &lt;code&gt;State&lt;/code&gt; 章节.深感改模式对我目前代码优化的帮助巨大.于是决定写个demo来实现一下&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>今天读了 <code>Game Programming Patterns</code> 的 <code>State</code> 章节.深感改模式对我目前代码优化的帮助巨大.于是决定写个demo来实现一下</p><span id="more"></span><p>文章中是用<code>C++</code>作为描述语言的,而对于使用 Unity 引擎, C# 语言的我来说,需要做一些适应性的修改.</p><p>这个<code>demo</code>主要涉及的是玩家控制</p><h2 id="FSM-有限状态机"><a href="#FSM-有限状态机" class="headerlink" title="FSM(有限状态机)"></a>FSM(有限状态机)</h2><h3 id="为什么要使用有限状态机"><a href="#为什么要使用有限状态机" class="headerlink" title="为什么要使用有限状态机"></a>为什么要使用有限状态机</h3><p>在回答这个问题之前,不妨想一想你自己之前是如何实现玩家控制的,就以跳跃为例</p><p>或许你会这样写</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Jump</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//跳跃</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然这个函数有个大问题,只要按下空格键,你就会一直往上跳,最后你的角色就飞了起来,这当然不是你想要的.最简单的修补办法是给他添加上一个<code>isJumping</code>或者<code>isOnGround</code>的布尔判断</p><p>再然后,你又想给你的角色添加一个冲刺的功能,如果你什么也不做,神奇的玩家或许会对冲刺中按下跳跃键后发生的事情感到啼笑皆非,这时候你又需要添加一个<code>isDashing</code>的布尔判断.然而实际开发中的需求可不会像上面的例子一样简单,你也不想你的代码里全是各种<code>if else</code>吧.</p>]]></content:encoded>
      
      
      
      
      <comments>http://rdququ.top/posts/1f1f5f6a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Game Programming Patterns_Prototype原型模式</title>
      <link>http://rdququ.top/posts/cb3ccb51/</link>
      <guid>http://rdququ.top/posts/cb3ccb51/</guid>
      <pubDate>Mon, 18 Sep 2023 15:05:27 GMT</pubDate>
      
      <description>&lt;p&gt;如果给你一个需求  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你需要设计出一群不同种类的可怖的怪物,让他们在英雄前进的道路上阻挡他们&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你会则表明怎么做呢?&lt;br&gt;或许当你刚接触游戏开发的时候,你会这样做&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>如果给你一个需求  </p><blockquote><p>你需要设计出一群不同种类的可怖的怪物,让他们在英雄前进的道路上阻挡他们</p></blockquote><p>你会则表明怎么做呢?<br>或许当你刚接触游戏开发的时候,你会这样做</p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Monster</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 代码……</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ghost</span> : <span class="keyword">public</span> Monster &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demon</span> : <span class="keyword">public</span> Monster &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sorcerer</span> : <span class="keyword">public</span> Monster &#123;&#125;;</span><br></pre></td></tr></table></figure><p>每一种怪物都有自己的类.为了让这些家伙降临到这个世界,或许你还会给他们精心设计独属于他们自己的生产者类(spawner).事实上,这是一种相当暴力的解决方案,每个怪物都有自己的生产者类,这构成了一种平行的类的结构.</p><p><img src="image.png" alt="Alt text"></p><blockquote><p>图上这个带尾巴的小三角形是继承的意思</p></blockquote><p>下面是该方案一种实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spawner</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Spawner</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Monster* <span class="title">spawnMonster</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GhostSpawner</span> : <span class="keyword">public</span> Spawner</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Monster* <span class="title">spawnMonster</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Ghost</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemonSpawner</span> : <span class="keyword">public</span> Spawner</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Monster* <span class="title">spawnMonster</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Demon</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  You get the idea...</span></span><br></pre></td></tr></table></figure><p>如果你和你的学长/前辈一起共事,那么作为经验丰富的代码世界的造物主,他肯定会想方设法阻止你 <code>&quot;这种代码很难维护.&quot;&quot;如果有策划设计了一千种怪物,那么你要专门为这个项目撰写一本字典吗?&quot;</code>显然,以这种方法创世,第七天肯定没法放假.</p><h2 id="一个更好的方法"><a href="#一个更好的方法" class="headerlink" title="一个更好的方法"></a>一个更好的方法</h2><p>前人给出了一个比上面的实现更具性价比的解决方案 <code>设计模式</code>.</p><blockquote><p>关键思路是<code>一个对象可以产出与它自己相近的对象</code>。 如果你有一个恶灵，你可以制造更多恶灵。 如果你有一个恶魔，你可以制造其他恶魔。 任何怪物都可以被视为<code>原型</code>怪物，产出其他版本的自己。</p></blockquote><p>为了实现这个功能,我们可以给基类<code>Monster</code>添加一个抽象方法<code>clone</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Monster</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Monster</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Monster* <span class="title">clone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Other stuff...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后,我们可以让每个怪物都实现这个方法,并且返回一个与它自己的类和状态都完全一样的新对象.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ghost</span> : <span class="keyword">public</span> Monster &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Ghost</span>(<span class="type">int</span> health, <span class="type">int</span> speed)</span><br><span class="line">  : <span class="built_in">health_</span>(health),</span><br><span class="line">    <span class="built_in">speed_</span>(speed)</span><br><span class="line">  &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Monster* <span class="title">clone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Ghost</span>(health_, speed_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> health_;</span><br><span class="line">  <span class="type">int</span> speed_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在,我们不再需要再给每个怪物都添加上他们自己的生产者类了,我们大可以写一个<code>Spawner</code>类,它可以接受一个<code>Monster</code>对象,并且使用<code>clone</code>方法来产生新的怪物.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Spawner</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Spawner</span>(Monster* prototype)</span><br><span class="line">  : <span class="built_in">prototype_</span>(prototype)</span><br><span class="line">  &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Monster* <span class="title">spawnMonster</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prototype_-&gt;<span class="built_in">clone</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Monster* prototype_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>重要的是</strong>,或者说他和抽离内部实现的接口思想有很大不同的一点是,他内部是存有<code>template</code>的,模板是怎样的,克隆出来的怪物就是怎样的.</p><p><img src="image-1.png" alt="Alt text"></p><p>书上举了一个很直观的例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Monster* ghostPrototype = <span class="keyword">new</span> <span class="built_in">Ghost</span>(<span class="number">15</span>, <span class="number">3</span>);</span><br><span class="line">Spawner* ghostSpawner = <span class="keyword">new</span> <span class="built_in">Spawner</span>(ghostPrototype);</span><br></pre></td></tr></table></figure><p>这段代码创建了一个恶灵的原型实例,然后创建了这个实例的生产者. 巧妙的是,我们只需要更改这个模板鬼魂的状态,就可以创建出各种各样的鬼魂.</p><p>看起来一切都搞定了</p><p>吗?</p><p>不说每个<code>clone</code>方法仍然需要我们自己去实现,这些工作量不比给每个怪物都写一个生产者类少多少,也不说实际程序开发中会遇到的不同的语义漏洞</p><blockquote><p>做深层拷贝还是浅层拷贝呢？换言之，如果恶魔拿着叉子，克隆恶魔也要克隆叉子吗？</p></blockquote><p>就说这种方法的前提就很难达成,在现代的游戏引擎上工作,还有谁会给每个怪物都设计一个自己的类?</p><h2 id="生产函数"><a href="#生产函数" class="headerlink" title="生产函数"></a>生产函数</h2><p>哪怕我们必须要为每个怪物都添加上一个独立的类,那么给给每个怪物都添加上一个分离的生产者类也并非上上之选,我们可以使用一个更加简单的方法,那就是使用一个生产函数.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Monster* <span class="title">spawnGhost</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Ghost</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面给出新方法的实现,可以看看这和上面的方法有什么区别?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Monster* (*SpawnCallback)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spawner</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Spawner</span>(SpawnCallback spawn)</span><br><span class="line">  : <span class="built_in">spawn_</span>(spawn)</span><br><span class="line">  &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Monster* <span class="title">spawnMonster</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">spawn_</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  SpawnCallback spawn_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>很显然,函数指针嘛,生产者类不需要再存储一个怪物对象了,它只需要储存一个函数指针就可以做到和之前一样的事情了.后面是构筑生产者的代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spawner* ghostSpawner = <span class="keyword">new</span> <span class="built_in">Spawner</span>(spawnGhost);</span><br></pre></td></tr></table></figure><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>模板没什么好说的,这是一个C++程序员必须掌握的一个编程方法.在另一些语言中其思想被推广为泛型<strong>T</strong></p><p>模板和许多高级语言中的继承或者接口不一样,这些机制大多是运行时才确定的(比如成员函数只有在运行时才知道调用哪个),所以被叫做<strong>运行时多态</strong>,而模板则是一种<strong>编译时多态</strong>,编译器在编译的时候就知道调用哪个函数了.代价是目标代码会多一点.</p><p>那么事情就很清楚了,如果我们把生产者类当作模板中的<code>T</code>(类型参数),我们就能实现这样一段代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Spawner</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Spawner</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Monster* <span class="title">spawnMonster</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpawnerFor</span> : <span class="keyword">public</span> Spawner</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Monster* <span class="title">spawnMonster</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">T</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以这样使用它</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spawner* ghostSpawner = <span class="keyword">new</span> <span class="built_in">SpawnerFor</span>&lt;Ghost&gt;();</span><br></pre></td></tr></table></figure><h2 id="第一公民类型"><a href="#第一公民类型" class="headerlink" title="第一公民类型"></a>第一公民类型</h2><p>在C++中，类型不是第一公民,所以我们需要进行一些小改动,不过在此之前,我们需要讨论一下什么是第一公民/第二公民</p><p>第一公民类型是指可以被当作参数传递,可以被当作返回值返回,可以被当作容器的元素的类型的类型.比如说,在C++中,函数不是第一公民类型,所以我们不能把函数当作参数传递给另一个函数,也不能把函数当作返回值返回,也不能把函数当作容器的元素的类型.</p><p>我们熟悉的 char, int, float等都是第一公民类型,不能满足的上述条件的,就是第二公民了.</p>]]></content:encoded>
      
      
      <category domain="http://rdququ.top/categories/Game-Programming-Patterns/">Game Programming Patterns</category>
      
      <category domain="http://rdququ.top/categories/Design-Patterns-Revisited/">Design Patterns Revisited</category>
      
      <category domain="http://rdququ.top/categories/Prototype-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/">Prototype(原型模式)</category>
      
      
      <category domain="http://rdququ.top/tags/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">游戏设计模式</category>
      
      <category domain="http://rdququ.top/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/">原型模式</category>
      
      <category domain="http://rdququ.top/tags/C/">C++</category>
      
      
      <comments>http://rdququ.top/posts/cb3ccb51/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>简单的无限地图实现</title>
      <link>http://rdququ.top/posts/c8583f8a/</link>
      <guid>http://rdququ.top/posts/c8583f8a/</guid>
      <pubDate>Sun, 17 Sep 2023 15:46:44 GMT</pubDate>
      
      <description>&lt;p&gt;突然想写一个类吸血鬼幸存者的 &lt;code&gt;demo&lt;/code&gt;, 想了一下无限地图挺重要的,于是就设计了一个简单的无限地图实现,感觉性能一般般,过两天找一下类似的代码比对一下性能,这个功能实现还是很简单的,今天记录一下.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>突然想写一个类吸血鬼幸存者的 <code>demo</code>, 想了一下无限地图挺重要的,于是就设计了一个简单的无限地图实现,感觉性能一般般,过两天找一下类似的代码比对一下性能,这个功能实现还是很简单的,今天记录一下.</p><span id="more"></span><h2 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a>数学原理</h2><p>呢讲到无限地图算法,首先就要考虑他的数学原理.我实现的这个方法也是目前应用比较广,实现起来也是最简单的那种了.</p><p><img src="image.png" alt="Alt text"></p><p>在这张图上,我们给出了原点$O$,橙色框所框中的是以玩家出生点为原点渲染出来的第一块地图,我们可以记为$M(0,0)$,图中还给出了框的长和宽$X$和$Y$,这里的红框和绿框的大小是相同的,他的的焦点,也是相交的几条边的中点.</p><p>玩家的视野范围,即摄像机所捕获的范围是不大于橙色框的<br>我们通过矩形的四个点就可以确定所需要渲染出的地图区块,比如说当玩家在所示绿框中活动的时候,我们就需要渲染出$M(0,0),M(1,0),M(1,1),M(0,1)$这四块地图</p><p>整张地图所需要记录的只是以$X$为X轴上的单位长度和以$Y$为Y轴上的单位长度组成的点阵图,当玩家处于任意四个点组成的举行范围内时,我们只需要把以这四个点为中点,以$X$和$Y$为长和宽的标准地图就可以了.</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>首先我们定义一个结构体来储存我们的地图信息</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 地图数据</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> MapData</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> MapUnit map;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个结构体中有三个成员,<code>map</code>是一个<code>MapUnit</code>类型的变量,<code>X</code>和<code>Y</code>分别是以<code>X</code>和<code>Y</code>为单位长度的坐标.</p><p>下面放一下<code>MapUnit</code>的定义</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MapUnit</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> MapData _myData;</span><br><span class="line">    <span class="keyword">private</span> MapUnit _mapUnit;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MapManager.Instance.mapList.Add(_myData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (MapManager.Instance.checkPlayerPosition(transform))</span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MapData <span class="title">GetMyData</span>(<span class="params"><span class="built_in">int</span> _X, <span class="built_in">int</span> _Y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _myData = <span class="keyword">new</span> MapData()</span><br><span class="line">        &#123;</span><br><span class="line">            map = _mapUnit,</span><br><span class="line">            X = _X,</span><br><span class="line">            Y = _Y</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> _myData;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MapManager.Instance.mapList.Remove(_myData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也很简单,这个类有两个成员字段,分别存贮自己的地图数据和自己的脚本,他还有一个方法,用来获取自己的地图数据.<br>在<code>Start</code>方法中,我们把自己的地图数据添加到<code>MapManager</code>的<code>mapList</code>中,在<code>Update</code>方法中,地图会自行检测自己是否在玩家的视野范围内,如果是,就销毁自己,在<code>OnDestroy</code>方法中,他会把自己的地图数据从<code>MapManager</code>的<code>mapList</code>中移除.</p><p>最后来看一下地图管理类的实现</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> Unity.Mathematics;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MapManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MapManager Instance;</span><br><span class="line">    <span class="keyword">private</span> GameObject _player;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> _playerLive;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _mapX;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _mapY;</span><br><span class="line">    <span class="keyword">public</span> GameObject mapPrefabs;</span><br><span class="line">    <span class="keyword">public</span> Transform grid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;MapData&gt; mapList = <span class="keyword">new</span> List&lt;MapData&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Instance = <span class="keyword">this</span>;</span><br><span class="line">        _mapX = <span class="number">18</span>;</span><br><span class="line">        _mapY = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_playerLive)</span><br><span class="line">        &#123;</span><br><span class="line">            ConrtolAutoMap();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 获取玩家对象</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;player&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetPlayer</span>(<span class="params">GameObject player</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _player = player;</span><br><span class="line">        _playerLive = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 自动检查玩家身边的地图,并自动加载未加载地图</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConrtolAutoMap</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> x = _player.transform.position.x;</span><br><span class="line">        <span class="keyword">var</span> y = _player.transform.position.y;</span><br><span class="line">        <span class="built_in">int</span> X = (<span class="built_in">int</span>)x / _mapX;</span><br><span class="line">        <span class="built_in">int</span> Y = (<span class="built_in">int</span>)y / _mapY;</span><br><span class="line">        <span class="built_in">int</span> XX = x &gt; <span class="number">0</span> ? X + <span class="number">1</span> : X - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> YY = y &gt; <span class="number">0</span> ? Y + <span class="number">1</span> : Y - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!CheckMapLive(X, Y))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> newMap = Instantiate(mapPrefabs, <span class="keyword">new</span> Vector3(X * _mapX, Y * _mapY), quaternion.identity,grid);</span><br><span class="line">            newMap.GetComponent&lt;MapUnit&gt;().GetMyData(X, Y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!CheckMapLive(XX, Y))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> newMap = Instantiate(mapPrefabs, <span class="keyword">new</span> Vector3((XX) * _mapX, Y * _mapY), quaternion.identity,grid);</span><br><span class="line">            newMap.GetComponent&lt;MapUnit&gt;().GetMyData(XX, Y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!CheckMapLive(X, YY))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> newMap = Instantiate(mapPrefabs, <span class="keyword">new</span> Vector3(X * _mapX, (YY) * _mapY), quaternion.identity,grid);</span><br><span class="line">            newMap.GetComponent&lt;MapUnit&gt;().GetMyData(X, YY);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!CheckMapLive(XX, YY))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> newMap = Instantiate(mapPrefabs, <span class="keyword">new</span> Vector3((XX) * _mapX, (YY) * _mapY), quaternion.identity,grid);</span><br><span class="line">            newMap.GetComponent&lt;MapUnit&gt;().GetMyData(XX, YY);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 检查目标地点是否存在地图单元</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;x_target&quot;&gt;</span>坐标x<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;y_target&quot;&gt;</span>坐标y<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>存在返回true<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">CheckMapLive</span>(<span class="params"><span class="built_in">int</span> x_target, <span class="built_in">int</span> y_target</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> target =</span><br><span class="line">            <span class="keyword">from</span> m <span class="keyword">in</span> mapList</span><br><span class="line">            <span class="keyword">where</span> m.X == x_target &amp;&amp; m.Y == y_target</span><br><span class="line">            <span class="keyword">select</span> m.map;</span><br><span class="line">        <span class="keyword">return</span> target.Any();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 检查地图块是否已经超出了玩家的区块范围</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;t&quot;&gt;</span>地图的Transform<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>如果地图快已经超出了玩家的区块范围,则返回true<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">checkPlayerPosition</span>(<span class="params">Transform t</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> math.abs(t.position.x - _player.transform.position.x) &gt; _mapX ||</span><br><span class="line">               math.abs(t.position.y - _player.transform.position.y) &gt; _mapY</span><br><span class="line">            ? <span class="literal">true</span></span><br><span class="line">            : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        mapList.Clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然,写的有点蠢,不过好歹能用,生成不同地图的方法也很简单,多做几个预制体,生成的时候写一个随机方法就可以了.</p><p>过两天把这个优化一下.</p><hr>]]></content:encoded>
      
      
      <category domain="http://rdququ.top/categories/%E8%AE%B0%E5%BD%95%E5%90%91/">记录向</category>
      
      <category domain="http://rdququ.top/categories/%E8%AE%B0%E5%BD%95%E5%90%91/Unity/">Unity</category>
      
      
      <category domain="http://rdququ.top/tags/Unity/">Unity</category>
      
      <category domain="http://rdququ.top/tags/C/">C#</category>
      
      <category domain="http://rdququ.top/tags/%E6%97%A0%E9%99%90%E5%9C%B0%E5%9B%BE/">无限地图</category>
      
      
      <comments>http://rdququ.top/posts/c8583f8a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>简单的事件中心</title>
      <link>http://rdququ.top/posts/63fcc5fa/</link>
      <guid>http://rdququ.top/posts/63fcc5fa/</guid>
      <pubDate>Sat, 16 Sep 2023 12:44:41 GMT</pubDate>
      
      <description>&lt;p&gt;下面给出一个简单的事件中心的实现&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>下面给出一个简单的事件中心的实现</p><span id="more"></span><p>首先是事件类型</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 事件类型</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> EventType</span><br><span class="line">&#123;</span><br><span class="line">    Speed,Frozen,Pause,UnPause,Dash,GameOver</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后是事件中心</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 事件中心，负责注册、发布事件</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventCenter</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EventCenter _instance = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EventCenter Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                _instance = <span class="keyword">new</span> EventCenter();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> _instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Dictionary&lt;EventType, List&lt;Action&gt;&gt; eventDict = <span class="keyword">new</span> Dictionary&lt;EventType, List&lt;Action&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EventCenter</span>()</span> &#123; &#125;<span class="comment">//私有构造函数，防止外部实例化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 订阅事件</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventType&quot;&gt;</span>事件类型<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventHandler&quot;&gt;</span>事件处理方法<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SubscribeEvent</span>(<span class="params">EventType eventType, Action eventHandler</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventDict.ContainsKey(eventType))</span><br><span class="line">        &#123;</span><br><span class="line">            eventDict[eventType].Add(eventHandler);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;Action&gt; list = <span class="keyword">new</span> List&lt;Action&gt;();</span><br><span class="line">            list.Add(eventHandler);</span><br><span class="line">            eventDict.Add(eventType, list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 取消订阅事件</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventType&quot;&gt;</span>事件类型<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventHandler&quot;&gt;</span>事件处理方法<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveSubscribedEvent</span>(<span class="params">EventType eventType, Action eventHandler</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(eventDict.ContainsKey(eventType))</span><br><span class="line">        &#123;</span><br><span class="line">            eventDict[eventType].Remove(eventHandler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 发布事件</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventType&quot;&gt;</span>事件类型<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PublishEvent</span>(<span class="params">EventType eventType</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventDict.ContainsKey(eventType))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (Action handler <span class="keyword">in</span> eventDict[eventType])</span><br><span class="line">            &#123;</span><br><span class="line">                handler?.Invoke();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content:encoded>
      
      
      <category domain="http://rdququ.top/categories/%E4%BB%A3%E7%A0%81%E5%BA%93/">代码库</category>
      
      <category domain="http://rdququ.top/categories/%E4%BB%A3%E7%A0%81%E5%BA%93/Unity/">Unity</category>
      
      
      <category domain="http://rdququ.top/tags/%E4%BA%8B%E4%BB%B6-Unity-C/">事件,Unity,C#</category>
      
      
      <comments>http://rdququ.top/posts/63fcc5fa/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Unity中空判断与Destroy实现</title>
      <link>http://rdququ.top/posts/da6ffe54/</link>
      <guid>http://rdququ.top/posts/da6ffe54/</guid>
      <pubDate>Sat, 16 Sep 2023 04:59:37 GMT</pubDate>
      
      <description>&lt;p&gt;以往我在做空判断的时候，都是这样写的：&lt;/p&gt;
&lt;figure class=&quot;highlight csharp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (gameobject != &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;或者是&lt;/p&gt;
&lt;figure class=&quot;highlight csharp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (gameobject == &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最近换了Rider， 他给我来了句提示&lt;code&gt;与 &amp;#39;null&amp;#39; 的比较开销较大&lt;/code&gt;,奇奇怪怪，我换成了  &lt;code&gt;if(gameobject)&lt;/code&gt; 就没有这些提示了，那么这两种写法到底有什么区别呢？&lt;br&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>以往我在做空判断的时候，都是这样写的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (gameobject != <span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p>或者是</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (gameobject == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>最近换了Rider， 他给我来了句提示<code>与 &#39;null&#39; 的比较开销较大</code>,奇奇怪怪，我换成了  <code>if(gameobject)</code> 就没有这些提示了，那么这两种写法到底有什么区别呢？<br> <span id="more"></span></p><p>要讨论这两个问题，还真不是很简单，我们首先要了解<code>Object</code>,这里的<code>Object</code>是<code>System.Object</code>，也是<code>UnityEngine.Object</code>。</p><p><code>System.Object</code>大家都很好理解，我们来看看<code>UnityEngine.Object</code>吧。</p><p><code>UnityEngine.Object</code>继承自<code>system.Object</code>，是<code>Unity</code>所涉及所有物体的基类。</p><p>但是他们也有区别，不得不谈的就是<code>销毁</code>和<code>空判断</code>。</p><blockquote><p>这是最常见的问题，在UnityEngine中我们销毁一个对象时，使用“==”操作符与null比较结果为true，但是可以发现，我们还是可以引用这个变量，这主要是由于UnityEngine的==操作符在销毁后即将Object置位null，但是对象本身需要被GC后才能达到真正意义上的销毁，也就是System.Object中的null；</p><p>这里涉及到了托管的问题，如果不了解也不要紧，我可以告诉你从 UnityEngine.Object 继承的对象，包括托管和非托管两部分，当调用 Destroy 时，销毁的只是非托管部分，托管部分只能通过 C# 的垃圾回收器进行回收。</p></blockquote><p>什么意思呢，我们直接来看<code>Destroy</code>会更清晰一点</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span>   <span class="doctag">&lt;para&gt;</span>Removes a GameObject, component or asset.<span class="doctag">&lt;/para&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;obj&quot;&gt;</span>The object to destroy.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;t&quot;&gt;</span>The optional amount of time to delay before destroying the object.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">[<span class="meta">NativeMethod(Name = <span class="string">&quot;Scripting::DestroyObjectFromScripting&quot;</span>, IsFreeFunction = true, ThrowsException = true)</span>]</span><br><span class="line">[<span class="meta">MethodImpl(MethodImplOptions.InternalCall)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Destroy</span>(<span class="params">Object obj, [DefaultValue(<span class="string">&quot;0.0F&quot;</span></span>)] <span class="built_in">float</span> t)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span>   <span class="doctag">&lt;para&gt;</span>Removes a GameObject, component or asset.<span class="doctag">&lt;/para&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;obj&quot;&gt;</span>The object to destroy.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;t&quot;&gt;</span>The optional amount of time to delay before destroying the object.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">[<span class="meta">ExcludeFromDocs</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Destroy</span>(<span class="params">Object obj</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">float</span> t = <span class="number">0.0f</span>;</span><br><span class="line">  Object.Destroy(obj, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Unity 自己的文档讲的很清楚了， 我们来看“了解托管堆”这一节</p><blockquote><p>垃圾回收器定期运行（<strong>注意：</strong>具体运行时间视平台而定）。这时将扫描堆上的所有对象，将任何不再引用的对象标记为删除。然后会删除未引用的对象，从而释放内存。</p></blockquote><p>Unity 用了一种很讨巧的方法，他们把 <code>destroy</code> 掉的内存标记为 <code>&#39;null&#39;</code>，事实上，这些内存并没有被回收，而是在等待 C# 的 <code>GC</code> 把他们回收掉。</p><p>我们再来看看<code>Unity</code>对于<code>==</code>的重载</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="keyword">operator</span> ==(Object x, Object y) =&gt; Object.CompareBaseObjects(x, y);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="keyword">operator</span> !=(Object x, Object y) =&gt; !Object.CompareBaseObjects(x, y);</span><br></pre></td></tr></table></figure><p>还有其对布尔类型的重载</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">bool</span>(<span class="params">Object exists</span>)</span> =&gt; !Object.CompareBaseObjects(exists, (Object) <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>可以发现<code>CompareBaseObjects</code>方法的实现也是绕不开的，我们来看看</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">CompareBaseObjects</span>(<span class="params">Object lhs, Object rhs</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">bool</span> flag1 = (<span class="built_in">object</span>) lhs == <span class="literal">null</span>;</span><br><span class="line">      <span class="built_in">bool</span> flag2 = (<span class="built_in">object</span>) rhs == <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (flag2 &amp; flag1)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (flag2)</span><br><span class="line">        <span class="keyword">return</span> !Object.IsNativeObjectAlive(lhs);</span><br><span class="line">      <span class="keyword">return</span> flag1 ? !Object.IsNativeObjectAlive(rhs) : lhs.m_InstanceID == rhs.m_InstanceID;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看到这里，其实我们已经对之前的问题有了回答了</p><p><code>UnityEngine.Object</code>中的布尔类型重载和<code>==</code>运算符重载，他们都是通过<code>CompareBaseObjects</code>来实现的<br>他们俩本质上都是采用了 <code>Unity</code> 层面上的检查。</p><p>对于这点，我们也可以证明</p><p>请看方法<code>IsNativeObjectAlive</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsNativeObjectAlive</span>(<span class="params">Object o</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> (o.GetCachedPtr() != IntPtr.Zero)</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     <span class="keyword">return</span> !(o <span class="keyword">is</span> MonoBehaviour) &amp;&amp; !(o <span class="keyword">is</span> ScriptableObject) &amp;&amp; Object.DoesObjectWithInstanceIDExist(o.GetInstanceID());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>Unity</code> 先调用<code>o.GetCachedPtr()</code> 方法检查目标对象的本机指针是否还存在, 要知道 <code>IntPtr</code> 并非 <code>Unity</code> 自己鼓捣出来的玩意， 他是<code>.NET Framework</code>和 <code>.NET Core</code>中的一个特殊的结构体，用于表示目标对象的本地指针. 如果本地指针不存在，那么就会调用<code>Object.DoesObjectWithInstanceIDExist</code>方法，这个方法会检查目标对象的实例ID是否存在,如果存在具有给定实例ID的对象，则返回 true.</p><p>通过这种方法实现的空判断,实质上开销是特别大的,有些人会使用<code>System.Object.ReferenceEquals</code>,比如这样</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(System.Object.ReferenceEquals(gameobject, <span class="literal">null</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// TODO something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做,在性能上确实是有很大提升的,但是读到这里的朋友估计已经猜到我要讲什么了.<br>在执行<code>destroy</code>方法后,目标对象实质上并没有被回收,他只是被打上了一个<code>&#39;tag&#39;</code>的标签,而变量仍然在指向着堆对象.为什么<code>==</code>可以呢,因为<code>Unity</code>已经把他重载了.</p><hr>]]></content:encoded>
      
      
      <category domain="http://rdququ.top/categories/%E8%AE%B0%E5%BD%95%E5%90%91/">记录向</category>
      
      <category domain="http://rdququ.top/categories/%E8%AE%B0%E5%BD%95%E5%90%91/Unity/">Unity</category>
      
      <category domain="http://rdququ.top/categories/%E8%AE%B0%E5%BD%95%E5%90%91/Unity/GC/">GC</category>
      
      
      <category domain="http://rdququ.top/tags/GC-Unity-%E5%86%85%E5%AD%98-C-%E7%A9%BA%E5%BC%95%E7%94%A8%E5%88%A4%E6%96%AD-Destroy/">GC,Unity,内存,C#,空引用判断,Destroy</category>
      
      
      <comments>http://rdququ.top/posts/da6ffe54/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Unity文件读写方法之StreamingAssets</title>
      <link>http://rdququ.top/posts/fc36bd86/</link>
      <guid>http://rdququ.top/posts/fc36bd86/</guid>
      <pubDate>Sat, 26 Aug 2023 07:27:35 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;StreamingAssets-文件夹&quot;&gt;&lt;a href=&quot;#StreamingAssets-文件夹&quot; class=&quot;headerlink&quot; title=&quot;StreamingAssets 文件夹&quot;&gt;&lt;/a&gt;StreamingAssets 文件夹&lt;/h2&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="StreamingAssets-文件夹"><a href="#StreamingAssets-文件夹" class="headerlink" title="StreamingAssets 文件夹"></a>StreamingAssets 文件夹</h2>]]></content:encoded>
      
      
      
      
      <comments>http://rdququ.top/posts/fc36bd86/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>XML介绍和增删改查</title>
      <link>http://rdququ.top/posts/eb414ab7/</link>
      <guid>http://rdququ.top/posts/eb414ab7/</guid>
      <pubDate>Sat, 26 Aug 2023 04:42:30 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;什么是-XML&quot;&gt;&lt;a href=&quot;#什么是-XML&quot; class=&quot;headerlink&quot; title=&quot;什么是 XML&quot;&gt;&lt;/a&gt;什么是 XML&lt;/h2&gt;&lt;p&gt;XML 指可扩展标记语言（eXtensible Markup Language）。&lt;/p&gt;
&lt;p&gt;XML 被设计用来传输和存储数据 -&amp;gt; 仅关注数据本身&lt;/p&gt;
&lt;p&gt;XML 被设计为具有自我描述性。&lt;br&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="什么是-XML"><a href="#什么是-XML" class="headerlink" title="什么是 XML"></a>什么是 XML</h2><p>XML 指可扩展标记语言（eXtensible Markup Language）。</p><p>XML 被设计用来传输和存储数据 -&gt; 仅关注数据本身</p><p>XML 被设计为具有自我描述性。<br> <span id="more"></span></p><h2 id="XML-的基本语法"><a href="#XML-的基本语法" class="headerlink" title="XML 的基本语法"></a>XML 的基本语法</h2><h3 id="XML-简单的使用案例"><a href="#XML-简单的使用案例" class="headerlink" title="XML 简单的使用案例"></a>XML 简单的使用案例</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget me this weekend!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="XML-的树结构"><a href="#XML-的树结构" class="headerlink" title="XML 的树结构"></a>XML 的树结构</h3><p>我们这里给出实例和图片的对应关系</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;COOKING&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Everyday Italian<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>Giada De Laurentiis<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>30.00<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;CHILDREN&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Harry Potter<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>J K. Rowling<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>29.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;WEB&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Learning XML<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>Erik T. Ray<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">year</span>&gt;</span>2003<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>39.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="XML介绍和增删改查\nodetree.gif" alt="XML 树结构"></p><h3 id="XML-文档的声明-可选的"><a href="#XML-文档的声明-可选的" class="headerlink" title="XML 文档的声明(可选的)"></a>XML 文档的声明(可选的)</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br></pre></td></tr></table></figure><p>声明不是 xml 文档本身的一部分</p><h3 id="XML-注意事项"><a href="#XML-注意事项" class="headerlink" title="XML 注意事项"></a>XML 注意事项</h3><ul><li>XML 标签对大小写敏感</li><li>XML 必须正确地嵌套</li><li>XML 文档必须有根元素</li><li>XML 属性值必须加引号</li><li>使用预定义的实体引用来代替 “&lt;” 和 “&amp;” 等特殊字符</li></ul><div class="table-container"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td><code>&amp;lt;</code></td><td>&lt;</td><td>less than</td></tr><tr><td><code>&amp;gt;</code></td><td>&gt;</td><td>greater than</td></tr><tr><td><code>&amp;amp;</code></td><td>&amp;</td><td>ampersand</td></tr><tr><td><code>&amp;apos;</code></td><td>‘</td><td>apostrophe</td></tr><tr><td><code>&amp;quot;</code></td><td>“</td><td>quotation mark</td></tr></tbody></table></div><ul><li>XML 中的注释从 <!-- 开始，--> 结束</li><li>XML 中的特殊字符必须被转义</li><li>XML 中的空格会被保留</li><li>XML 以 LF 存储换行</li><li>XML 元素名称可以包含字母、数字以及其他的字符</li><li>XML 元素名称不能以数字或者标点符号开始</li><li>XML 元素名称不能以字母 xml（或者 XML、Xml 等等）开始</li><li>XML 元素名称不能包含空格</li></ul><h3 id="XML-属性"><a href="#XML-属性" class="headerlink" title="XML 属性"></a>XML 属性</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;CHILDREN&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>属性提供有关元素的额外信息</li><li>属性始终在元素的开始标签中规定</li><li>属性总是以名称/值的形式出现，比如：name=”value”</li><li>属性值必须被引号包围，单引号和双引号都可以使用</li><li>属性值必须是合法的 XML 数据类型</li><li>属性不能包含多个值，不能折行</li></ul><h2 id="Unity-中-XML-的增删改查"><a href="#Unity-中-XML-的增删改查" class="headerlink" title="Unity 中 XML 的增删改查"></a>Unity 中 XML 的增删改查</h2><h3 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Xml;</span><br><span class="line">...</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">CreateXML</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> localPath = UnityEngine.Application.dataPath + <span class="string">&quot;/Resources/Data/&quot;</span> + <span class="string">&quot;DeckData.xml&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!File.Exists(localPath))</span><br><span class="line">        &#123;</span><br><span class="line">            XmlDocument xml = <span class="keyword">new</span> XmlDocument();</span><br><span class="line">            XmlDeclaration xmldecl = xml.CreateXmlDeclaration(<span class="string">&quot;1.0&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>, <span class="string">&quot;&quot;</span>);<span class="comment">//设置xml文件编码格式为UTF-8</span></span><br><span class="line">            XmlElement root = xml.CreateElement(<span class="string">&quot;Data&quot;</span>);<span class="comment">//创建根节点</span></span><br><span class="line">            xml.AppendChild(root);</span><br><span class="line">            xml.Save(localPath);<span class="comment">//保存xml到路径位置</span></span><br><span class="line">            Debug.Log(<span class="string">&quot;创建XML成功!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WriteDeckDataToXML</span>(<span class="params"><span class="built_in">string</span> deckName,Dictionary&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt; deckCards</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">var</span> localPath = UnityEngine.Application.dataPath + <span class="string">&quot;/Resources/Data/&quot;</span> + <span class="string">&quot;DeckData.xml&quot;</span>;</span><br><span class="line">       <span class="keyword">if</span> (File.Exists(localPath))</span><br><span class="line">       &#123;</span><br><span class="line">           XmlDocument xml = <span class="keyword">new</span> XmlDocument();</span><br><span class="line">           xml.Load(localPath);<span class="comment">//加载xml文件</span></span><br><span class="line">           XmlNode root = xml.SelectSingleNode(<span class="string">&quot;Data&quot;</span>);<span class="comment">//获取根节点</span></span><br><span class="line">           <span class="keyword">if</span>(root.HasChildNodes)<span class="comment">//如果根节点有子节点(即有卡组数据</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">foreach</span> (XmlNode node <span class="keyword">in</span> root.ChildNodes)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">if</span> (node.Attributes[<span class="string">&quot;name&quot;</span>].Value == deckName)</span><br><span class="line">                   &#123;</span><br><span class="line">                       root.RemoveChild(node);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           XmlElement deck = xml.CreateElement(<span class="string">&quot;Deck&quot;</span>);<span class="comment">//创建子节点</span></span><br><span class="line">           deck.SetAttribute(<span class="string">&quot;name&quot;</span>, deckName);<span class="comment">//设置属性</span></span><br><span class="line">           <span class="keyword">foreach</span> (<span class="keyword">var</span> card <span class="keyword">in</span> deckCards)</span><br><span class="line">           &#123;</span><br><span class="line">               XmlElement cardElement = xml.CreateElement(<span class="string">&quot;Card&quot;</span>);</span><br><span class="line">               cardElement.SetAttribute(<span class="string">&quot;id&quot;</span>, card.Key.ToString());</span><br><span class="line">               cardElement.SetAttribute(<span class="string">&quot;count&quot;</span>, card.Value.ToString());</span><br><span class="line">               deck.AppendChild(cardElement);</span><br><span class="line">           &#125;</span><br><span class="line">           root.AppendChild(deck);</span><br><span class="line">           xml.Save(localPath);<span class="comment">//保存xml到路径位置</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReadDeckDataFromXML</span>(<span class="params"><span class="built_in">string</span> deckName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> card <span class="keyword">in</span> deckCards)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;card.Key: &quot;</span> + card.Key + <span class="string">&quot;card.Value: &quot;</span> + card.Value);</span><br><span class="line">        &#125;</span><br><span class="line">        Debug.Log(<span class="string">&quot;开始读取&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> localPath = UnityEngine.Application.dataPath + <span class="string">&quot;/Resources/Data/&quot;</span> + <span class="string">&quot;DeckData.xml&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (File.Exists(localPath))</span><br><span class="line">        &#123;</span><br><span class="line">            XmlDocument xml = <span class="keyword">new</span> XmlDocument();</span><br><span class="line">            xml.Load(localPath);<span class="comment">//加载xml文件</span></span><br><span class="line">            XmlNode root = xml.SelectSingleNode(<span class="string">&quot;Data&quot;</span>);<span class="comment">//获取根节点</span></span><br><span class="line">            <span class="keyword">if</span> (root.HasChildNodes)<span class="comment">//如果根节点有子节点(即有卡组数据</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">foreach</span> (XmlNode node <span class="keyword">in</span> root.ChildNodes)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (node.Attributes[<span class="string">&quot;name&quot;</span>].Value == deckName)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">foreach</span> (XmlNode card <span class="keyword">in</span> node.ChildNodes)</span><br><span class="line">                        &#123;</span><br><span class="line">                            deckCards.Add(<span class="built_in">int</span>.Parse(card.Attributes[<span class="string">&quot;id&quot;</span>].Value), <span class="built_in">int</span>.Parse(card.Attributes[<span class="string">&quot;count&quot;</span>].Value));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> card <span class="keyword">in</span> deckCards)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;card.Key: &quot;</span> + card.Key + <span class="string">&quot;card.Value: &quot;</span> + card.Value);</span><br><span class="line">        &#125;</span><br><span class="line">        Debug.Log(<span class="string">&quot;结束读取&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://rdququ.top/categories/%E6%95%99%E7%A8%8B%E5%90%91/">教程向</category>
      
      <category domain="http://rdququ.top/categories/%E6%95%99%E7%A8%8B%E5%90%91/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</category>
      
      <category domain="http://rdququ.top/categories/%E6%95%99%E7%A8%8B%E5%90%91/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/">Unity</category>
      
      <category domain="http://rdququ.top/categories/%E6%95%99%E7%A8%8B%E5%90%91/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/%E9%9B%86%E6%8D%A2%E5%BC%8F%E5%8D%A1%E7%89%8C%E6%B8%B8%E6%88%8F/">集换式卡牌游戏</category>
      
      
      <category domain="http://rdququ.top/tags/Unity/">Unity</category>
      
      <category domain="http://rdququ.top/tags/%E5%8D%A1%E7%89%8C%E6%B8%B8%E6%88%8F/">卡牌游戏</category>
      
      <category domain="http://rdququ.top/tags/%E6%95%99%E7%A8%8B%EF%BC%8CXML/">教程，XML</category>
      
      
      <comments>http://rdququ.top/posts/eb414ab7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>初读Snapshot Compressive Imaging: Principle, Implementation, Theory, Algorithms and Applications</title>
      <link>http://rdququ.top/posts/bcef6785/</link>
      <guid>http://rdququ.top/posts/bcef6785/</guid>
      <pubDate>Tue, 22 Aug 2023 13:26:12 GMT</pubDate>
      
      <description>&lt;p&gt;快照压缩成像：原理、实现、理论、算法和应用&lt;/p&gt;
&lt;p&gt;使用二维传感器捕获快照测量中的高维数据&lt;/p&gt;
&lt;h2 id=&quot;什么是-Snapshot-Compressive-Imaging-快照压缩成像-？&quot;&gt;&lt;a href=&quot;#什么是-Snapshot-Compressive-Imaging-快照压缩成像-？&quot; class=&quot;headerlink&quot; title=&quot;什么是 Snapshot Compressive Imaging (快照压缩成像)？&quot;&gt;&lt;/a&gt;什么是 Snapshot Compressive Imaging (快照压缩成像)？&lt;/h2&gt;&lt;h3 id=&quot;二维检测和高维-以3D为例-检测是什么？&quot;&gt;&lt;a href=&quot;#二维检测和高维-以3D为例-检测是什么？&quot; class=&quot;headerlink&quot; title=&quot;二维检测和高维(以3D为例)检测是什么？&quot;&gt;&lt;/a&gt;二维检测和高维(以3D为例)检测是什么？&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;p1.jpg&quot; alt=&quot;图一&quot;&gt;&lt;/p&gt;
&lt;p&gt;单目 3D 检测和 2D 检测具有相同的输入数据模态和不同的预测目标。2D 检测任务一般要求在给定一张输入图像后，检测出物体的类别和 2D 框；单目 3D 检测则设定在给定同样的一张二维图像下，检测出物体的类别和 3D 框，其中 3D 框通常拥有至少 7 个自由度：三维位置，三维框大小以及转向角&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>快照压缩成像：原理、实现、理论、算法和应用</p><p>使用二维传感器捕获快照测量中的高维数据</p><h2 id="什么是-Snapshot-Compressive-Imaging-快照压缩成像-？"><a href="#什么是-Snapshot-Compressive-Imaging-快照压缩成像-？" class="headerlink" title="什么是 Snapshot Compressive Imaging (快照压缩成像)？"></a>什么是 Snapshot Compressive Imaging (快照压缩成像)？</h2><h3 id="二维检测和高维-以3D为例-检测是什么？"><a href="#二维检测和高维-以3D为例-检测是什么？" class="headerlink" title="二维检测和高维(以3D为例)检测是什么？"></a>二维检测和高维(以3D为例)检测是什么？</h3><p><img src="p1.jpg" alt="图一"></p><p>单目 3D 检测和 2D 检测具有相同的输入数据模态和不同的预测目标。2D 检测任务一般要求在给定一张输入图像后，检测出物体的类别和 2D 框；单目 3D 检测则设定在给定同样的一张二维图像下，检测出物体的类别和 3D 框，其中 3D 框通常拥有至少 7 个自由度：三维位置，三维框大小以及转向角</p><span id="more"></span><h3 id="驱动任务"><a href="#驱动任务" class="headerlink" title="驱动任务"></a>驱动任务</h3><p>Snapshot compressive imaging (SCI) uses a two-dimensional (2D) detector to capture HD (≥ 3D) data in a snapshot measurement.<br>Via novel optical designs, the 2D detector samples the HD data in<br>a compressive manner; following this, algorithms are employed to reconstruct the desired HD data-cube</p><p>快照压缩成像（SCI）使用二维（2D）探测器在快照测量中捕获高维（≥3D）数据。通过新颖的光学设计，2D探测器以压缩方式采样高维数据；随后，使用算法重建所需的高维数据立方体</p><h3 id="什么是-Data-Cube-数据立方体-？"><a href="#什么是-Data-Cube-数据立方体-？" class="headerlink" title="什么是 Data-Cube (数据立方体)？"></a>什么是 Data-Cube (数据立方体)？</h3><p>数据立方体是一种多维数据模型, 并且只有三维。</p><p><img src="Data-Cube.png" alt="数据立方体"></p><h4 id="什么是多维数据模型？"><a href="#什么是多维数据模型？" class="headerlink" title="什么是多维数据模型？"></a>什么是多维数据模型？</h4><p>多维模型的相关概念：</p><ul><li>多维数据模型：为了满足用户从多角度多层次进行数据查询和分析的需要而建立起来的基于事实和维的数据库模型，其基本的应用是为了实现OLAP（Online Analytical Processing）</li><li>立方体：它是由维度构建出来的多维空间，包含了所要分析的基础数据，所有的聚合数据操作都在它上面进行</li><li>维度：观察数据的一种角度，比如在上图中address、item、time都可以被看作一个维度，直观上来看维度是一个立方体的轴，比如三个维度可以构成一个立方体的空间</li><li>维度成员：构成维度的基本单位，比如对于time维，包含Q1、Q2、Q3、Q4四个维度成员</li><li>层次：维度的层次结构，它存在两种：自然层次和用户自定义层次。比如对于时间维，可以分为年、月、日三个层次，也可以分为年、季度、月三个层次。一个维可以有多个层次，它是单位数据聚集的一种路径</li><li>级别：级别组成层次，比如年、月、日分别是时间维的三个级别</li><li>度量：一个数值函数，可以对数据立方体空间中的每个点求值；度量值自然就是度量的结果</li><li>事实表：存放度量值得表，同时存放了维表得外键，所有分析所用得数据最终都来自事实表</li><li>维表：对于维度的描述，每个维度对应一个或多个维表，一个维度对应一个表的是星型模式，对应多个表的是雪花模式</li><li>OLAP：Online Analytical Processing，联机分析处理，是一种多维、分析式的查询处理技术，它是一种基于维度的数据分析方法，它的基本特征是：面向主题、集成性、时序性、非易失性、动态性、客户/服务器结构、开放式的数据库连接、多维数据分析、灵活的报表生成、图形化的用户界面</li></ul><p><img src="多维模型.png" alt="多维数据模型"></p><h3 id="什么是-CS-Compressive-Sensing-『压缩感知』"><a href="#什么是-CS-Compressive-Sensing-『压缩感知』" class="headerlink" title="什么是 CS (Compressive Sensing) 『压缩感知』?"></a>什么是 CS (Compressive Sensing) 『压缩感知』?</h3><p>压缩感知本质上一个线性逆问题 (linear inverse problem)，目的是从少量的线性测量 (linear measurements) 中还原高维的信号。</p><h4 id="什么是线性反问题-linear-inverse-problem-？"><a href="#什么是线性反问题-linear-inverse-problem-？" class="headerlink" title="什么是线性反问题 (linear inverse problem)？"></a>什么是线性反问题 (linear inverse problem)？</h4><p>在数学上,一对问题称为是互逆的，如果一个问题的表述或处理需要另一个问题解的信息；若把其中的一个问题称为正问题，另一个就称为反问题。</p><p>在物理问题上,反问题是指从一些带噪声的观测中试图还原出真实信息的行为,很好理解,这和上面的一点其实是一样的.</p><p>而对反问题而言,Well-posed和ill-posed的情况都是存在的,<a href="https://de.wikipedia.org/wiki/Inverses_Problem#:~:text=Inverses%20Problem%20Ein%20mathematisches%20Problem%20wird%20ein%20inverses,oft%20sehr%20schwierig%20oder%20manchmal%20gar%20nicht%20l%C3%B6sbar.">(Man unterscheidet <code>gut gestellte</code> und <code>schlecht gestellte</code> inverse Probleme. )</a></p><p>故而,想要理解求解 inverse problem 之难, 我们最好对适定问题（Well-posed problem）有一定的了解.</p><p>什么是适定问题（Well-posed problem）呢?<br>满足<code>解存在</code>、<code>唯一</code>且<code>连续依赖于定解条件</code>三个条件的问题,我们称之为 Well-posed problem ,反之,只要有一个条件不满足,则称之为不适定问题（ill-posed problems）</p><p>在图像识别领域且不仅在此领域,inverse problem 通常是 ill-posed problem.</p><p>到这里,什么是线性反问题 (linear inverse problem) 就很好理解了,就是从一些带噪声的观测中试图还原出真实信息的行为,且这个问题是一个线性问题.</p><h3 id="什么是-sparse-MRI-稀疏磁共振成像-？"><a href="#什么是-sparse-MRI-稀疏磁共振成像-？" class="headerlink" title="什么是 sparse MRI (稀疏磁共振成像)？"></a>什么是 sparse MRI (稀疏磁共振成像)？</h3><p>MRI (Magnetic Resonance Imaging) 磁共振成像是一种医学成像技术，它利用磁共振现象对人体进行成像，是一种无创的检查方法。MRI 通过对人体进行扫描，利用计算机对扫描结果进行处理，得到人体的图像。MRI 检查不仅可以对人体进行断层成像，还可以对人体进行三维成像，从而可以对人体进行全方位的观察。</p><h3 id="2-5D"><a href="#2-5D" class="headerlink" title="2.5D"></a>2.5D</h3><p>2.5D 通常指的是 2.5 维，即 2D + 1D，比如 2D 图像 + 1D 深度图<br>第六页写道  “Note that (x, y, z) denotes 3D tomography and we use (x, y)+z<br>to represent a 2D image plus a depth map, which is also called 2.5D in certain articles in the literature.”<br>(x,y)+z 当然是 2.5D</p><h2 id="SCI-的数学模型"><a href="#SCI-的数学模型" class="headerlink" title="SCI 的数学模型"></a>SCI 的数学模型</h2><p>前文中, 作者举了 video SCI &amp; spectral SCI 两个例子来介绍 SCI 的设计. 而在本节中, 作者为他们构建了一个统一的数学模型, 这个模型也方便嵌套在别的 3D SCI 中.<br>在模型中, 作者使用了 mask matrix, 我们需要再复习一下 mask 的概念.</p><h3 id="什么是-mask-掩膜"><a href="#什么是-mask-掩膜" class="headerlink" title="什么是 mask (掩膜)?"></a>什么是 mask (掩膜)?</h3><p>mask（掩码、掩膜）是深度学习中的常见操作。简单而言，其相当于在原始张量上盖上一层掩膜，从而屏蔽或选择一些特定元素, 其中掩膜的元素值为 0 或 1，0 表示屏蔽，1 表示选择。  </p><p>按照上述定义，非线性激活函数Relu（根据输出的正负区间进行简单粗暴的二分）、dropout机制（根据概率进行二分）都可以理解为泛化的mask操作。</p><p>正如其名 mask 在宏观上的表现就是<code>遮罩</code></p><p><img src="mask.png" alt="使用mask提取ROI区域"></p><h3 id="什么是-CASSI-Coded-Aperture-Snapshot-Spectral-Imaging-『编码孔径快照光谱成像』"><a href="#什么是-CASSI-Coded-Aperture-Snapshot-Spectral-Imaging-『编码孔径快照光谱成像』" class="headerlink" title="什么是 CASSI (Coded Aperture Snapshot Spectral Imaging) 『编码孔径快照光谱成像』"></a>什么是 CASSI (Coded Aperture Snapshot Spectral Imaging) 『编码孔径快照光谱成像』</h3><p>CASSI (coded aperture snapshot spectral imaging)是一种具有代表性的高光谱图像捕获SCI系统。</p><h3 id="Main-Difference-between-SCI-and-Single-Pixel-Imaging"><a href="#Main-Difference-between-SCI-and-Single-Pixel-Imaging" class="headerlink" title="Main Difference between SCI and Single-Pixel Imaging"></a>Main Difference between SCI and Single-Pixel Imaging</h3><p>二者主要的区别存在于 forward model 上.  </p><p>单像素相机的 sensing matrix (Φ) 是 dense matrix, 而 SCI 的 sensing matrix 是 sparse matrix.</p><p>单像素相机中,感知矩阵Φ的每一行对应于在场景（一个2D静态图像）x 上施加的调制器的一个模式。这些模式可以被视为对场景的编码方式，类似于将图像分成不同的部分或区域，并对每个部分应用不同的测量方式。</p><p>而单像素探测器会捕获这些模式下的测量结果，每个测量对应于感知矩阵Φ的一行。换句话说，通过应用感知矩阵的每个模式，探测器会测量场景中的某种特性或信息，然后这些测量结果会被组合成一个向量，通常表示为向量y。这个向量y可以被用来进行图像重建，从而还原出原始的2D静态图像x。</p><p>在SCI的感知矩阵Φ中，它被构建为Nt个对角矩阵的串联。每个对角矩阵对应于一个时间帧（frame），所以Nt代表了时间帧的数量。对角矩阵的概念是，在主对角线上有非零元素，其他位置都是零。每个对角矩阵中的非零元素用来表示该帧中特定位置的测量权重。</p><p>测量的每个元素是通过对应位置 x(a<br>3D or HD cube) 上不同<code>时间帧</code> Nt 中的元素进行加权求和得到的。这个过程涉及到应用mask (掩膜)对不同时间帧的信息进行调制，然后加权求和得到最终的测量结果。这些测量结果最终表示为向量y。</p><p>再者, 单像素相机中的密集矩阵较大, 存储起来消耗的资源也更多(如果是随机的, 我们肯定要去保存他) 当然,我们可以用 structural matrix 的方法来优化, 比如 DCT 或者 Hadamard matrix, 也可以使用一些经过排序或者特定设计的矩阵.</p><p>相比之下，在快照压缩成像中，虽然感知矩阵Φ要比单像素成像中的感知矩阵大，但我们不需要存储整个$Φ$矩阵，只需要存储 mask (Φ 中的 $N^t$ 个对角元素)。由于$Φ$的特殊结构，观察到$ΦΦ^T$是一个对角矩阵。这个性质在文献中被用来加速快照压缩成像的重建算法。这种对角性质可以利用，使得重建算法更高效。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p><a href="https://zhuanlan.zhihu.com/p/400191167">“3Dfy” A General 2D Detector: 纯视觉 3D 检测再思考</a></p></li><li><p><a href="https://blog.csdn.net/forlogen/article/details/88634117">数据立方体（Data Cube）</a></p></li><li><p><a href="https://www.zhihu.com/question/28552876">如何理解压缩感知(compressive sensing)？</a></p></li><li><p><a href="https://www.rebellionresearch.com/what-is-sensing-matrix">What is sensing matrix?</a></p></li></ol>]]></content:encoded>
      
      
      
      
      <comments>http://rdququ.top/posts/bcef6785/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Unity集换式卡牌游戏_Dictionry序列化成json</title>
      <link>http://rdququ.top/posts/5e1ac7cf/</link>
      <guid>http://rdququ.top/posts/5e1ac7cf/</guid>
      <pubDate>Mon, 21 Aug 2023 06:57:15 GMT</pubDate>
      
      <description>&lt;p&gt;在开始讲解这一章节前，我们需要了解，什么是 Json.&lt;/p&gt;
&lt;h2 id=&quot;Json&quot;&gt;&lt;a href=&quot;#Json&quot; class=&quot;headerlink&quot; title=&quot;Json&quot;&gt;&lt;/a&gt;Json&lt;/h2&gt;&lt;p&gt;他的全称是 JavaScript Object Notation 【JavaScript 对象表示法】&lt;br&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>在开始讲解这一章节前，我们需要了解，什么是 Json.</p><h2 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h2><p>他的全称是 JavaScript Object Notation 【JavaScript 对象表示法】<br> <span id="more"></span><br>JSON 是存储和交换文本信息的<code>语法</code>。类似 XML。json是基于<code>ECMAScript</code>语法，但这并不意味着 json 必须在 js 中使用，或者必须要产生什么联系， json 在 js 中的处理也并没有比其他语言占有更多优势。只是因为语法相似，而使得js开发者能更快的上手 json 而已。</p><p>JSON采用完全独立于任何程序语言的文本格式,但是也使用了类似于 C 语言家族的习惯（包括 C、C++、C#、Java、JavaScript、Perl、Python 等）。这些特性使 JSON 成为理想的数据交换语言。易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。  </p><h3 id="典型的-Json-数据"><a href="#典型的-Json-数据" class="headerlink" title="典型的 Json 数据"></a>典型的 Json 数据</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">对象：</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;火球术&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;cost&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Owner&quot;</span><span class="punctuation">:</span> <span class="string">&quot;法师&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">数组：</span><br><span class="line"><span class="punctuation">[</span><span class="string">&quot;hello&quot;</span><span class="punctuation">,</span><span class="number">3.1415</span><span class="punctuation">,</span><span class="string">&quot;json&quot;</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">数组嵌套对象：</span><br><span class="line"><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;admin&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">18</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;root&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">16</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">20</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><h3 id="Json-语法规则"><a href="#Json-语法规则" class="headerlink" title="Json 语法规则"></a>Json 语法规则</h3><ul><li>数据在 <code>键值对</code> 中</li><li>数据由逗号 , 分隔</li><li>使用斜杆 \ 来转义字符</li><li>大括号 {} 保存对象</li><li>中括号 [] 保存数组，数组可以包含多个对象</li></ul><h4 id="json-的值"><a href="#json-的值" class="headerlink" title="json 的值"></a>json 的值</h4><ul><li>数字（整数或浮点数）</li><li>字符串（在双引号中）</li><li>逻辑值（true 或 false）</li><li>数组（在中括号中）</li><li>对象（在大括号中）</li><li>null</li></ul><h2 id="JsonUtility"><a href="#JsonUtility" class="headerlink" title="JsonUtility"></a>JsonUtility</h2><p>JsonUtility 是 Unity 提供的一个工具类，用于序列化和反序列化 Json 数据。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="built_in">string</span> json = JsonUtility.ToJson(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line">myObject = JsonUtility.FromJson&lt;T&gt;(json);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 Json 文本中读取数据并将其反序列化到现有对象中。</span></span><br><span class="line">FromJsonOverwrite(<span class="built_in">string</span> text, <span class="built_in">object</span> objectToOverwrite)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ToJson(<span class="built_in">object</span> target, <span class="built_in">bool</span> prettyPrint)</span><br><span class="line">target：对象转换为 Json 数据文本</span><br><span class="line">prettyPrint：决定最终的 Json 数据文本是否是一个格式化后的数据文本。</span><br><span class="line">即是否使用 Json 文本的 Format 化。</span><br><span class="line"></span><br><span class="line">FromJson(<span class="built_in">string</span> text)</span><br><span class="line">将 Json 数据文本转存至类中 <span class="keyword">public</span> 或 附有 SerializeField 特性的字段上赋值。</span><br><span class="line">使用时无需管理值具体分配。其将基于字段命名自行匹配并赋值。</span><br><span class="line">此代码将创建一个新的 T 实例，并使用 JSON 数据设置该实例的值。如果 JSON 数据包含的某些值未映射到 T 中的字段，则序列化程序将忽略这些值。如果 JSON 数据缺少 T 中某些字段的值，则序列化程序会在返回的对象中保留这些字段的构造值。</span><br><span class="line"></span><br><span class="line">FromJsonOverwrite(<span class="built_in">string</span> text, <span class="built_in">object</span> objectToOverwrite)</span><br><span class="line">在现有对象上反序列化 JSON 数据，从而覆盖所有现有数据。</span><br><span class="line">使用时无需管理值具体分配。其将基于字段命名自行匹配并赋值。</span><br><span class="line">如果 JSON 数据不包含某个字段的值，则序列化程序不会更改该字段的值。</span><br><span class="line">JSON 序列化程序 API 支持 MonoBehaviour 和 ScriptableObject 子类以及普通结构和类。但是，将 JSON 反序列化为 MonoBehaviour 或 ScriptableObject 子类时，必须使用 FromJsonOverwrite 方法。如果尝试使用 FromJson，则 Unity 会抛出异常，因为不支持此行为。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>仅支持 MonoBehaviour / ScriptableObject 继承类的序列化</li><li>仅支持 [Serializable] 的普通类与结构体</li><li>仅序列化 public 或 [SerializeField] 标签的字段  </li><li>在内部，此方法使用 Unity 序列化器；因此传入的对象必须受序列化器支持：它必须是 MonoBehaviour、ScriptableObject 或应用了 Serializable 属性的普通类/结构。要包含的字段的类型必须受序列化器支持；不受支持的字段以及私有字段、静态字段和应用了 NonSerialized 属性的字段会被忽略。</li><li>支持 List、Array 数据类型，但不支持 Dictionary、Query、Stack 等集合</li><li>支持 Enum 枚举，但默认存储值为数值类型</li></ul><h2 id="字典的序列化和反序列化"><a href="#字典的序列化和反序列化" class="headerlink" title="字典的序列化和反序列化"></a>字典的序列化和反序列化</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SerializeDictionary</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">DicToJson</span>&lt;<span class="title">TKey</span>, <span class="title">TValue</span>&gt;(<span class="params">Dictionary&lt;TKey, TValue&gt; dic</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> JsonUtility.ToJson(<span class="keyword">new</span> SerializeDictionary&lt;TKey, TValue&gt;(dic));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">Dictionary</span>&lt;<span class="title">TKey</span>, <span class="title">TValue</span>&gt; <span class="title">DicFromJson</span>&lt;<span class="title">TKey</span>, <span class="title">TValue</span>&gt;(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> JsonUtility.FromJson&lt;SerializeDictionary&lt;TKey, TValue&gt;&gt;(str).ToDictionary();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SerializeDictionary</span>&lt;<span class="title">TKey</span>, <span class="title">TValue</span>&gt; : <span class="title">ISerializationCallbackReceiver</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    List&lt;TKey&gt; keys;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    List&lt;TValue&gt; values;</span><br><span class="line"></span><br><span class="line">    Dictionary&lt;TKey, TValue&gt; target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dictionary&lt;TKey, TValue&gt; <span class="title">ToDictionary</span>()</span> &#123; <span class="keyword">return</span> target; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SerializeDictionary</span>(<span class="params">Dictionary&lt;TKey, TValue&gt; target</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnBeforeSerialize</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        keys = <span class="keyword">new</span> List&lt;TKey&gt;(target.Keys);</span><br><span class="line">        values = <span class="keyword">new</span> List&lt;TValue&gt;(target.Values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnAfterDeserialize</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> count = Math.Min(keys.Count, values.Count);</span><br><span class="line">        target = <span class="keyword">new</span> Dictionary&lt;TKey, TValue&gt;(count);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            target.Add(keys[i], values[i]);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>本文作于2023-08-21，首发于个人博客<a href="https://rdququ.top/">https://rdququ.top/</a></p>]]></content:encoded>
      
      
      <category domain="http://rdququ.top/categories/%E6%95%99%E7%A8%8B%E5%90%91/">教程向</category>
      
      <category domain="http://rdququ.top/categories/%E6%95%99%E7%A8%8B%E5%90%91/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</category>
      
      <category domain="http://rdququ.top/categories/%E6%95%99%E7%A8%8B%E5%90%91/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/">Unity</category>
      
      <category domain="http://rdququ.top/categories/%E6%95%99%E7%A8%8B%E5%90%91/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/%E9%9B%86%E6%8D%A2%E5%BC%8F%E5%8D%A1%E7%89%8C%E6%B8%B8%E6%88%8F/">集换式卡牌游戏</category>
      
      
      <category domain="http://rdququ.top/tags/Unity/">Unity</category>
      
      <category domain="http://rdququ.top/tags/%E5%8D%A1%E7%89%8C%E6%B8%B8%E6%88%8F/">卡牌游戏</category>
      
      <category domain="http://rdququ.top/tags/%E6%95%99%E7%A8%8B%EF%BC%8CJson/">教程，Json</category>
      
      <category domain="http://rdququ.top/tags/%E5%AD%97%E5%85%B8/">字典</category>
      
      <category domain="http://rdququ.top/tags/%E5%BA%8F%E5%88%97%E5%8C%96/">序列化</category>
      
      
      <comments>http://rdququ.top/posts/5e1ac7cf/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Unity集换式卡牌游戏_第4期_配表与读取你的卡牌</title>
      <link>http://rdququ.top/posts/bf64112e/</link>
      <guid>http://rdququ.top/posts/bf64112e/</guid>
      <pubDate>Tue, 15 Aug 2023 13:03:15 GMT</pubDate>
      
      <description>&lt;p&gt;在上一期中，我们制作了自己的第一张卡牌，并且通过&lt;code&gt;CardDisplay&lt;/code&gt;类中的&lt;code&gt;DisplayCard()&lt;/code&gt;方法展示了我们卡牌的属性。当时为了方便展示，我们直接在&lt;code&gt;CardDisplay&lt;/code&gt;中的&lt;code&gt;Start()&lt;/code&gt;里 new 了一张火球术出来&lt;br&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>在上一期中，我们制作了自己的第一张卡牌，并且通过<code>CardDisplay</code>类中的<code>DisplayCard()</code>方法展示了我们卡牌的属性。当时为了方便展示，我们直接在<code>CardDisplay</code>中的<code>Start()</code>里 new 了一张火球术出来<br> <span id="more"></span><br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cardModel = <span class="keyword">this</span>.GetModel&lt;CardModel&gt;();</span><br><span class="line">        card =<span class="keyword">new</span> SpellCard(<span class="number">1</span>, <span class="string">&quot;Fireball&quot;</span>, <span class="string">&quot;Deals 5 damage&quot;</span>, <span class="number">5</span>, <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;Fire&quot;</span> &#125;);<span class="comment">//就是这句啦</span></span><br><span class="line">        DisplayCard();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>然鹅，我们显然不能把我们所以的卡牌都以这样的方法 new 出来，我们需要一种更成熟，更方便的方法获取我们的卡牌————读配表。</p><h2 id="配表"><a href="#配表" class="headerlink" title="配表"></a>配表</h2><p>在实际开发中策划会不断地提出不同的需求，但是他们不会直接对代码进行操作，而是通过和程序的沟通间接完成，而将它们对数值的具体需求，忠实的向程序反映的桥梁就是数据表，一个典型的数据表可能是这样的：<br>||主键|名称|描述|<br>|—-|—-|—-|—-|<br>|类型|INT|STRING|STRING|<br>|字段名|ID|Name|Desc|<br>||1|勇士|勇敢的战士，遵循你的召唤而降生|<br>|</p><p>当然，实际的表可能会比这复杂的多。程序需要做的，就是去读取这张表，并可能将他以另外某种形式储存起来。持久存储数据的方法有很多，CSV,Json,XML,二进制…今天我们主要介绍的，就是CSV文件的读取。  </p><h2 id="csv的读取"><a href="#csv的读取" class="headerlink" title="csv的读取"></a>csv的读取</h2><p>csv其实就是 <code>Comma-Separated Values</code> -&gt; 逗号分隔的值<br>想要新建一个 csv 文件，就用 Excel 把 xls 另存为 csv 文件即可。<br>在视频中，我们新建了一个 CardData 文件，我们是这样读取他的<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadCardsFromCsv</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       cardData = Resources.Load&lt;TextAsset&gt;(<span class="string">&quot;Data/cardData&quot;</span>);<span class="comment">//读取csv文件</span></span><br><span class="line">       <span class="built_in">string</span>[] dataRow = cardData.text.Split(<span class="string">&#x27;\n&#x27;</span>);<span class="comment">//按行分割</span></span><br><span class="line">       <span class="keyword">foreach</span>(<span class="keyword">var</span> row <span class="keyword">in</span> dataRow)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">string</span>[] rowArray = row.Split(<span class="string">&#x27;,&#x27;</span>);<span class="comment">//按列分割</span></span><br><span class="line">           <span class="keyword">if</span> (rowArray[<span class="number">0</span>] == <span class="string">&quot;类型&quot;</span>)<span class="comment">//跳过第一行</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (rowArray[<span class="number">0</span>] == <span class="string">&quot;MonsterCard&quot;</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               MonsterCard monsterCard = <span class="keyword">new</span> MonsterCard(<span class="built_in">int</span>.Parse(rowArray[<span class="number">1</span>]), rowArray[<span class="number">2</span>], rowArray[<span class="number">3</span>], <span class="built_in">int</span>.Parse(rowArray[<span class="number">4</span>]), rowArray[<span class="number">5</span>].Split(<span class="string">&#x27;;&#x27;</span>), <span class="built_in">int</span>.Parse(rowArray[<span class="number">9</span>]), <span class="built_in">int</span>.Parse(rowArray[<span class="number">10</span>]));</span><br><span class="line">               totalCards.Add(monsterCard);</span><br><span class="line">               Debug.Log(<span class="string">&quot;monsterCard.Name&quot;</span>+monsterCard.Name);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (rowArray[<span class="number">0</span>] == <span class="string">&quot;SpellCard&quot;</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               SpellCard spellCard = <span class="keyword">new</span> SpellCard(<span class="built_in">int</span>.Parse(rowArray[<span class="number">1</span>]), rowArray[<span class="number">2</span>], rowArray[<span class="number">3</span>], <span class="built_in">int</span>.Parse(rowArray[<span class="number">4</span>]), rowArray[<span class="number">5</span>].Split(<span class="string">&#x27;;&#x27;</span>));</span><br><span class="line">               totalCards.Add(spellCard);</span><br><span class="line">               Debug.Log(<span class="string">&quot;spellCard.Name&quot;</span> + spellCard.Name);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>我们先用<code>/n</code>把文件分割成一行一行的字符串数组，再通过<code>,</code>如法炮制，把每一行都分割成对应 csv 表格的字符串数组，方便我们读取。跳过不需要读取的行， 我们按照事先标记的卡牌的种类，依次 new 出具体的 card，并把他们储存到 <code>List&lt;Card&gt;</code> 中去。 就这样，我们的卡牌的读取就顺利完成了，其实并没有什么难度，也适合自由发挥。<br>在视频的最后，我留下了 SkillData 没有读取，这里把读取方法一并写出。<br>我们新建了 Skill 类 和 SkillModel 类</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Skill</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">int</span> ID;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">string</span> Description;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">int</span> SkillValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> QFramework;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SkillModel</span> :<span class="title">AbstractModel</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> TextAsset skillData;</span><br><span class="line">    List&lt;Skill&gt; totalSkills = <span class="keyword">new</span> List&lt;Skill&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnInit</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        LoadSkillsFromCsv();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadSkillsFromCsv</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        skillData = Resources.Load&lt;TextAsset&gt;(<span class="string">&quot;Data/SkillData&quot;</span>);<span class="comment">//读取csv文件</span></span><br><span class="line">        <span class="built_in">string</span>[] dataRow = skillData.text.Split(<span class="string">&#x27;\n&#x27;</span>);<span class="comment">//按行分割</span></span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> row <span class="keyword">in</span> dataRow)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span>[] rowArray = row.Split(<span class="string">&#x27;,&#x27;</span>);<span class="comment">//按列分割</span></span><br><span class="line">            <span class="keyword">if</span> (rowArray[<span class="number">0</span>] == <span class="string">&quot;技能ID&quot;</span>)<span class="comment">//跳过第一行</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Skill skill = <span class="keyword">new</span> Skill();</span><br><span class="line">                skill.ID = <span class="built_in">int</span>.Parse(rowArray[<span class="number">0</span>]);</span><br><span class="line">                skill.Name = rowArray[<span class="number">1</span>];</span><br><span class="line">                skill.Description = rowArray[<span class="number">2</span>];</span><br><span class="line">                skill.SkillValue = <span class="built_in">int</span>.Parse(rowArray[<span class="number">5</span>]);      </span><br><span class="line">                totalSkills.Add(skill);</span><br><span class="line">                Debug.Log(<span class="string">&quot;读取了技能&quot;</span>+skill.Name+<span class="string">&quot; 技能ID: &quot;</span>+skill.ID+<span class="string">&quot; 技能描述: &quot;</span>+skill.Description+<span class="string">&quot; 技能数值: &quot;</span>+skill.SkillValue);</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，和上次我们写的 Card 颇有不同，也是想借此告诉大家，程序的设计方法千千万，不必拘泥于某一种写法，因地制宜才是妙招。</p><hr><p>本文作于2023-08-15，首发于个人博客<a href="https://rdququ.top/">https://rdququ.top/</a></p>]]></content:encoded>
      
      
      <category domain="http://rdququ.top/categories/%E6%95%99%E7%A8%8B%E5%90%91/">教程向</category>
      
      <category domain="http://rdququ.top/categories/%E6%95%99%E7%A8%8B%E5%90%91/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</category>
      
      <category domain="http://rdququ.top/categories/%E6%95%99%E7%A8%8B%E5%90%91/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/">Unity</category>
      
      <category domain="http://rdququ.top/categories/%E6%95%99%E7%A8%8B%E5%90%91/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/%E9%9B%86%E6%8D%A2%E5%BC%8F%E5%8D%A1%E7%89%8C%E6%B8%B8%E6%88%8F/">集换式卡牌游戏</category>
      
      
      <category domain="http://rdququ.top/tags/Unity/">Unity</category>
      
      <category domain="http://rdququ.top/tags/%E5%8D%A1%E7%89%8C%E6%B8%B8%E6%88%8F/">卡牌游戏</category>
      
      <category domain="http://rdququ.top/tags/%E6%95%99%E7%A8%8B/">教程</category>
      
      
      <comments>http://rdququ.top/posts/bf64112e/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
