<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>蛐蛐的软件开发世界</title>
    <link>https://rdququ.top/</link>
    
    <atom:link href="https://rdququ.top/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>正在学习unity中</description>
    <pubDate>Tue, 14 Nov 2023 07:32:41 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>引擎开发实战学习笔记</title>
      <link>https://rdququ.top/posts/b15b4e49/</link>
      <guid>https://rdququ.top/posts/b15b4e49/</guid>
      <pubDate>Tue, 14 Nov 2023 07:26:04 GMT</pubDate>
      
      <description>&lt;p&gt;记录&lt;br&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>记录<br><span id="more"></span></p><ol><li>EntryPoint</li><li>Logging</li></ol>]]></content:encoded>
      
      
      
      
      <comments>https://rdququ.top/posts/b15b4e49/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Component-Based &amp; Component-Oriented Programming</title>
      <link>https://rdququ.top/posts/c63a25c3/</link>
      <guid>https://rdququ.top/posts/c63a25c3/</guid>
      <pubDate>Sat, 11 Nov 2023 04:09:40 GMT</pubDate>
      
      <description>&lt;p&gt;一点关于 Component 的思考&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>一点关于 Component 的思考</p><span id="more"></span><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="面向对象编程-Object-Oriented-Programming"><a href="#面向对象编程-Object-Oriented-Programming" class="headerlink" title="面向对象编程 Object Oriented Programming"></a>面向对象编程 Object Oriented Programming</h3><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><h5 id="实现继承"><a href="#实现继承" class="headerlink" title="实现继承"></a>实现继承</h5><p>让派生类可以使用基类的接口和实现，而不需要重新编写相同的代码。目的是代码的复用。<br>但是实现继承会导致派生类和基类之间的强耦合，当基类的实现发生变化时，派生类也需要跟着变化。</p><h5 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h5><p>接口继承是指派生类只继承基类的接口，而不继承基类的实现。目的是让更高层的调用者不需要关注具体细节，可以一视同仁的去处理他见到的所以对象。我们也会把这种思想叫做“归一化”，典型的就是<code>toString()</code>方法。</p><p>反过来也一样，高层的调用者不需要对底层的实现指手画脚，最好连告知都不需要告知他们。我们把这种策略叫做“封装”</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>代码复用性相对差</li><li>实际开发中，对象缺少明显的父子继承关系</li><li>实现继承的强耦合性</li></ul><p>游戏世界的对象是绝对复杂的，再父子继承的过程中，我们几乎没办法找到一个父类或者祖父类让所有子类都心甘情愿的继承他。</p><p>下面可以举一个小栗子</p><p>我们有一个 <code>水陆空三栖核能魔法混动运兵器</code>，那么这个类该继承自谁呢？</p><p>或许你能搞定他的父类，但是你能搞定他的祖父类吗？战车？船只？还是飞机？</p><p>或许你会觉得这个例子太过刁钻了，但事实上，哪怕是现实世界的对象，纯粹的 OO 也会心有余而力不足。比如，弓骑兵到底是骑兵的子类还是弓手的子类？还有那个经久不衰的笑话，连裤袜倒是改继承自裤子还是袜子？虽然最高法告诉我们连裤袜就是连裤袜，但是对于一种编程范式来说，模糊和冗余是致命的。</p><p>这就是这节课我为什么要和大家谈面向组件开发。</p><h2 id="什么是面向组件编程-Component-Oriented-Programming"><a href="#什么是面向组件编程-Component-Oriented-Programming" class="headerlink" title="什么是面向组件编程 Component-Oriented Programming"></a>什么是面向组件编程 Component-Oriented Programming</h2><h3 id="什么是组件"><a href="#什么是组件" class="headerlink" title="什么是组件"></a>什么是组件</h3><p>组件的本质，就是把一些经常使用的功能或者行为抽离出来，封装成一个个独立的模块，在要使用的时候想乐高积木或者 Switch 的游戏卡带一样，组装起来或者插进我们想要构建功能的对象中就可以了。这种性质，我们也称为 PnP，即 Plug and Play, 即插即用。大家以后要熟悉这个词，在很多领域都会大量出现。</p><h2 id="另一种解决方案——面向数据编程-Data-Oriented-Programming"><a href="#另一种解决方案——面向数据编程-Data-Oriented-Programming" class="headerlink" title="另一种解决方案——面向数据编程 Data-Oriented Programming"></a>另一种解决方案——面向数据编程 Data-Oriented Programming</h2><h2 id="没有银弹"><a href="#没有银弹" class="headerlink" title="没有银弹"></a>没有银弹</h2><p>“A”:”a”<br>“B”:”b”<br>“Sprite”:4</p>]]></content:encoded>
      
      
      
      
      <comments>https://rdququ.top/posts/c63a25c3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>GAMES101Notes</title>
      <link>https://rdququ.top/posts/6206937d/</link>
      <guid>https://rdququ.top/posts/6206937d/</guid>
      <pubDate>Mon, 06 Nov 2023 13:51:16 GMT</pubDate>
      
      <description>&lt;p&gt;GAMES101Notes&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>GAMES101Notes</p><span id="more"></span><h2 id="Leture-3-Transform"><a href="#Leture-3-Transform" class="headerlink" title="Leture 3 Transform"></a>Leture 3 Transform</h2><ul><li>Modeling<br>-&gt;transformation, rotation, scaling<br>eg. Camera &amp; IK</li><li>Viewing<br>-&gt; (3D to 2D)projection</li></ul><h3 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h3><p>$<br>x’ = sx \<br>y’ = sy<br>$</p><p>$<br>\begin{bmatrix}<br>x’ \<br>y’ \<br>\end{bmatrix} =<br>\begin{bmatrix}<br>s &amp; 0 \<br>0 &amp; s \<br>\end{bmatrix}<br>\begin{bmatrix}<br>x \<br>y \<br>\end{bmatrix}<br>$</p><p>$<br>\begin{bmatrix}<br>x’ \<br>y’ \<br>\end{bmatrix} =<br>\begin{bmatrix}<br>s_x &amp; 0 \<br>0 &amp; s_y \<br>\end{bmatrix}<br>\begin{bmatrix}<br>x \<br>y \<br>\end{bmatrix}<br>$</p><h3 id="Reflection-Matrix"><a href="#Reflection-Matrix" class="headerlink" title="Reflection Matrix"></a>Reflection Matrix</h3><p>$<br>x’ = -x \<br>y’ = -y<br>$</p><p>$<br>\begin{bmatrix}<br>x’ \<br>y’ \<br>\end{bmatrix} =<br>\begin{bmatrix}<br>-1 &amp; 0 \<br>0 &amp; -1 \<br>\end{bmatrix}<br>\begin{bmatrix}<br>x \<br>y \<br>\end{bmatrix}<br>$</p><h3 id="Shear-Matrix"><a href="#Shear-Matrix" class="headerlink" title="Shear Matrix"></a>Shear Matrix</h3><p>$<br>x’ = x + ay \<br>y’ = y + bx<br>$</p><p>$<br>\begin{bmatrix}<br>x’ \<br>y’ \<br>\end{bmatrix} =<br>\begin{bmatrix}<br>1 &amp; a \<br>b &amp; 1 \<br>\end{bmatrix}<br>\begin{bmatrix}<br>x \<br>y \<br>\end{bmatrix}<br>$</p><h3 id="Rotate-abount-origin-0-0-CCW-by-default-『绕原点，逆时针』"><a href="#Rotate-abount-origin-0-0-CCW-by-default-『绕原点，逆时针』" class="headerlink" title="Rotate(abount origin$(0,0)$,CCW by default)『绕原点，逆时针』"></a>Rotate(abount origin$(0,0)$,CCW by default)『绕原点，逆时针』</h3><p>$<br>x’ = xcos\theta - ysin\theta \<br>y’ = xsin\theta + ycos\theta<br>$</p><p>$<br>\begin{bmatrix}<br>x’ \<br>y’ \<br>\end{bmatrix} =<br>\begin{bmatrix}<br>cos\theta &amp; -sin\theta \<br>sin\theta &amp; cos\theta \<br>\end{bmatrix}<br>\begin{bmatrix}<br>x \<br>y \<br>\end{bmatrix}<br>$</p><p>$<br>R = \begin{bmatrix}<br>cos\theta &amp; -sin\theta \<br>sin\theta &amp; cos\theta \<br>\end{bmatrix}<br>$</p><h3 id="Linear-Transform-Matrices-of-the-same-dimension-『相同』"><a href="#Linear-Transform-Matrices-of-the-same-dimension-『相同』" class="headerlink" title="Linear Transform = Matrices(of the same dimension)『相同』"></a>Linear Transform = Matrices(of the same dimension)『相同』</h3><p>$<br>x’ = ax + by \<br>y’ = cx + dy<br>$</p><p>$<br>\begin{bmatrix}<br>x’ \<br>y’ \<br>\end{bmatrix} =<br>\begin{bmatrix}<br>a &amp; b \<br>c &amp; d \<br>\end{bmatrix}<br>\begin{bmatrix}<br>x \<br>y \<br>\end{bmatrix}<br>$</p><p>$<br>x’ = Mx<br>$</p><h3 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h3><p>$<br>x’ = x + t_x \<br>y’ = y + t_y<br>$</p><p>$<br>\begin{bmatrix}<br>x’ \<br>y’ \<br>\end{bmatrix} =<br>\begin{bmatrix}<br>1 &amp; 0 \<br>0 &amp; 1 \<br>\end{bmatrix}<br>\begin{bmatrix}<br>x \<br>y \<br>\end{bmatrix} +<br>\begin{bmatrix}<br>t_x \<br>t_y \<br>\end{bmatrix}<br>$</p><p>$<br>\begin{bmatrix}<br>x’ \<br>y’ \<br>\end{bmatrix} =<br>\begin{bmatrix}<br>a &amp; b \<br>c &amp; d \<br>\end{bmatrix}<br>\begin{bmatrix}<br>x \<br>y \<br>\end{bmatrix} +<br>\begin{bmatrix}<br>t_x \<br>t_y \<br>\end{bmatrix}<br>$</p><p>显然，平移不是线性变换</p><p>但是我们想要有一个大统一的概念可以描述这些变换</p><h3 id="Homogeneous-Coordinates『齐次坐标』"><a href="#Homogeneous-Coordinates『齐次坐标』" class="headerlink" title="Homogeneous Coordinates『齐次坐标』"></a>Homogeneous Coordinates『齐次坐标』</h3><p>Add a third coordinate $w$ to $(x,y)$</p><ul><li>2D point: $= (x,y,1)^T$</li><li>2D vector: $= (x,y,0)^T$</li></ul><p>Maxtrix representation of translation</p><p>$<br>\begin{bmatrix}<br>x’ \<br>y’ \<br>w’ \<br>\end{bmatrix} =<br>\begin{bmatrix}<br>1 &amp; 0 &amp; t_x \<br>0 &amp; 1 &amp; t_y \<br>0 &amp; 0 &amp; 1 \<br>\end{bmatrix} ·<br>\begin{bmatrix}<br>x \<br>y \<br>1 \<br>\end{bmatrix} =<br>\begin{bmatrix}<br>x + t_x \<br>y + t_y \<br>1 \<br>\end{bmatrix}<br>$</p><p>$w$的意义是什么呢？</p><p>In homogeneous coordinates,<br>$<br>\begin{bmatrix}<br>x \<br>y \<br>w \<br>\end{bmatrix}$ is the 2D point $\begin{bmatrix}<br>\frac{x}{w} \<br>\frac{y}{w} \<br>1<br>\end{bmatrix}, w \neq 0<br>$</p><h3 id="2D-transformations"><a href="#2D-transformations" class="headerlink" title="2D transformations"></a>2D transformations</h3><h4 id="scale"><a href="#scale" class="headerlink" title="scale"></a>scale</h4><p>$<br>S(s_x,s_y) = \begin{bmatrix}<br>s_x &amp; 0 &amp; 0 \<br>0 &amp; s_y &amp; 0 \<br>0 &amp; 0 &amp; 1 \<br>\end{bmatrix}<br>$</p><h4 id="rotate"><a href="#rotate" class="headerlink" title="rotate"></a>rotate</h4><p>$<br>R(\theta) = \begin{bmatrix}<br>cos\theta &amp; -sin\theta &amp; 0 \<br>sin\theta &amp; cos\theta &amp; 0 \<br>0 &amp; 0 &amp; 1 \<br>\end{bmatrix}<br>$</p><h4 id="shear"><a href="#shear" class="headerlink" title="shear"></a>shear</h4><p>$<br>H(a,b) = \begin{bmatrix}<br>1 &amp; a &amp; 0 \<br>b &amp; 1 &amp; 0 \<br>0 &amp; 0 &amp; 1 \<br>\end{bmatrix}<br>$</p><h4 id="translate"><a href="#translate" class="headerlink" title="translate"></a>translate</h4><p>$<br>T(t_x,t_y) = \begin{bmatrix}<br>1 &amp; 0 &amp; t_x \<br>0 &amp; 1 &amp; t_y \<br>0 &amp; 0 &amp; 1 \<br>\end{bmatrix}<br>$</p><h3 id="Inverse-transform"><a href="#Inverse-transform" class="headerlink" title="Inverse transform"></a>Inverse transform</h3><p>逆变换刚好对应逆矩阵</p><h2 id="Lecture-4-Transformation-Cont"><a href="#Lecture-4-Transformation-Cont" class="headerlink" title="Lecture 4 Transformation Cont"></a>Lecture 4 Transformation Cont</h2><p><a href="https://blog.csdn.net/daduzimama/article/details/120509856">逆矩阵的求法</a></p><p>当一个矩阵的逆等同于他的伴随矩阵，那么这个矩阵是正交矩阵。</p><p>旋转矩阵是正交矩阵</p><h3 id="3D-transformations"><a href="#3D-transformations" class="headerlink" title="3D transformations"></a>3D transformations</h3><ul><li><p>Scale<br>$<br>S(s_x,s_y,s_z) = \begin{bmatrix}<br>s_x &amp; 0 &amp; 0 &amp; 0 \<br>0 &amp; s_y &amp; 0 &amp; 0 \<br>0 &amp; 0 &amp; s_z &amp; 0 \<br>0 &amp; 0 &amp; 0 &amp; 1 \<br>\end{bmatrix}<br>$</p></li><li><p>Translate<br>$<br>T(t_x,t_y,t_z) = \begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; t_x \<br>0 &amp; 1 &amp; 0 &amp; t_y \<br>0 &amp; 0 &amp; 1 &amp; t_z \<br>0 &amp; 0 &amp; 0 &amp; 1 \<br>\end{bmatrix}<br>$</p></li><li><p>Rotate(Around x-, y-, z-axis)<br>$<br>R_x(\theta) = \begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0 \<br>0 &amp; cos\theta &amp; -sin\theta &amp; 0 \<br>0 &amp; sin\theta &amp; cos\theta &amp; 0 \<br>0 &amp; 0 &amp; 0 &amp; 1 \<br>\end{bmatrix}\<br>$<br>$<br>R_y(\theta) = \begin{bmatrix}<br>cos\theta &amp; 0 &amp; sin\theta &amp; 0 \<br>0 &amp; 1 &amp; 0 &amp; 0 \<br>-sin\theta &amp; 0 &amp; cos\theta &amp; 0 \<br>0 &amp; 0 &amp; 0 &amp; 1 \<br>\end{bmatrix}\<br>$<br>$<br>R_z(\theta) = \begin{bmatrix}<br>cos\theta &amp; -sin\theta &amp; 0 &amp; 0 \<br>sin\theta &amp; cos\theta &amp; 0 &amp; 0 \<br>0 &amp; 0 &amp; 1 &amp; 0 \<br>0 &amp; 0 &amp; 0 &amp; 1 \<br>\end{bmatrix}<br>$</p></li></ul><h4 id="Rodrigues’-Rotation-Formula『罗德里格斯旋转公式』"><a href="#Rodrigues’-Rotation-Formula『罗德里格斯旋转公式』" class="headerlink" title="Rodrigues’ Rotation Formula『罗德里格斯旋转公式』"></a>Rodrigues’ Rotation Formula『罗德里格斯旋转公式』</h4><p>Rotation by angle $\alpha$ around axis $n$</p><p>$<br>\boldsymbol  {R}(\boldsymbol  {n},\alpha) = cos(\alpha)\boldsymbol  {I} + (1-cos(\alpha))\boldsymbol  {nn}^T + sin(\alpha)N\<br>N = \begin{bmatrix}<br>0 &amp; -n_z &amp; n_y \<br>n_z &amp; 0 &amp; -n_x \<br>-n_y &amp; n_x &amp; 0 \<br>\end{bmatrix}<br>$</p><h3 id="Viewing-transformation『观测变换』"><a href="#Viewing-transformation『观测变换』" class="headerlink" title="Viewing transformation『观测变换』"></a>Viewing transformation『观测变换』</h3><h3 id="View-Camera-transformation『视图变换』"><a href="#View-Camera-transformation『视图变换』" class="headerlink" title="View / Camera transformation『视图变换』"></a>View / Camera transformation『视图变换』</h3><h3 id="Projection-transformation『投影变换』"><a href="#Projection-transformation『投影变换』" class="headerlink" title="Projection transformation『投影变换』"></a>Projection transformation『投影变换』</h3><h4 id="Orthographic-projection『正交投影』"><a href="#Orthographic-projection『正交投影』" class="headerlink" title="Orthographic projection『正交投影』"></a>Orthographic projection『正交投影』</h4><ul><li>相机置于原点，面朝 -z 轴</li><li>丢掉 z 轴</li><li>Translate and scale to $[-1,1]^2$</li></ul><h5 id="In-general"><a href="#In-general" class="headerlink" title="In general"></a>In general</h5><ul><li>We want to map a cuboid $[l,r] \times [b,t] \times [\boldsymbol f,\boldsymbol n]$ to the “canonical” cube$[-1,1]^3$</li></ul><h6 id="Transformation-matrix"><a href="#Transformation-matrix" class="headerlink" title="Transformation matrix"></a>Transformation matrix</h6><p>Translate(center to origin) -&gt; Scale(length/width/height to 2)</p><p>$<br>M_{ortho} = \begin{bmatrix}<br>\frac{2}{r-l} &amp; 0 &amp; 0 &amp; 0 \<br>0 &amp; \frac{2}{t-b} &amp; 0 &amp; 0 \<br>0 &amp; 0 &amp; \frac{2}{\boldsymbol n-\boldsymbol f} &amp; 0 \<br>0 &amp; 0 &amp; 0 &amp; 1 \<br>\end{bmatrix}<br>·<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; -\frac{r+l}{2} \<br>0 &amp; 1 &amp; 0 &amp; -\frac{t+b}{2} \<br>0 &amp; 0 &amp; 1 &amp; -\frac{\boldsymbol n+\boldsymbol f}{2} \<br>0 &amp; 0 &amp; 0 &amp; 1 \<br>\end{bmatrix}<br>= \begin{bmatrix}<br>\frac{2}{r-l} &amp; 0 &amp; 0 &amp; -\frac{r+l}{r-l} \<br>0 &amp; \frac{2}{t-b} &amp; 0 &amp; -\frac{t+b}{t-b} \<br>0 &amp; 0 &amp; \frac{2}{\boldsymbol n-\boldsymbol f} &amp; -\frac{\boldsymbol n+\boldsymbol f}{\boldsymbol n-\boldsymbol f} \<br>0 &amp; 0 &amp; 0 &amp; 1 \<br>\end{bmatrix}<br>$</p><h4 id="Perspective-projection『透视投影』"><a href="#Perspective-projection『透视投影』" class="headerlink" title="Perspective projection『透视投影』"></a>Perspective projection『透视投影』</h4>]]></content:encoded>
      
      
      <category domain="https://rdququ.top/categories/%E5%AD%A6%E4%B9%A0%E5%90%91/">学习向</category>
      
      <category domain="https://rdququ.top/categories/%E5%AD%A6%E4%B9%A0%E5%90%91/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/">计算机图形学</category>
      
      
      <category domain="https://rdququ.top/tags/GAMES101Notes/">GAMES101Notes</category>
      
      
      <comments>https://rdququ.top/posts/6206937d/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>GAMES104Notes</title>
      <link>https://rdququ.top/posts/32cb02ce/</link>
      <guid>https://rdququ.top/posts/32cb02ce/</guid>
      <pubDate>Mon, 06 Nov 2023 04:49:57 GMT</pubDate>
      
      <description>&lt;p&gt;GAMES104Notes&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>GAMES104Notes</p><span id="more"></span><p><img src="GAMES104_Zoo of Game Engines-1.png" alt="AMES104_Zoo of Game Engines-1"></p><p><img src="GAMES104_Middlewares.png" alt="GAMES104_Middlewares"></p><h2 id="引擎的基本架构"><a href="#引擎的基本架构" class="headerlink" title="引擎的基本架构"></a>引擎的基本架构</h2><p>自顶向底的五层架构</p><ul><li>Tool Layer<br>工具链和编辑环境</li><li>Function Layer<br>游戏逻辑设计</li><li>Resource Layer<br>处理存储不同种类的文件资源</li><li>Core Layer<br>构建功能</li><li>Platform Layer<br>硬件的运行环境，输入设备的差别，软件的发布平台</li></ul><h3 id="resource-layer"><a href="#resource-layer" class="headerlink" title="resource layer"></a>resource layer</h3><p>importing: resource -&gt; asset</p><p>全局唯一编号: GUID</p><p>Runtime Asset Manager</p><p>Manager Asset Life Cycle</p><h3 id="Function-Layer"><a href="#Function-Layer" class="headerlink" title="Function Layer"></a>Function Layer</h3><p>tick &amp; frame</p><p>Multi-threading</p><h3 id="Core-Layer"><a href="#Core-Layer" class="headerlink" title="Core Layer"></a>Core Layer</h3><p>Math Library</p><p>Math Efficiency<br>eg. Quick and dirty hacks</p><ul><li>Carmack’s 1/sqrt(x)</li><li>Magic number</li></ul><p>eg. SIMD<img src="SIMD-1.png" alt="Alt text"></p><p>Data Structure and Containers</p><p>Memory Management</p><p>Foundation of Game Engine</p><h3 id="Platform-Layer"><a href="#Platform-Layer" class="headerlink" title="Platform Layer"></a>Platform Layer</h3><p>Target on Different Platform</p><p>Graphics API<br>eg. Render Hardware Interface(RHI)</p><p>Hardware Architecture</p><h3 id="Tool-Layer"><a href="#Tool-Layer" class="headerlink" title="Tool Layer"></a>Tool Layer</h3><p>Allow Anyone to Create Game</p><p>Digital Content Creation(DCC)</p><h2 id="如何构建游戏世界"><a href="#如何构建游戏世界" class="headerlink" title="如何构建游戏世界"></a>如何构建游戏世界</h2><h3 id="game-object-GO"><a href="#game-object-GO" class="headerlink" title="game object(GO)"></a>game object(GO)</h3><h4 id="property"><a href="#property" class="headerlink" title="property"></a>property</h4><h4 id="behavior"><a href="#behavior" class="headerlink" title="behavior"></a>behavior</h4><h4 id="OOP-vs-Component"><a href="#OOP-vs-Component" class="headerlink" title="OOP vs. Component"></a>OOP vs. Component</h4><p>OOP 也符合直觉，但是在复杂的游戏世界中并没有非常清晰的父子继承关系。</p><p>现在更多地使用 Component 的方式，将游戏对象的行为分解为多个组件，每个组件只负责一种行为。</p><h4 id="Component-based-Tick"><a href="#Component-based-Tick" class="headerlink" title="Component-based Tick"></a>Component-based Tick</h4><p>和曾经分GO Tick不同，现在是分Component Tick。由于 pipeline 效率更高</p><h4 id="GO-间通信"><a href="#GO-间通信" class="headerlink" title="GO 间通信"></a>GO 间通信</h4><ul><li>Hard Code</li><li>Event</li><li>uid</li></ul><h4 id="Scene-Management"><a href="#Scene-Management" class="headerlink" title="Scene Management"></a>Scene Management</h4><ol><li><p>No division &amp; Drived by grid</p></li><li><p>Spatial Data Structures</p><ul><li>Quadtree</li><li>Octree</li><li>Binary Space Partitioning(BSP)</li><li>Bounding Volume Hierarchy(BVH)</li><li>Scene Graph</li></ul></li></ol><h2 id="Rendering"><a href="#Rendering" class="headerlink" title="Rendering"></a>Rendering</h2><h3 id="Basics-of-Game-Rendering"><a href="#Basics-of-Game-Rendering" class="headerlink" title="Basics of Game Rendering"></a>Basics of Game Rendering</h3><h4 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h4><h5 id="SIMD-Single-Instruction-Multiple-Data-单指令多数据"><a href="#SIMD-Single-Instruction-Multiple-Data-单指令多数据" class="headerlink" title="SIMD(Single Instruction Multiple Data/单指令多数据)"></a>SIMD(Single Instruction Multiple Data/单指令多数据)</h5><p><code>SMID_ADD c, a, b</code></p><h5 id="SIMT-Single-Instruction-Multiple-Thread-单指令多线程"><a href="#SIMT-Single-Instruction-Multiple-Thread-单指令多线程" class="headerlink" title="SIMT(Single Instruction Multiple Thread/单指令多线程)"></a>SIMT(Single Instruction Multiple Thread/单指令多线程)</h5><p><code>SIMT_ADD c, a, b</code></p><h5 id="GPU-Architecture"><a href="#GPU-Architecture" class="headerlink" title="GPU Architecture"></a>GPU Architecture</h5><ul><li>GPC(Graphics Processing Cluster)</li><li>SM(Streaming Multiprocessor)</li><li>Texture Units</li><li>CUDA Core</li><li>Warp</li></ul><p><img src="GAMES101_GPU_Architecture.png" alt="GPU Architecture"></p><h5 id="Data-Flow-From-CPU-to-GPU"><a href="#Data-Flow-From-CPU-to-GPU" class="headerlink" title="Data Flow From CPU to GPU"></a>Data Flow From CPU to GPU</h5><ul><li>CPU and Main Memory</li><li>CPU to GPU</li><li>GPU and Video Memory</li></ul><p>尽可能让数据单向传输，从 CPU 到 GPU<br>尽可能不要从 GPU 里读数据</p><h5 id="Be-Aware-of-Cache-Efficiency"><a href="#Be-Aware-of-Cache-Efficiency" class="headerlink" title="Be Aware of Cache Efficiency"></a>Be Aware of Cache Efficiency</h5><p>数据一定要放在一起为 Cache(缓存) 做准备</p><h5 id="GPU-Bounds-and-Performance"><a href="#GPU-Bounds-and-Performance" class="headerlink" title="GPU Bounds and Performance"></a>GPU Bounds and Performance</h5><h4 id="Renderable"><a href="#Renderable" class="headerlink" title="Renderable"></a>Renderable</h4><h5 id="Mesh"><a href="#Mesh" class="headerlink" title="Mesh"></a>Mesh</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span></span><br><span class="line">&#123;</span><br><span class="line">  Vector3 m_position;</span><br><span class="line">  <span class="comment">// other attributes</span></span><br><span class="line">  UByte4 m_color;</span><br><span class="line">  Vector3 m_normal;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mesh</span></span><br><span class="line">&#123;</span><br><span class="line">  Vertex m_vertex[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>Vertex Data<ul><li>Vertex declaration</li><li>Vertex buffer</li></ul></li><li>Index Data<ul><li>Index declaration</li><li>Index buffer</li></ul></li></ul><p>Triangle Strip 利好 Cache</p><h3 id="Material-Shader-and-Lighting"><a href="#Material-Shader-and-Lighting" class="headerlink" title="Material, Shader, and Lighting"></a>Material, Shader, and Lighting</h3><h3 id="Special-Rendering"><a href="#Special-Rendering" class="headerlink" title="Special Rendering"></a>Special Rendering</h3><h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3>]]></content:encoded>
      
      
      <category domain="https://rdququ.top/categories/%E5%AD%A6%E4%B9%A0%E5%90%91/">学习向</category>
      
      <category domain="https://rdququ.top/categories/%E5%AD%A6%E4%B9%A0%E5%90%91/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/">游戏引擎</category>
      
      
      <category domain="https://rdququ.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/">计算机图形学</category>
      
      <category domain="https://rdququ.top/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/">游戏引擎</category>
      
      <category domain="https://rdququ.top/tags/GAMES104/">GAMES104</category>
      
      
      <comments>https://rdququ.top/posts/32cb02ce/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2D图形——渲染、精灵和简单应用</title>
      <link>https://rdququ.top/posts/220dd5af/</link>
      <guid>https://rdququ.top/posts/220dd5af/</guid>
      <pubDate>Sun, 05 Nov 2023 14:03:42 GMT</pubDate>
      
      <description>&lt;p&gt;2D 渲染基础&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>2D 渲染基础</p><span id="more"></span><h2 id="像素缓冲区和垂直同步"><a href="#像素缓冲区和垂直同步" class="headerlink" title="像素缓冲区和垂直同步"></a>像素缓冲区和垂直同步</h2><h3 id="CRT-显示器基础"><a href="#CRT-显示器基础" class="headerlink" title="CRT 显示器基础"></a>CRT 显示器基础</h3><p>现在大家用的比较多的是液晶显示器(LCD), 在早先年，大家用的 CRT 显示器比较多，也就是阴极管射线显示器。LCD 通过控制是否透光来控制亮和暗，当色彩不变时，液晶也保持不变，这样就无须考虑刷新率的问题。对于画面稳定、无闪烁感的液晶显示器，刷新率不高但图像也很稳定。不过对于我们今天要谈的游戏来说，缺点就很明显了，其相应速度不够，画面有时候会有重影。</p><p>当然，我们这节课的主题是 2D 游戏渲染基础，和大家聊显示器主要也是让大家更好的了解我们渲染操作生成后呈现的载体。</p><p>其实 LCD 和 CRT 显示器在刷新上的原理是差不多的，当然我们前面也说了，在早点年，CRT 显示器是当时的主流，综合考虑，也是为了让大家了解 2D 渲染这项技术在诞生之初的显示设备的环境，我打算从 CRT 显示器的角度带大家聊聊显示器的工作原理。</p><p>大家高中信息课应该教过，在 CRT 显示器内部，绘制图形是通过电子枪发射电子流完成的。这样讲可能比较抽象。其实，在显示器内部有一层荧光板，荧光板上面有一些荧光粉末，红绿蓝三种颜色的荧光粉末，单色的荧光粉末会聚集起来形成一个小小的荧光单元。红绿蓝三种单元各出一个聚集在一起就是一个像素点，密密麻麻的像素点就充斥在荧光板上了。<br>电子枪则会一口气发射三注电子流，很好理解，这些电子流依次打在了 RGB 三色上，由于电子流的强度不一样，每个像素点的红绿蓝三色的光也不一样，通过空间混色法，每个像素点就会呈现出不同的颜色。</p><p>当然，电子流的能量是有限的，这些荧光粉很快就会熄灭，所以电子枪需要不断的发射电子流，这样才能保证荧光粉不断的发光，显示器才能一直显示图像。这就是刷新了。</p><p>不过要想让画面动起来，而不是显示器上某个像素点一直再发不同的光，然而其他地方却一片黑，我们的电子流就要去射击不同的像素点，让整个显示器都呈现出画面。我们管这叫扫描。当然这里也运用到了人眼的视觉残留效应，想必大家很清楚。</p><p>当然扫描也不是乱扫的，是有章法有规则的，请看下图。</p><p><img src="CRT显示器扫描.png" alt="CRT显示器扫描"></p><p>这张图大家肯定超级熟悉吧。电子枪从左上角向右扫，然后再从右向左扫，直到扫完整个屏幕。欸，我估计聪明的小伙伴已经发现了，这个扫描线不是绝对水平的，而是略微带一点倾斜。这也是为了让扫描线能扫过整个屏幕而不是只在一条横线上来回扫。从左向右扫的每条扫描线都略微下坡，其实这个下坡的度数是可以算出来的，其斜率大约为 -1/水平分辨率, 非常好算，我就不带大家算一遍了。</p><h4 id="消隐期-BLANK"><a href="#消隐期-BLANK" class="headerlink" title="消隐期 BLANK"></a>消隐期 BLANK</h4><p>其实，在 CRT 显示器中，从右向左的这一条扫描线往往不会真实的扫描，而是消隐，大家可以理解为电子枪在这段时间不喷了，画面上一片漆黑。这个时间段我们称为<strong>行消隐期(HBLANK)</strong>，也可以叫做水平回扫。</p><p>啥是行？电子束既要作水平方向的运动，又要作垂直方向的运动。前者形成一行的扫描，称为行扫描，后者形成一幅画面的扫描，称为场扫描。</p><p>当电子流从左上角扫到右下角后，屏幕就完成了一帧的渲染，不过这时候电子枪指着右下角啊，难道说下一帧是从右下角原路返回右上角吗？听起来好像效率挺高的，不过我们实际上不会这么干。而是让电子枪直接从右下角跳到右上角，然后再从右上角开始扫描。电子枪从右下角移动到左上角的的过程，我们称作<strong>场消隐期(VBLANK)</strong>，也可以叫做垂直回扫。同样的，这段时间内，画面上也是一片漆黑的。</p><h4 id="垂直同步"><a href="#垂直同步" class="headerlink" title="垂直同步"></a>垂直同步</h4><p>前面我们已经谈过了画面撕裂的原理，是渲染帧数超过刷新率，在显示器才显示到一半时就粗暴的给他塞了新的画面进去。 那后来人是怎么解决这个问题的呢？很简单，就是在显示器刷新的时候，我们不提交渲染，直到等显示器刷新完了。这样就不会出现画面撕裂的问题了。这个技术就是<strong>垂直同步(VSYNC)</strong>。</p><p>简单来说就是渲染循环受到真实刷新率的支配嘛。让游戏渲染的输出频率对标设备的刷新率，游戏的主循环又会和渲染循环相互制约，游戏的帧率也就被限制在了设备的刷新率上。当然这也会造成输入延迟，这一点不理解的同学可以去听我上一节的课，讲的很清楚。</p><p>下面来点<strong>套话</strong><br>为了同步显示屏的显示过程和控制器，控制器会产生一系列的定时信号。当电子枪换行进行扫描时，控制器会发出一个<strong>水平同步信号 HSync</strong>；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，控制器会发出一个<strong>垂直同步信号 VSync</strong>。</p><p>VSYNC信号有效时，表示一帧数据的开始。</p><h3 id="像素缓冲区"><a href="#像素缓冲区" class="headerlink" title="像素缓冲区"></a>像素缓冲区</h3><p>缓冲区是一个很好理解的概念，图像从我们的 GPU 到屏幕上并不是实时的一步到位的。在 GPU 内存上有一系列的缓冲区用来暂存渲染数据。</p><p>我们在屏幕上展示出来的图像实际上是存储来 GPU 内存里面的。现代的硬件也足够支撑高分辨率的图像存在内存中，然而，这并不意味着我们就可以高枕无忧了。游戏循环仍然要像我们之前反复强调的那样考虑到 CRT(或者其他什么) 的电子枪。请试想，当 CRT 喷枪才在屏幕中喷到一半的时候，缓冲区就写入了新的数据，等这帧渲染完成后，显示器就会显示出一半新的画面，一半旧的画面，这就是我们前面说的画面撕裂。更糟糕的是，新数据提交的时候，上一帧还没开始绘制，那么就不是说屏幕中同时存在新的和旧的画面了，而是直接丢失了上一帧的画面。</p><p>为了解决这个问题，早期的开发者想出了一种现在我们已经很难接受的办法，那就是等到场消隐期再开始渲染，但这样的做法带来的弊端也很明显，游戏循环被完全锁死在了显示器的刷新率上了。</p><p>当然，还有另一种解决方案-多缓冲技术。我们可以在 GPU 内存中准备多个缓冲区，游戏循环可以将图像写入缓冲区A，这时屏幕正在绘制缓冲区B，等到下一帧，屏幕显示缓冲区A，游戏循环则将图像写入缓冲区B，由于屏幕和游戏循环的工作是交替进行的，所以我们可以保证屏幕显示的是完整的一帧画面。</p><p>为了完全消灭画面撕裂，缓冲区的交换必须在场消隐期进行，这就是我们之前一直说的<strong>垂直同步</strong>。</p><p>当然，这种技术的前提有两个，一个是交换缓冲区的速度足够快，在绝大多数场景下，这一点是不会变的，然而第二点则是等待 VBLANK。首先你得把游戏里面垂直同步的开关打开，缓冲区的交换才会等待垂直同步。有一些玩家为了追求极致的帧率和更低的输入延迟会关闭垂直同步，然而他们的屏幕刷新率又远低于游戏帧率，那么画面撕裂仍然会存在，缓冲区的存在只是一定程度的减缓了这种现象。</p><p>当然，有双缓冲区也有三缓冲区，甚至更多，为了画面的稳定和帧率的平滑，他们放弃了较短的输入延迟。</p><h2 id="精灵-Sprite"><a href="#精灵-Sprite" class="headerlink" title="精灵 Sprite"></a>精灵 Sprite</h2><h3 id="为什么是『精灵-·-Sprite』？"><a href="#为什么是『精灵-·-Sprite』？" class="headerlink" title="为什么是『精灵 · Sprite』？"></a>为什么是『精灵 · Sprite』？</h3><p>Sprite 是 德州仪器(TI)的工程师 Daniel Hillis 在 1970 年代后期创造的一个术语，也有一种说法，该词汇来自于 TI 的经理 David Ackley。</p><p>在计算机图形学和游戏开发领域，Sprite 指的是集成到更大场景中的独立悬浮于帧缓冲之上的的二维位图(Textrue2D)，其更多的用来表示游戏角色或者其他动态对象。</p><p>想象一下，你有一张图片作为游戏的背景——还有另外一张图片漂浮在这个作为背景的图片上，在游戏更新的过程中，后者会移动，旋转，缩放，甚至是可交互的，就像神话中的『幽灵』或者说『精灵』。</p><h3 id="画家算法"><a href="#画家算法" class="headerlink" title="画家算法"></a>画家算法</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>先将画面中的物体按其距离观察点的远近进行排序，结果存放在一张线形表中。距观察点远者称其优先级高，放在表头,距观察点近者称其优先级低，放在表尾，这张表称为深度优先级表。</p><p>然后按照从表头到表尾的顺序逐个绘制物体。由于距观察者近的物体在表尾最后画出，它覆盖了远处的物体，最终在屏幕上产生了正确的遮挡关系。</p><h3 id="精灵动画"><a href="#精灵动画" class="headerlink" title="精灵动画"></a>精灵动画</h3><p>就像所有动画一样，精灵动画也是运用的人眼的视觉残留效应，那么当然，一组精灵动画就需要一组精灵图片，为了让你的游戏人物的行动看起来足够流畅，一秒完成的动作至少也需要24张图片，一个简单攻击动作的精灵图量往往在8张以上。</p><h3 id="精灵表单"><a href="#精灵表单" class="headerlink" title="精灵表单"></a>精灵表单</h3><p>为了保证精灵完全对其，我们通常要求美术绘制的角色起码得是同一个尺寸，在过去，这个尺寸往往是 $2^n$ 次方，这也是许多库内部规定好的。当然，我们现在已经不追 $2^n$ 次方了，但是仍然需要一个角色一系列的动画帧保持相同的大小，并且，别的角色也最好按照设定保持类似的比例。</p><p>许多美术给图喜欢一张一张的给，那么这其实是让每张图片都成为以一个单独的纹理，并且图片中也会存在大量的留白，虽然现代引擎对这一类资源做过优化，但是不管是对内存，还是对程序员（有些美术给图之后往往就甩手不管图片的裁剪了）的头发来说，这都是一件很痛苦的事情。</p><p>一个更好的做法是将所有的动画帧放在一张图片上，这张图片，我们叫做精灵表单，这张表单上的图片，我们希望间距足够小，并且成行成列的对齐，这样不仅能节省不少内存空间，还可以让处理素材更加快捷。<br><img src="_AttackCombo.png" alt="_AttackCombo"><br>下面我提供一个打包的小工具，大家可以试试。 <a href="https://www.codeandweb.com/texturepacker">TexturePacker</a></p><p>当然，游戏引擎对图片的大小，长和宽都是有限制的。最好不要把所有图片都塞进一张精灵表里。</p><h2 id="滚屏"><a href="#滚屏" class="headerlink" title="滚屏"></a>滚屏</h2><p>在以前简单的 2D 游戏中，比如俄罗斯方块一类，游戏中所有元素都可以在一张固定大小的小小屏幕中展现出来，但随着玩法的更新迭代，游戏的世界也越来越大，再也不是一张固定大小的图片能承载的下的了。屏幕的大小没有办法改变，但实际上可显示的图片是可与改变的，想象一下，你面前有一张巨大的画布，你用一个木框去框住一小部分，这时候你再扯动，这时候这张远超木框大小的画布的全部内容就都可以再一个小小的屏幕中全部展现出来。</p><h3 id="单轴滚屏"><a href="#单轴滚屏" class="headerlink" title="单轴滚屏"></a>单轴滚屏</h3><p>单轴滚动顾名思义，就是屏幕在单个轴上滚动，其实现原理也特别简单。你可以按照屏幕大小绘制出一连串的图片，在游戏进行时只需要同时绘制出两张图片就可以。图片绘制的时机你可以采用时间计算，也可以采用Trigger或者射线检测，当你给你的每张图片都加上ID，你就可以非常自由的控制下一张改出现那一张图片了。又或者你的玩家吃到什么道具，同样可以很方便的影响到下一张图片的绘制。</p><h3 id="无限滚屏"><a href="#无限滚屏" class="headerlink" title="无限滚屏"></a>无限滚屏</h3><p>无限滚屏的原理其实和上面的单轴没有任何区别，只是说上面的图片出现顺序可能是写在策划表里的，而无限滚动是做一个循环或者随机打散组成序列。</p><h3 id="平行滚屏"><a href="#平行滚屏" class="headerlink" title="平行滚屏"></a>平行滚屏</h3><p>当然，制作过 2D 横版卷轴游戏的同学可能会知道，我们的背景实质上是分层的，远景，中景，近景，他们的移动都是有不同的速率的。</p><p>这会让你的游戏看起来更加真实，美术绝赞。</p><h3 id="四向滚屏"><a href="#四向滚屏" class="headerlink" title="四向滚屏"></a>四向滚屏</h3><p>四向滚屏的数学运算确实比单轴滚屏难了一个维度，但其实解决方案也是很多的。你可以选定一个坐标原点，以你的图片的长宽为x,y轴的单位长度构建一个坐标系，后面就是简单的数学问题了。一个很简单的很符合直觉的解决方案是，渲染你的角色所在的矩阵四角的图片。实际上就是你的角色所在的矩阵的四个点为中心渲染出图片。<br>很简单的算法吧，一句话就可以描述。</p><h2 id="瓦片地图"><a href="#瓦片地图" class="headerlink" title="瓦片地图"></a>瓦片地图</h2><p>素材复用在现代游戏中是很重要的一环，相信大家都没法接受每一关都需要重新绘制一遍，尤其是对于游戏地图来说，很多花草竹石在每个场景中也都大同小异。</p><p>瓦片地图把游戏世界划分成等分的网格（可以是等六边形也可以是平行四边形或者其他什么形状），每个方块都有其对应的精灵。一般来说游戏引擎都会提供一个瓦片地图的编辑器，一张画布，上面来绘制你的地图，一个调色板，上面是你将采用的精灵。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p><a href="https://vibaike.com/130533/">光栅扫描</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/412713532">液晶屏刷新原理和时序</a></p></li><li><p><a href="https://chillstepp.github.io/2020/07/17/AHU%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/">AHU计算机图形学</a></p></li><li><p><a href="https://handwiki.org/wiki/Sprite_(computer_graphics">Sprite (computer graphics)</a>)</p></li></ol>]]></content:encoded>
      
      
      
      
      <comments>https://rdququ.top/posts/220dd5af/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Unity rectTransform 解析</title>
      <link>https://rdququ.top/posts/462539dc/</link>
      <guid>https://rdququ.top/posts/462539dc/</guid>
      <pubDate>Sat, 04 Nov 2023 04:35:35 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/RectTransform.html&quot;&gt;官方文档地址&lt;/a&gt;&lt;br&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><a href="https://docs.unity3d.com/ScriptReference/RectTransform.html">官方文档地址</a><br><span id="more"></span></p><ul><li><p>anchoredPosition 锚点位置<br>不要使用 position 也不要使用 <strong>localPosition</strong>.<br>数据类型是 Vector2<br>The position of the pivot of this RectTransform relative to the anchor reference point.<br>相对于锚点参照点的轴枢位置</p></li><li><p>pivot 锚点<br>数据类型是 Vector2<br>The normalized position in this RectTransform that it rotates around.<br>在此 RectTransform 中环绕的归一化位置。<br>(0,0) 为左下角，(1,1) 为右上角.</p></li><li><p>sizeDelta 大小<br>数据类型是 Vector2<br>The size of this RectTransform relative to the distances between the anchors.<br>相对于锚点之间的距离，此 RectTransform 的大小。<br>If the anchors are together, sizeDelta is the same as size. If the anchors are in each of the four corners of the parent, the sizeDelta is how much bigger or smaller the rectangle is compared to its parent.<br>如果锚点在一起，则 sizeDelta 与 size 相同。如果锚点分别位于父对象的四个角上，那么 sizeDelta 就是矩形相对于父对象的大小。</p></li></ul>]]></content:encoded>
      
      
      
      
      <comments>https://rdququ.top/posts/462539dc/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>南京邮电大学校大学生科学技术协会软件研发部游戏组授课计划</title>
      <link>https://rdququ.top/posts/e5afc9d6/</link>
      <guid>https://rdququ.top/posts/e5afc9d6/</guid>
      <pubDate>Tue, 31 Oct 2023 09:18:02 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;GamePlay-Programming-Exprience&quot;&gt;&lt;a href=&quot;#GamePlay-Programming-Exprience&quot; class=&quot;headerlink&quot; title=&quot;GamePlay Programming Exprience&quot;&gt;&lt;/a&gt;GamePlay Programming Exprience&lt;/h2&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="GamePlay-Programming-Exprience"><a href="#GamePlay-Programming-Exprience" class="headerlink" title="GamePlay Programming Exprience"></a>GamePlay Programming Exprience</h2><span id="more"></span><h3 id="0-导论"><a href="#0-导论" class="headerlink" title="0.导论"></a>0.导论</h3><h3 id="1-游戏循环-时间和计算"><a href="#1-游戏循环-时间和计算" class="headerlink" title="1.游戏循环,时间和计算"></a>1.游戏循环,时间和计算</h3><h3 id="2-2D图形——渲染、精灵和简单应用"><a href="#2-2D图形——渲染、精灵和简单应用" class="headerlink" title="2.2D图形——渲染、精灵和简单应用"></a>2.2D图形——渲染、精灵和简单应用</h3><h3 id="3-游戏中的线性代数"><a href="#3-游戏中的线性代数" class="headerlink" title="3.游戏中的线性代数"></a>3.游戏中的线性代数</h3><h3 id="4-3D图形初探——坐标与世界变换"><a href="#4-3D图形初探——坐标与世界变换" class="headerlink" title="4.3D图形初探——坐标与世界变换"></a>4.3D图形初探——坐标与世界变换</h3><h3 id="5-3D图形再探——光照与着色"><a href="#5-3D图形再探——光照与着色" class="headerlink" title="5.3D图形再探——光照与着色"></a>5.3D图形再探——光照与着色</h3><h3 id="6-游戏输入——输入设备和输入系统"><a href="#6-游戏输入——输入设备和输入系统" class="headerlink" title="6.游戏输入——输入设备和输入系统"></a>6.游戏输入——输入设备和输入系统</h3><h3 id="7-声音和数字信号处理"><a href="#7-声音和数字信号处理" class="headerlink" title="7.声音和数字信号处理"></a>7.声音和数字信号处理</h3><h3 id="8-碰撞检测算法和数值积分法求解物理运动"><a href="#8-碰撞检测算法和数值积分法求解物理运动" class="headerlink" title="8.碰撞检测算法和数值积分法求解物理运动"></a>8.碰撞检测算法和数值积分法求解物理运动</h3><h3 id="9-有趣摄像机的实现与算法"><a href="#9-有趣摄像机的实现与算法" class="headerlink" title="9.有趣摄像机的实现与算法"></a>9.有趣摄像机的实现与算法</h3><h3 id="10-浅谈游戏AI-不止A-FSM和状态树"><a href="#10-浅谈游戏AI-不止A-FSM和状态树" class="headerlink" title="10.浅谈游戏AI, 不止A*, FSM和状态树"></a>10.浅谈游戏AI, 不止A*, FSM和状态树</h3><h3 id="11-UI设计，中间件和本地化"><a href="#11-UI设计，中间件和本地化" class="headerlink" title="11.UI设计，中间件和本地化"></a>11.UI设计，中间件和本地化</h3><h3 id="12-脚本语言和数据格式"><a href="#12-脚本语言和数据格式" class="headerlink" title="12.脚本语言和数据格式"></a>12.脚本语言和数据格式</h3><h3 id="13-网络游戏概述"><a href="#13-网络游戏概述" class="headerlink" title="13.网络游戏概述"></a>13.网络游戏概述</h3><h2 id="Unity-进阶"><a href="#Unity-进阶" class="headerlink" title="Unity 进阶"></a>Unity 进阶</h2><h2 id="UE5-3D-ARPG"><a href="#UE5-3D-ARPG" class="headerlink" title="UE5 3D ARPG"></a>UE5 3D ARPG</h2><h3 id="1-UE5界面介绍与基础建模"><a href="#1-UE5界面介绍与基础建模" class="headerlink" title="1.UE5界面介绍与基础建模"></a>1.UE5界面介绍与基础建模</h3><h3 id="2-熟悉蓝图脚本与EnhancedInputSystem"><a href="#2-熟悉蓝图脚本与EnhancedInputSystem" class="headerlink" title="2.熟悉蓝图脚本与EnhancedInputSystem"></a>2.熟悉蓝图脚本与EnhancedInputSystem</h3><h3 id="3-U-踏上UE的GamePlay架构"><a href="#3-U-踏上UE的GamePlay架构" class="headerlink" title="3.U++?踏上UE的GamePlay架构"></a>3.U++?踏上UE的GamePlay架构</h3><h3 id="4-骨骼绑定？射线追踪？教你使用AActor"><a href="#4-骨骼绑定？射线追踪？教你使用AActor" class="headerlink" title="4.骨骼绑定？射线追踪？教你使用AActor"></a>4.骨骼绑定？射线追踪？教你使用AActor</h3><h3 id="5-背包、血条——快来探索UE的前端UWdiget"><a href="#5-背包、血条——快来探索UE的前端UWdiget" class="headerlink" title="5.背包、血条——快来探索UE的前端UWdiget"></a>5.背包、血条——快来探索UE的前端UWdiget</h3><h3 id="6-狠狠存进来——UE数据表"><a href="#6-狠狠存进来——UE数据表" class="headerlink" title="6.狠狠存进来——UE数据表"></a>6.狠狠存进来——UE数据表</h3><h3 id="6-既然把Player讲的差不多了——那就开始我们的AI-Controller与行为树吧！"><a href="#6-既然把Player讲的差不多了——那就开始我们的AI-Controller与行为树吧！" class="headerlink" title="6.既然把Player讲的差不多了——那就开始我们的AI Controller与行为树吧！"></a>6.既然把Player讲的差不多了——那就开始我们的AI Controller与行为树吧！</h3><h3 id="7-特效环节——Niagara系统"><a href="#7-特效环节——Niagara系统" class="headerlink" title="7.特效环节——Niagara系统"></a>7.特效环节——Niagara系统</h3><h3 id="8-终于结束了GamePlay，那……开始我们的GAS与Game-Feature战斗吧"><a href="#8-终于结束了GamePlay，那……开始我们的GAS与Game-Feature战斗吧" class="headerlink" title="8.终于结束了GamePlay，那……开始我们的GAS与Game Feature战斗吧"></a>8.终于结束了GamePlay，那……开始我们的GAS与Game Feature战斗吧</h3>]]></content:encoded>
      
      
      <category domain="https://rdququ.top/categories/SAST/">SAST</category>
      
      
      <category domain="https://rdququ.top/tags/GamePlay-Programming-Exprience-Unity-UE5/">GamePlay Programming Exprience, Unity, UE5</category>
      
      
      <comments>https://rdququ.top/posts/e5afc9d6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>GamePlayProgrammingExprience_系列课_第一讲_游戏循环，时间和对象</title>
      <link>https://rdququ.top/posts/6d5dfc5f/</link>
      <guid>https://rdququ.top/posts/6d5dfc5f/</guid>
      <pubDate>Mon, 30 Oct 2023 13:49:03 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;课前的话&quot;&gt;&lt;a href=&quot;#课前的话&quot; class=&quot;headerlink&quot; title=&quot;课前的话&quot;&gt;&lt;/a&gt;课前的话&lt;/h2&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="课前的话"><a href="#课前的话" class="headerlink" title="课前的话"></a>课前的话</h2><span id="more"></span><p>今天我们要开的这节课，我把它取名叫做 GamePlay Programming Exprience. 今天是第一节. 这是校科协游戏组的大课, 在这套课上, 我不打算专注讲 Unity, UE 或者 CoCos 等游戏引擎的使用, 也不打算精细的教学 C# 或者 C++ 的具体语法, 为什么呢? 原因就在上一句, 游戏引擎太多, 我们授课没有办法面面俱到, 程序语言已经有各个组负责了, 他们会对语法进行详细的教学. 在这套课上, 我想和大家成系统的聊聊游戏编程的算法和游戏设计的心得, 正如其名, 这套课是为了 GamePlay 程序员准备的, 我们不会花很大篇幅描述物理模拟, 图形渲染, 而是作为将他作为 GamePlay 程序员(或许还有技术策划,真是新颖的方向)的入门基础课, 游戏运行的基本逻辑, 良好的输入交互, 游戏功能的实现算法(AI…A*啦,FSM啦,感知,群居..),游戏数学, 2D和3D渲染基础, 物理模拟计算, 摄像机控制, UI设计, 脚本语言(Lua, javaScript…),最后还会聊点网络编程.</p><p>看起来饼画得很大,乐, 看起来有点多, 我们计划讲两个学期,这是作为游戏组的大课, 我们在课上会尽量使用 Lua 风格的伪代码, 或许还会夹杂了C# 和 Java, 当然考虑到学校课程的设计, 同时也会给出一份 C/C++ 的代码以供参考. 本课程如果遇到示例, 将会使用 Unity 游戏引擎展示,若有不便之处,还请见谅.</p><p>在每节课结束之后,我们会布置一些小题目作为课后的作业,当然这是选做的.届时我会在QQ群里面发布作业,大家感兴趣去做一下就好. 在布置一周后我会在B站上公布解析视频.</p><p>如果大家对 Unity 和 C# 特别感兴趣, 或者觉得我大课上讲的太简单,可以来找我听小课,小课基本上会提前一天在群里通知时间和地点,大家可以关注华夜工作室和校科协游戏组群. 我还有一个小课授课前瞻群,群里会投票决定下节小课讲什么, 程序设计能力很强的同学可以向我提交作品入群.</p><p>当然,大课和小课都会把录播放出来,所以上面的要求也都不是强制的.</p><p>好,我们开始今天的课程吧</p><h2 id="游戏循环-loop"><a href="#游戏循环-loop" class="headerlink" title="游戏循环 loop"></a>游戏循环 loop</h2><p>游戏循环是游戏的核心控制流程，它是游戏的主线程，它负责游戏的运行，它是游戏的心脏。</p><p>在这个循环里，程序不断地去处理玩家的输入，更新游戏世界，然后生成输出（生成到屏幕上的我们会叫作渲染，游戏手柄等的震动也算是生成输出）。</p><p>这是非常经典而传统的游戏循环，你可以在任何游戏中见到他。想想看你再玩马里奥的时候，当你当你按下方向键，马里奥就会向你想要的方向移动，当你踩到龟壳上面的时候，龟壳会飞出去，或许你的手柄也会震动一下。</p><p>每次迭代游戏循环称为一帧，大部分游戏的帧率在 30-60 帧之间，也就是说，游戏循环每秒会执行 30-60 次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while game is running:</span><br><span class="line">    process inputs</span><br><span class="line">    update game world</span><br><span class="line">    generate outputs</span><br><span class="line">loop</span><br></pre></td></tr></table></figure><p>当然，循环的每一步都没有他们本身看上去的那么简单，每一步都有许多细节不容忽视。</p><h3 id="process-inputs"><a href="#process-inputs" class="headerlink" title="process inputs"></a>process inputs</h3><p>就像 process inputs，他意味着在循环的开始，你需要检查各种各样的设备的输入，键鼠，手柄，麦克风甚至还有触摸屏，陀螺仪，摄像机，GPS。有些是由你游戏中某些功能或者特色决定的，而另一些则来自玩家方便或者高品质游玩的需求。</p><p>他们的输入的类型也是多样的。如果你接触过 Unity 的 InputSystem, 那么或许你会更好的理解这一点。我们键盘的WASD，又或者手柄的遥感，他们都是Vector2的输入，而键盘，手柄，鼠标乃至触摸屏的点击，都是 Trigger 或者 Boolean 类型的， 这取决与他们是 Down, Up, Click 又或者是长按，双击。再打个比方，陀螺仪的输入可能是 Vector3的。输入系统的设备和输入的类型都是纷繁多样的，任何外部的输入都要在这一阶段被转换成计算机可以理解的数据结构。</p><h3 id="update-game-world"><a href="#update-game-world" class="headerlink" title="update game world"></a>update game world</h3><p>结束玩家的输入后，就来到或许是大家最关心的一部分了，更新游戏世界。是的，谁不想通过代码构筑一个属于自己的美妙世界呢，或许每个程序员写下第一行 Hello World 的时候，都会自豪于即将成为一个小小代码世界的上帝。然而，一个游戏世界的构筑显然不会像 Hello World 那么简单， 他需要构筑世界的<code>实例</code>和<code>法则</code>，这听来有点像炼金术师又或者魔法师，当然，也许游戏程序员在某种程度上就是在没有魔力的世界里施法的人。好了让我们回到构筑世界的具体方法上来，我们通常把构筑世界的实例称为<code>Game Object</code>, 他们是构成游戏世界的最基本的物质元素和法则的载体。这个我们后半节课会详细讲解。而<code>法则</code>也不难理解，那是世界运转的基本原理，或许他的本质是计算，而在宏观上的体现可以是物理模拟，游戏玩法，甚至是游戏的时间与空间。想象一下吧，在一款玩家可以肆意控制重力的世界，那里的法则就是<code>重力会不定期改变</code>，又或者是<code>雨世界</code>中精彩的生态系统，<code>Minecraft</code>里的方块世界和史蒂夫能锤爆钻石的手，游戏的<code>法则</code>是塑造你的游戏世界的基准线，而你将用代码去实现他。</p><p>上面讲了很多，但是简单概括一下就是一句</p><blockquote><p>更新所有已激活且需要更新的对象</p></blockquote><p>其中，<code>更新</code>就是<code>法则</code>, <code>对象</code>就是<code>实例</code></p><h3 id="generate-outputs"><a href="#generate-outputs" class="headerlink" title="generate outputs"></a>generate outputs</h3><p>在很多情境中，生成输出是最耗费计算量的一步。想想看最常见的输出是什么？…<br>2D和3D的渲染，最简单的3D渲染在计算三角形顶点和颜色的时候计算量都是一个天文数字。（这里讲的比较模糊，这节课有空就细讲，没空就下一节课讲）。当然，输出也不知图形渲染，音视频，手柄的力回馈，甚至是网络数据的发送，都是输出的一部分。</p><p>讲了这么多，或许我可以给出一个小游戏（Flappy Bird）的例子，让大家更好的理解游戏循环。请看伪代码</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> Bird is alive:</span><br><span class="line">    // process inputs</span><br><span class="line">    InputDeviceData j = grap raw data from <span class="built_in">input</span> device</span><br><span class="line"></span><br><span class="line">    // update game world</span><br><span class="line">    update bird.position based on j</span><br><span class="line">    <span class="built_in">foreach</span> pipe <span class="keyword">in</span> pipes</span><br><span class="line">        <span class="keyword">if</span> pipe is out of screen</span><br><span class="line">            move pipe to the right out of screen</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> bird collides with pipe</span><br><span class="line">                kill bird</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                update pipe.position</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    loop</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // generate outputs</span><br><span class="line">    draw graphics</span><br><span class="line">    play aduio</span><br><span class="line">loop</span><br></pre></td></tr></table></figure><h3 id="多线程下的游戏循环"><a href="#多线程下的游戏循环" class="headerlink" title="多线程下的游戏循环"></a>多线程下的游戏循环</h3><p>不同于早期游戏开发紧巴巴的硬件条件，2005年左右，多核处理器(CPU)开始普及，多线程编程也开始流行起来。在多线程的环境下，游戏循环的结构会有所不同，我们会把游戏循环分为两个线程，一个是游戏逻辑线程，另一个是渲染线程。游戏逻辑线程负责处理玩家的输入，更新游戏世界，而渲染线程则负责把游戏世界渲染到屏幕上。这样做的好处是，游戏逻辑线程和渲染线程可以并行执行，这样就可以充分利用多核处理器的优势，提高游戏的性能。</p><p>请你设想，在早期的单核处理器上，程序需要先花费 20ms 在逻辑运算上用来更新游戏世界，而后还需要花费 30ms 在渲染上，这样一来，游戏的帧率就只有 20FPS了。20帧的游戏，相信对于绝大多数玩家来说都是不可接受的，所以当年的游戏程序员绞劲脑汁开发出了大量极为优秀的优化算法————这点我们暂且不展开说，来提升游戏的帧率。然而，如果我们再新建一条渲染线程用来处理图形计算，那么游戏逻辑和图形渲染就可以并行执行，最终的帧率是 33.3FPS,卓越的提升！</p><p>没错，现代的游戏引擎也是这么做的，无论是 Unity 还是 UE</p><p>下面简单展示一下 Unity 的多线程渲染的基本逻辑</p><p>CPU 计算出什么需要渲染 -&gt; 渲染命令从主线程传给渲染线程 -&gt; 渲染线程生成渲染指令并提交给图形驱动 -&gt; GPU 执行渲染指令 -&gt; 显示器显示</p><p>很有意思，对吧？</p><p>当然，这里似乎有些问题</p><p>同学们，我们设想一下，主线程消耗20ms，渲染线程消耗30ms，如果主线程不等待渲染线程，那么到每3帧主线程就会领先渲染线程整整1帧，而为了追赶上主线程，渲染线程就要每4帧丢弃一帧（只保留1，2，3帧）的渲染，这会导致什么呢？</p><p>相信很多同学已经能报出答案了，画面卡顿。  </p><p>那么看起来我们只能让主线程等待渲染线程了吗？</p><p>难道没有其他更好的办法了吗？</p><p>有。我们有一个经典的解决办法：让渲染进程的执行比主线程慢一帧。<br>但是这种方法是有代价的，玩家的输入需要更久才能体现到画面上，这对 FPS，格斗，竞速等品类的即时竞技游戏来说是致命的。</p><p>当然，现在的多线程渲染方案也提出了不少新法门。比如 Unity 的<code>帧同步队列</code>技术。<br>我不太清楚同学们对数据结构有多少了解，所以我这里只做简单的解释。<br>前面我们多线程渲染的基本逻辑可以简化成这个样子：</p><p>主线程 -&gt; 渲染线程 -&gt; GPU -&gt; 显示器</p><p>主线程不断向GPU下达渲染指令，显然可以类比为生产者，而GPU不断读取着渲染指令，自然是链中的消费者。渲染指令会抵达一个循环队列(RingBuffer).</p><p>简单介绍一下循环队列的工作方式：<br>循环队列的实现，实际上是靠 Head 指针和 Tail 指针的原子操作来实现的。也就是说，生产者线程写入循环队列时，会原子地去后移 Tail 指针；消费者线程读取循环队列时，会原子地去后移 Head 指针。当 Tail 指针再次超过 Head 指针，则说明队列满了，则需要阻塞生产者线程。</p><ul><li>RingBuffer 在写满的时候会阻塞主线程，等待渲染线程。</li><li>RingBuffer 在读空的时候会阻塞渲染线程，等待主线程。</li></ul><p>多线程渲染的基础知识太多了，我这里只是简单的介绍一下，如果同学们对这方面感兴趣，可以自行搜索资料或者线下找我沟通。</p><h3 id="视窗消息泵-Windows-message-pump"><a href="#视窗消息泵-Windows-message-pump" class="headerlink" title="视窗消息泵 Windows message pump"></a>视窗消息泵 Windows message pump</h3><p>值得注意的是，在 Windows 平台中，本身逻辑的循环等，游戏还要处理来自 Windows 系统的指令。处理这段来自 Windows 指令的代码就被叫做 <code>message pump</code>。<code>message pump</code>从 Windows 消息队列中取出消息，然后分发给游戏程序的窗口。基本的逻辑是：</p><blockquote><p>先处理来自 Windows 的消息，然后在处理引擎（如果你的游戏并不依托某个引擎也是这样）的任务</p></blockquote><p>下面给出一段经典的消息泵的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Msg msg;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">PeekMessage</span>(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, PM_REMOVE))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.message == WM_QUIT)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">        <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do game stuff</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这带来了一个有趣的现象，当你移动（或者其他什么操作）你游戏的窗体的时候，游戏会卡住不动。比如 <code>Slay the Spire</code> 这款游戏是用 <code>Java</code> 语言，<code>libGDX</code> 框架开发的，不过在 <code>犹格索托斯的庭院</code> 上的实验没有起效，或许这说明了 Unity 并没有默认内置/启用这一段代码，需要开发者自行实现/开启。</p><p>对这点我还没有深入研究，希望大家搞明白后可以来和我分享。</p><h4 id="Windows-API-解释"><a href="#Windows-API-解释" class="headerlink" title="Windows API 解释"></a>Windows API 解释</h4><ul><li><code>PeekMessage</code>: 从消息队列中取出消息，但是不会阻塞</li><li>TranslateMessage: 将消息转换为字符消息</li><li>DispatchMessage: 将消息分发给窗口过程</li><li>PM_REMOVE: 从消息队列中移除消息</li><li>WM_QUIT: 指示终止应用程序</li></ul><h3 id="回调驱动框架-Callback-driven-framework"><a href="#回调驱动框架-Callback-driven-framework" class="headerlink" title="回调驱动框架 Callback-driven framework"></a>回调驱动框架 Callback-driven framework</h3><p>大多数游戏引擎的子系统或者第三方游戏中间套件都是以<code>library</code>的方式构成的。请注意，这里要和 Unity Project 文件夹中的 <code>Library</code> 文件夹区分开，前者是指一组可被程序员调用的函数和类，后者是指项目的缓存文件夹。</p><p>而另外一些游戏引擎或是中间套件，则是基于 <code>framework</code> 的。或许你可以把框架视为一套半完成的应用程序，你需要也仅能在框架的留白下自定义你的代码或者覆写代码预设的某些行为。但在控制流中，你的程序并不能取得主导地位，大部分流的控制权限被框架牢牢的攥在手中，你只能取得少量的控制。当然，对开源引擎如“Godot”，或者代码可访问的引擎如“Unreal Engine”来说，你当然可以通过自己修改引擎的框架来达成自己自定义程序流程的目的，不过一来这种方法相对危险且对程序员的水平要求很高，并且对“Unity”一类的引擎来说是做不到的。</p><p>简单的来说，<code>library</code> 是你调用他，而 <code>framework</code> 是他调用你。</p><p>具体的说，<code>library</code> 仅仅是提供了一些库函数供你调用，其灵活性强，侵入性低，不主导控制流，往往针对某个特殊的功能提供解决状态；而 <code>framework</code> 灵活性较差，侵入性强，主导控制流，能够为游戏开发提供一整套的解决方案。</p><p>在基于 <code>framework</code> 的游戏引擎中，主游戏循环已经为我们准备好了，他们的调度有一套严谨的顺序，只不过在我们编写回调方法 <code>callback function</code> 去覆写他们之前，他们什么也做不了。</p><p>下面给出简单的回调驱动的伪代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while (true)</span><br><span class="line">    foreach activeObject in activeObjects</span><br><span class="line">        activeObject.start()</span><br><span class="line">        activeObject.update()</span><br><span class="line">        activeObject.end()</span><br><span class="line">    loop</span><br><span class="line">loop</span><br></pre></td></tr></table></figure><p>虽然只是一段可以说是简陋的示例，但大家有没有觉得很眼熟？没错，这就是 Unity 的 <code>MonoBehaviour</code> 的生命周期。Unity 有着相当丰富的声明周期函数，他们的本质是事件函数(<code>event functions</code>), 或者说回调(<code>callback</code>)。这是一个非常经典的回调驱动的框架。</p><h2 id="时间和游戏"><a href="#时间和游戏" class="headerlink" title="时间和游戏"></a>时间和游戏</h2><p>现在大多数游戏都会有时间进程(progression of time)的概念。无论是 minecraft 中的日夜交替，还是 moba 游戏中对局时长，甚至是回合制游戏中的回合数，都依赖着时间进展的管理。这是从 gameplay 的角度来说的。在游戏实现的技术层面，或者无论是游戏循环还是渲染循环，也都离不开游戏时间的处理。</p><h3 id="真实时间"><a href="#真实时间" class="headerlink" title="真实时间"></a>真实时间</h3><p>真实事件顾名思义，就是真实世界流逝的时间，然而他的计算并不容易。显然我们不能直接调用C语言的标准库函数<code>time()</code>来获取真实时间，这个函数返回的是从1970年1月1日0时0分0秒到现在的秒数，这个数值是一个相当大的整数，而我们需要的是一个足够小的浮点数。毕竟，考虑到游戏中每帧仅耗时数十毫秒，这样的测量分辨率着实太粗糙了。</p><p>所以，我们该如何解决这个问题呢？（下面的 CPU 版本都以 Pentium 为例）</p><p>答案是使用 CPU 的高分辨率计时器来测量真实时间。这种计时器通常会实现为硬件寄存器，其它以64位无符号整型数的格式，记录了自CPU上电以来所经过的时钟周期数。Intel Pentium 以来所有 x86 处理器上都存在一个叫做 “Time Stamp Counter” 的 64 位寄存器。没错，他们就是上文所说的计时器和硬件寄存器。</p><p>在 3GHz 的 Pentium 上，其 Time Stamp Counter 每周期递增一次，也就是说每秒 30 亿次。分辨率是其每秒递增次数的倒数，即 $1/3GHz=3.33*10^{-10}s=0.333ns$。</p><p>在 Pentium 及其以上的 CPU 中，提供了一条机器指令RDTSC（Read Time Stamp Counter）来读取这个时间戳的数字，并将其保存在EDX:EAX寄存器对中。不过C++语言本身是不直接支持汇编指令的，所以我们需要使用内联汇编来调用这条指令。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">get_tsc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> a, d;</span><br><span class="line">    <span class="function">__asm__ <span class="title">volatile</span><span class="params">(<span class="string">&quot;rdtsc&quot;</span> : <span class="string">&quot;=a&quot;</span>(a), <span class="string">&quot;=d&quot;</span>(d))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> (d &lt;&lt; <span class="number">32</span>) | a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我们也可以用_emit伪指令直接嵌入该指令的机器码形式0X0F、0X31</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">unsigned</span> __int64 <span class="title">GetCycleCount</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">__asm _emit <span class="number">0x0F</span> </span><br><span class="line">__asm _emit <span class="number">0x31</span> </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>如果你使用 MSVC, 你也可以这么写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrin.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">get_tsc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __rdtsc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多核CPU或者“休眠”操作系统或乱序执行等带来的不精确的时间测量"><a href="#多核CPU或者“休眠”操作系统或乱序执行等带来的不精确的时间测量" class="headerlink" title="多核CPU或者“休眠”操作系统或乱序执行等带来的不精确的时间测量"></a>多核CPU或者“休眠”操作系统或乱序执行等带来的不精确的时间测量</h4><p>CPU 再也不是从前“单打独斗”的时代了，现在的 CPU 一般都是多核的，而且还有超线程技术，这就意味着，我们不能再简单的使用 Time Stamp Counter 来测量时间了。这超级好理解，假如你的CPU时四核的，他们开始工作的事件都不一样，你该听谁的？</p><p>不光如此，现在的操作系统都有节能模式，休眠模式，这些都会导致 CPU 的时钟频率发生变化，时钟频率变化，Time Stamp Counter 的递增速度也会变化，我们测量的结果自然也不准了。</p><p>再比如，现代的 CPU 为了提高性能，会对指令进行乱序执行，这也就意味着，我们测量的时间可能是乱序执行的时间，而不是我们想要的真实时间。</p><p>当然，后来的 CPU 都提供了一个新的指令，叫做 <code>RDTSCP</code>，这个指令会在读取时间戳的同时，读取一个标志位，这个标志位会在所有指令执行完毕后才会被置位，这样我们就可以保证测量的时间是正确的了。不过他的开销显然更大，耗时差不多是<code>RDTSC</code> 的两倍。</p><p>新版本的 CPU 也对上述的三个问题打了不同程度的补丁，这里也不详细展开了。</p><p>当然，在 Windows 平台上，也可以使用更加傻瓜式的方法来测量时间，比如调用 Windows API QueryPerformanceCounter 和 QueryPerformanceFrequency。不过为了跨平台和可拓展性，游戏引擎中是否要使用 QueryPerformanceCounter 和 QueryPerformanceFrequency 还有待商榷。</p><h3 id="游戏时间"><a href="#游戏时间" class="headerlink" title="游戏时间"></a>游戏时间</h3><p>在大多数情况下，游戏时间和真实事件时一致的，但这并不绝对，因为无论是从技术角度还是设计层面上考虑，游戏时间都是一个相对独立的概念。</p><p>如果我们提出一个时间流速的概念，也许会更便于大家理解。或者我们把它叫做时间缩放，这无所谓，只是个名字。</p><h4 id="时间缩放"><a href="#时间缩放" class="headerlink" title="时间缩放"></a>时间缩放</h4><p>好了，让我们来分类讨论。</p><p>当时间缩放为 1 的时候，游戏时间和真实时间是一致的，这是最常见的情况。在游戏 <code>60 Seconds</code> 中，游戏说好给你60s准备应对危机，他就的确只给了你60s，1s不多1s不少。</p><p>当时间缩放为 0 的时候，游戏时间就停止了，几乎所有游戏都会设置一个暂停功能。</p><p>当时间缩放大于 0 而小于 1 的时候，帅气的 <code>子弹时间</code>就出现了。除了玩家，几乎所有对象的时间都被减速了，又或者虽然玩家的时间同样被锁死了流速，但是他却凭借高超的技艺在危机前化险为夷或者大杀四方。在塞尔达传说系列游戏中，这种效果也被称为<code>林克时间</code>。</p><p>时间缩放大于 1 的情况也并不罕见，不仅在回合制游戏中有加速战斗的功能，各类即时游戏也同样有出自不同角度考虑设计的加速功能。比如在 <code>Minecraft</code> 中，玩家可以通过睡觉来跳过夜晚，<code>维多利亚3</code> 中的游戏流速也有多档位的设计。</p><p>最有趣的是时间缩放也可以为负数，理所当然的，这种情况通常表现为游戏世界的时间倒流。大名鼎鼎的 <code>时空幻境 （Braid）</code> 和 <code>波斯王子：时之沙</code> 在这方面的设计可谓神乎其技。</p><h3 id="增量时间与固定时间"><a href="#增量时间与固定时间" class="headerlink" title="增量时间与固定时间"></a>增量时间与固定时间</h3><p>前面我们说过，游戏的帧率是指以多快的时间向玩家展示一连串帧。帧率的单位是赫兹 Hz, 即每秒的执行次数，当然也可以用每秒帧数 FPS 来表示游戏的帧率。在传统上，电影的帧率是 24FPS，而游戏的帧率则是 30FPS 或者 60FPS。这通常和电子游戏流行开来时当地硬件设备（如彩色电视等）的刷新频率息息相关。</p><p>两帧之间的时间被称为 <code>帧时间 frame time</code>，当然，还要一个更加通用的的称呼 <code>增量时间 deltatime</code>, 在数学上写作 $Δt$。<br>早期的游戏不曾注意到增量时间的重要性，其经常依赖处理器的速度。毕竟我们每秒执行游戏循环的次数时固定的，即游戏的帧率。可是请大家试想，曾经在 8MHz 的 CPU 上运行的游戏迁移到由 16MHz 的 CPU 负责计算的游戏机上会发生什么事呢？</p><p>没错！每秒游戏循环的次数翻了倍，从而角色和敌人的移动速度也翻了倍，大家可以想象开了二倍速的马里奥会有多抽象。这还只是帧率翻了倍，要是把该游戏迁移到频率比过去的处理器高上百倍的机器上运行呢？<br>咦？这么严重的问题当初的程序员没有意识到吗？欸，我们在课堂上想一想都能考虑到的问题，实际开发游戏的工程师们会考虑不到吗？</p><p>如果你们有听过我第一节的导论课，那答案应该就能脱口而出了：当初的游戏是和游戏机绑定的，一台游戏机自带多少游戏就只能玩多少游戏，所以当时开发游戏的工作人员根本不会考虑到这一点，毕竟他们开发的游戏就根本不存在换一台机器运行的可能性，同时，在当年硬件性能捉襟见肘的年代，多节省点计算也是求之不得的。</p><p>当然，随着后来游戏产业的发展，大家也意识到了这个问题的严重性。B站上某UP主在使用模拟器测评上古老游戏的适合也曾经遇到过这个问题，游戏速度被加倍了好几十倍。不过也不是说现在的游戏就没有这个问题了，大家打开 TapTap 搜索 <code>几何决斗</code>，看看他的评论区，就能理解时间增量的正确应用是多么重要。他的问题看起来像是垂直同步 <code>v-sync</code> 和不正确的时间增量的使用共同导致的结果。当然，几何决斗只是一款连社区维护都谈不上的开源项目，但是大型游戏公司维护的 AAA 级或者说大型项目就一定能避免这个问题吗？<code>荒野大镖客</code> 和 <code>原神</code> 也都被反馈过存在高帧率游玩时会导致体力值消耗加快或者人物动作加快的 Bug。</p><h4 id="基于增量时间优化的游戏循环"><a href="#基于增量时间优化的游戏循环" class="headerlink" title="基于增量时间优化的游戏循环"></a>基于增量时间优化的游戏循环</h4><p>现在几乎所有的游戏引擎都提供了 Time 类的增量时间的 API。Gameplay 程序员可以轻松的调用他们，并且在合适的地方调用他们。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enemy.position.x += <span class="number">150</span> * deltaTime</span><br></pre></td></tr></table></figure><p>现在，无论帧率如何这段代码都能正确的工作了。在 30FPS 时，敌人会每帧移动 5 个像素；而在 60FPS 时，敌人会每帧移动 2.5 个像素，每秒都是 150 个像素，只不过在高帧率的设备上，角色的移动会更加的平滑。</p><p>很好，这样的方法已经极大程度的让游戏和 CPU 速度脱勾了，但是，我们要怎么实现呢？换句话说，我们怎么取得 $Δt$ 呢？这听起来似乎很简单，在一帧开始的时候取一次 <code>RDTSC</code>, 在结束的时候再取一次，然后取两者之差，再减去在 TSC 上取值所花的时间就能精准度量上一帧的 <code>Δt</code> 了。拿到上一帧的时间增量之后，自然就能使用其来预测当前帧的时间增量了。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">time</span> = GetTime()</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    var lastTime = <span class="built_in">time</span></span><br><span class="line">    <span class="built_in">time</span> = GetTime()</span><br><span class="line">    var deltaTime = <span class="built_in">time</span> – lastTime</span><br><span class="line">    ProcessInput()</span><br><span class="line">    Update(deltaTime)</span><br><span class="line">    GenerateOutput(deltaTime)</span><br><span class="line">loop</span><br></pre></td></tr></table></figure><p>很多游戏引擎都是采用上面的办法，但是该方法存在一个不可忽视的缺陷：我们用上一帧的时间增量预测的下一帧时间并不准确。某些帧可能会由于某些原因（程序的集中处理或者玩家的异常操作）而消耗过长/少的时间，我们称这个现象为 <code>帧率尖峰 frame-rate spike</code>.<br>比如在物理模拟中，某帧消耗了过长的时间，那么在下一帧我们就要 <code>步进</code> 两次来遮掩上一帧，这也会导致下一帧变得同样很慢，由此往复只会导致低帧问题越来越严重。</p><p>不过，由于游戏循环中帧与帧之间存在的时空相关性，如果我们将多个帧的时间增量的平均值作为下一帧时间增量的指导，那么也能大大缓解帧率尖峰带来的问题。</p><h4 id="固定时间"><a href="#固定时间" class="headerlink" title="固定时间"></a>固定时间</h4><p>所以，在一些帧率敏感的模块中，我们往往更倾向于向目标帧率靠近，比如我们要达到 33 帧的效果，那么如果本帧在预测的事件前就完成了任务，就让先线程去做别的些什么什么，反之只好等待下一个目标时间。该方法被称为<code>帧率调控 frame-rate governing</code>。</p><p>当然，只有游戏的平均帧率靠近该目标帧率的时候该方法才能尽可能的多发挥出效能。</p><p>然而，维持帧率的稳定对游戏各个子系统的意义都是非凡的。在引擎物理模拟的数学积分，以固定的时间更新效果最佳，而且物理效果也会变得更稳定流畅。包括屏幕刷新率和游戏帧率的不匹配，也会导致画面撕裂 <code>tearing</code>. 甚至是游戏的录播回访，也和游戏稳住是否稳定息息相关。周所周知，游戏的回访并非真的是屏幕的录制，只不过他们存储了游戏时间内的事件和时间戳，在打开回访的时候依次输出而已。有个很有意思的例子就是 <code>王者荣耀</code> 的回放，其实就是开了一局新的本地游戏。</p><h3 id="全局时间和局部时间"><a href="#全局时间和局部时间" class="headerlink" title="全局时间和局部时间"></a>全局时间和局部时间</h3><p>典型的如动画的时间是游离于整体时间轴之上的，我们可以在编辑面板单独调控动画的时间流速甚至他们的开始和结束。</p><h2 id="游戏对象"><a href="#游戏对象" class="headerlink" title="游戏对象"></a>游戏对象</h2><h3 id="游戏对象的类型"><a href="#游戏对象的类型" class="headerlink" title="游戏对象的类型"></a>游戏对象的类型</h3><ul><li>需要渲染不需要处理逻辑<br>背景，不可交互的物品等</li><li>既需要渲染也需要处理逻辑<br>玩家，敌人，子弹等</li><li>不需要渲染但需要处理逻辑<br>摄像机，空气墙</li></ul><h3 id="游戏“对象”一定是面向对象吗？"><a href="#游戏“对象”一定是面向对象吗？" class="headerlink" title="游戏“对象”一定是面向对象吗？"></a>游戏“对象”一定是面向对象吗？</h3><p>早期的游戏引擎和 Gameplay 会使用OOP，但是在复杂的游戏世界中并没有非常清晰的父子继承关系。eg. 水陆两栖单位。</p><p>现在更多地使用 Component 的方式，将游戏对象的行为分解为多个组件，每个组件只负责一种行为，并且 Component-Base 的模式也非常利于非程序员理解，因为他就像乐高积木一样的 PnP。</p><h3 id="游戏对象的生命周期"><a href="#游戏对象的生命周期" class="headerlink" title="游戏对象的生命周期"></a>游戏对象的生命周期</h3><p>在某些早期的游戏引擎中，和上面我们展示的<code>foreach activeObject in activeObjects</code>一样，是遍历所有的 GO，但是在现代的游戏引擎中，Component 则被更多的采用了。理由是将更多相同的模块放在一起可以最大程度的提高运行效率，也方便采用 Pipeline 的方式来运作。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>1.<a href="https://developer.unity.cn/projects/5ff9c6b0edbc2a60edd4807c">Unity 2020.2 优化了 Time.deltaTime，以实现更流畅的游戏体验</a><br>2.<a href="https://zhuanlan.zhihu.com/p/591218281">Unity多线程渲染概述</a><br>3.<a href="https://www.cnblogs.com/SunWentao/archive/2008/10/20/1315313.html">使用CPU时间戳进行高精度计时</a><br>4.<a href="http://taggedwiki.zubiaga.org/new_content/6fda7324cd6ec352ca95609d6ff5615a">Time Stamp Counter</a><br>5.<a href="http://www.wangkaixuan.tech/?p=901">细说RDTSC的坑</a></p>]]></content:encoded>
      
      
      <category domain="https://rdququ.top/categories/GamePlay-Programming-Exprience/">GamePlay Programming Exprience</category>
      
      
      <category domain="https://rdququ.top/tags/GamePlay-Programming-Exprience/">GamePlay Programming Exprience</category>
      
      
      <comments>https://rdququ.top/posts/6d5dfc5f/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>数据结构与算法_前缀、中缀、后缀表达式</title>
      <link>https://rdququ.top/posts/29455a3d/</link>
      <guid>https://rdququ.top/posts/29455a3d/</guid>
      <pubDate>Mon, 23 Oct 2023 10:30:13 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;中缀表达式&quot;&gt;&lt;a href=&quot;#中缀表达式&quot; class=&quot;headerlink&quot; title=&quot;中缀表达式&quot;&gt;&lt;/a&gt;中缀表达式&lt;/h2&gt;&lt;p&gt;中缀表达式就是我们通常所写的表达式，如：$1 + 2 &lt;em&gt; 3$，$1 + (2 + 3) &lt;/em&gt; 4 - 5$，$1 + 2 &lt;em&gt; (3 + 4 &lt;/em&gt; (5 + 6))$ 等等。&lt;/p&gt;
&lt;h2 id=&quot;后缀表达式及其求值方法&quot;&gt;&lt;a href=&quot;#后缀表达式及其求值方法&quot; class=&quot;headerlink&quot; title=&quot;后缀表达式及其求值方法&quot;&gt;&lt;/a&gt;后缀表达式及其求值方法&lt;/h2&gt;&lt;p&gt;后缀表达式又称为逆波兰表达式，它的特点是运算符在操作数的后面，如：$1 2 3 &lt;em&gt; +$，$1 2 3 + 4 &lt;/em&gt; + 5 -$，$1 2 3 4 5 6 + &lt;em&gt; + &lt;/em&gt; +$ 等等。&lt;/p&gt;
&lt;h3 id=&quot;后缀表达式的求值方法&quot;&gt;&lt;a href=&quot;#后缀表达式的求值方法&quot; class=&quot;headerlink&quot; title=&quot;后缀表达式的求值方法&quot;&gt;&lt;/a&gt;后缀表达式的求值方法&lt;/h3&gt;&lt;p&gt;后缀表达式的求值方法是：从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h2><p>中缀表达式就是我们通常所写的表达式，如：$1 + 2 <em> 3$，$1 + (2 + 3) </em> 4 - 5$，$1 + 2 <em> (3 + 4 </em> (5 + 6))$ 等等。</p><h2 id="后缀表达式及其求值方法"><a href="#后缀表达式及其求值方法" class="headerlink" title="后缀表达式及其求值方法"></a>后缀表达式及其求值方法</h2><p>后缀表达式又称为逆波兰表达式，它的特点是运算符在操作数的后面，如：$1 2 3 <em> +$，$1 2 3 + 4 </em> + 5 -$，$1 2 3 4 5 6 + <em> + </em> +$ 等等。</p><h3 id="后缀表达式的求值方法"><a href="#后缀表达式的求值方法" class="headerlink" title="后缀表达式的求值方法"></a>后缀表达式的求值方法</h3><p>后缀表达式的求值方法是：从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。</p><span id="more"></span><p>例如：$1 2 3 * +$ 的求值过程如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">读入字符</th><th style="text-align:center">当前栈</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">读入 1，进栈</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">1 2</td><td style="text-align:center">读入 2，进栈</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">1 2 3</td><td style="text-align:center">读入 3，进栈</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">1 6</td><td style="text-align:center">读入 <em>，出栈 3 和 2，计算 2 </em> 3 = 6，将 6 进栈</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">7</td><td style="text-align:center">读入 +，出栈 6 和 1，计算 1 + 6 = 7，将 7 进栈</td></tr></tbody></table></div><h3 id="C-实现后缀表达式的求值"><a href="#C-实现后缀表达式的求值" class="headerlink" title="C++ 实现后缀表达式的求值"></a>C++ 实现后缀表达式的求值</h3><p>用C++实现后缀表达式的求值。要求有简单的控制台UI，并且要对用户的危险行为进行检查和警告。控制台输出的语句要求是中英文对照，并且在用户进行错误操作的时候告知他进行了什么错误操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOperator</span><span class="params">(<span class="type">char</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">performOperation</span><span class="params">(<span class="type">char</span> op, <span class="type">double</span> operand1, <span class="type">double</span> operand2)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">evaluatePostfixExpression</span><span class="params">(<span class="type">const</span> string&amp; postfix, <span class="type">double</span>&amp; result)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;欢迎使用后缀表达式计算器！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入一个后缀表达式，使用空格分隔操作数和操作符，输入&#x27;q&#x27;退出：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        string input;</span><br><span class="line">        <span class="built_in">getline</span>(cin, input);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (input == <span class="string">&quot;q&quot;</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;感谢使用后缀表达式计算器，再见！&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查输入中的非法字符</span></span><br><span class="line">        <span class="type">bool</span> validInput = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : input) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isspace</span>(c) &amp;&amp; !<span class="built_in">isdigit</span>(c) &amp;&amp; !<span class="built_in">isOperator</span>(c)) &#123;</span><br><span class="line">                validInput = <span class="literal">false</span>;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;错误：输入包含非法字符 &#x27;&quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (validInput) &#123;</span><br><span class="line">            <span class="type">double</span> result;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">evaluatePostfixExpression</span>(input, result)) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;结果： &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;错误：无效的后缀表达式&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入另一个后缀表达式，或输入&#x27;q&#x27;退出：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOperator</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;*&#x27;</span> || c == <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">performOperation</span><span class="params">(<span class="type">char</span> op, <span class="type">double</span> operand1, <span class="type">double</span> operand2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> operand1 + operand2;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> operand1 - operand2;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> operand1 * operand2;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> (operand2 != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> operand1 / operand2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;错误：除数不能为零&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;错误：未知的操作符 &#x27;&quot;</span> &lt;&lt; op &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">evaluatePostfixExpression</span><span class="params">(<span class="type">const</span> string&amp; postfix, <span class="type">double</span>&amp; result)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">double</span>&gt; operandStack;</span><br><span class="line"></span><br><span class="line">    <span class="function">istringstream <span class="title">iss</span><span class="params">(postfix)</span></span>;</span><br><span class="line">    string token;</span><br><span class="line">    <span class="keyword">while</span> (iss &gt;&gt; token) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(token[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="type">double</span> operand = <span class="built_in">stod</span>(token);</span><br><span class="line">            operandStack.<span class="built_in">push</span>(operand);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isOperator</span>(token[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (operandStack.<span class="built_in">size</span>() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;错误：操作数不足&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">double</span> operand2 = operandStack.<span class="built_in">top</span>();</span><br><span class="line">            operandStack.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">double</span> operand1 = operandStack.<span class="built_in">top</span>();</span><br><span class="line">            operandStack.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">double</span> result = <span class="built_in">performOperation</span>(token[<span class="number">0</span>], operand1, operand2);</span><br><span class="line">            operandStack.<span class="built_in">push</span>(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;错误：无效的标记 &#x27;&quot;</span> &lt;&lt; token &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (operandStack.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">        result = operandStack.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;错误：操作数不足或操作符过多&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-实现后缀表达式的求值-1"><a href="#C-实现后缀表达式的求值-1" class="headerlink" title="C 实现后缀表达式的求值"></a>C 实现后缀表达式的求值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_STACK_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable : 4996)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈结构和操作</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> data[MAX_STACK_SIZE];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initialize</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Stack* <span class="built_in">stack</span>, <span class="type">double</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;top &lt; MAX_STACK_SIZE - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;data[++<span class="built_in">stack</span>-&gt;top] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;错误：栈已满\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">pop</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;错误：栈为空\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isOperator</span><span class="params">(<span class="type">char</span> c)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">performOperation</span><span class="params">(<span class="type">char</span> op, <span class="type">double</span> operand1, <span class="type">double</span> operand2)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">evaluatePostfixExpression</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* postfix, <span class="type">double</span>* result)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;欢迎使用后缀表达式计算器！\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个后缀表达式，使用空格分隔操作数和操作符，输入&#x27;q&#x27;退出：\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> input[<span class="number">100</span>];</span><br><span class="line">        fgets(input, <span class="keyword">sizeof</span>(input), <span class="built_in">stdin</span>);</span><br><span class="line">        input[<span class="built_in">strcspn</span>(input, <span class="string">&quot;\n&quot;</span>)] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 去掉换行符</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input, <span class="string">&quot;q&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;感谢使用后缀表达式计算器，再见！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查输入中的非法字符</span></span><br><span class="line">        <span class="type">int</span> validInput = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; input[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isspace</span>(input[i]) &amp;&amp; !<span class="built_in">isdigit</span>(input[i]) &amp;&amp; !isOperator(input[i])) &#123;</span><br><span class="line">                validInput = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;错误：输入包含非法字符 &#x27;%c&#x27;\n&quot;</span>, input[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (validInput) &#123;</span><br><span class="line">            <span class="type">double</span> result;</span><br><span class="line">            <span class="keyword">if</span> (evaluatePostfixExpression(input, &amp;result)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;结果： %g\n&quot;</span>, result);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;错误：无效的后缀表达式\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入另一个后缀表达式，或输入&#x27;q&#x27;退出：\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isOperator</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;*&#x27;</span> || c == <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">performOperation</span><span class="params">(<span class="type">char</span> op, <span class="type">double</span> operand1, <span class="type">double</span> operand2)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> operand1 + operand2;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> operand1 - operand2;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> operand1 * operand2;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> (operand2 != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> operand1 / operand2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;错误：除数不能为零\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;错误：未知的操作符 &#x27;%c&#x27;\n&quot;</span>, op);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">evaluatePostfixExpression</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* postfix, <span class="type">double</span>* result)</span> &#123;</span><br><span class="line">    Stack operandStack;</span><br><span class="line">    initialize(&amp;operandStack);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* token = strtok((<span class="type">char</span>*)postfix, <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (token != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(token[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="type">double</span> operand = atof(token);</span><br><span class="line">            push(&amp;operandStack, operand);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isOperator(token[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (operandStack.top &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;错误：操作数不足\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">double</span> operand2 = pop(&amp;operandStack);</span><br><span class="line">            <span class="type">double</span> operand1 = pop(&amp;operandStack);</span><br><span class="line">            <span class="type">double</span> result = performOperation(token[<span class="number">0</span>], operand1, operand2);</span><br><span class="line">            push(&amp;operandStack, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;错误：无效的标记 &#x27;%s&#x27;\n&quot;</span>, token);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        token = strtok(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (operandStack.top == <span class="number">0</span>) &#123;</span><br><span class="line">        *result = operandStack.data[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;错误：操作数不足或操作符过多\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后缀表达式的转换方法-中缀转后缀"><a href="#后缀表达式的转换方法-中缀转后缀" class="headerlink" title="后缀表达式的转换方法(中缀转后缀)"></a>后缀表达式的转换方法(中缀转后缀)</h3><p>将中缀表达式转换为后缀表达式的方法是：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，若是符号，则判断其与栈顶符号的优先级，是右括号或优先级不高于栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。</p><p>例如：$1 + (2 + 3) * 4 - 5$ 的转换过程如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">读入字符</th><th style="text-align:center">当前栈</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">读入 1，输出</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">+</td><td style="text-align:center">读入 +，进栈</td></tr><tr><td style="text-align:center">(</td><td style="text-align:center">+ (</td><td style="text-align:center">读入 (，进栈</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">+ ( 2</td><td style="text-align:center">读入 2，输出</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">+ ( +</td><td style="text-align:center">读入 +，进栈</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">+ ( + 3</td><td style="text-align:center">读入 3，输出</td></tr><tr><td style="text-align:center">)</td><td style="text-align:center">+</td><td style="text-align:center">读入 )，依次出栈 + 和 (，输出</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">*</td><td style="text-align:center">读入 *，进栈</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">* 4</td><td style="text-align:center">读入 4，输出</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">读入 -，进栈</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">- 5</td><td style="text-align:center">读入 5，输出</td></tr><tr><td style="text-align:center">空</td><td style="text-align:center">-</td><td style="text-align:center">依次出栈 - 和 *，输出</td></tr></tbody></table></div><p>转换后的后缀表达式为：$1 2 3 + 4 * + 5 -$。</p><h3 id="C-实现中缀表达式转后缀表达式"><a href="#C-实现中缀表达式转后缀表达式" class="headerlink" title="C++ 实现中缀表达式转后缀表达式"></a>C++ 实现中缀表达式转后缀表达式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getOperatorPrecedence</span><span class="params">(<span class="type">char</span> op)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOperator</span><span class="params">(<span class="type">char</span> c)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">infixToPostfix</span><span class="params">(<span class="type">const</span> string&amp; infix)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;欢迎使用中缀表达式转后缀表达式程序！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入一个中缀表达式，输入&#x27;q&#x27;退出：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        string infixExpression;</span><br><span class="line">        <span class="built_in">getline</span>(cin, infixExpression);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (infixExpression == <span class="string">&quot;q&quot;</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;感谢使用中缀表达式转后缀表达式程序，再见！&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string postfixExpression = <span class="built_in">infixToPostfix</span>(infixExpression);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;后缀表达式：&quot;</span> &lt;&lt; postfixExpression &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入另一个中缀表达式，或输入&#x27;q&#x27;退出：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getOperatorPrecedence</span><span class="params">(<span class="type">char</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOperator</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;*&#x27;</span> || c == <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">infixToPostfix</span><span class="params">(<span class="type">const</span> string&amp; infix)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; operatorStack;</span><br><span class="line">    string postfixExpression;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : infix) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(c)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c) || <span class="built_in">isalpha</span>(c)) &#123;</span><br><span class="line">            postfixExpression += c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isOperator</span>(c)) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!operatorStack.<span class="built_in">empty</span>() &amp;&amp;</span><br><span class="line">                <span class="built_in">getOperatorPrecedence</span>(operatorStack.<span class="built_in">top</span>()) &gt;= <span class="built_in">getOperatorPrecedence</span>(c)) &#123;</span><br><span class="line">                postfixExpression += operatorStack.<span class="built_in">top</span>();</span><br><span class="line">                operatorStack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            operatorStack.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            operatorStack.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!operatorStack.<span class="built_in">empty</span>() &amp;&amp; operatorStack.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                postfixExpression += operatorStack.<span class="built_in">top</span>();</span><br><span class="line">                operatorStack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!operatorStack.<span class="built_in">empty</span>() &amp;&amp; operatorStack.<span class="built_in">top</span>() == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                operatorStack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;错误：括号不匹配&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;错误：无效的字符 &#x27;&quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!operatorStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (operatorStack.<span class="built_in">top</span>() == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;错误：括号不匹配&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        postfixExpression += operatorStack.<span class="built_in">top</span>();</span><br><span class="line">        operatorStack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> postfixExpression;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-实现中缀表达式转后缀表达式-1"><a href="#C-实现中缀表达式转后缀表达式-1" class="headerlink" title="C 实现中缀表达式转后缀表达式"></a>C 实现中缀表达式转后缀表达式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_STACK_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈结构和操作</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> data[MAX_STACK_SIZE];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initialize</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isFull</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == MAX_STACK_SIZE - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Stack* <span class="built_in">stack</span>, <span class="type">char</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isFull(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;data[++<span class="built_in">stack</span>-&gt;top] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;错误：栈已满\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">pop</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;错误：栈为空\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">peek</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getOperatorPrecedence</span><span class="params">(<span class="type">char</span> op)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">isOperator</span><span class="params">(<span class="type">char</span> c)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">infixToPostfix</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* infix, <span class="type">char</span>* postfix)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;欢迎使用中缀表达式转后缀表达式程序！\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个中缀表达式，输入&#x27;q&#x27;退出：\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> infixExpression[<span class="number">100</span>];</span><br><span class="line">        fgets(infixExpression, <span class="keyword">sizeof</span>(infixExpression), <span class="built_in">stdin</span>);</span><br><span class="line">        infixExpression[<span class="built_in">strcspn</span>(infixExpression, <span class="string">&quot;\n&quot;</span>)] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 去掉换行符</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(infixExpression, <span class="string">&quot;q&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;感谢使用中缀表达式转后缀表达式程序，再见！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> postfixExpression[<span class="number">100</span>];</span><br><span class="line">        infixToPostfix(infixExpression, postfixExpression);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;后缀表达式：%s\n&quot;</span>, postfixExpression);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入另一个中缀表达式，或输入&#x27;q&#x27;退出：\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getOperatorPrecedence</span><span class="params">(<span class="type">char</span> op)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isOperator</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;*&#x27;</span> || c == <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">infixToPostfix</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* infix, <span class="type">char</span>* postfix)</span> &#123;</span><br><span class="line">    Stack operatorStack;</span><br><span class="line">    initialize(&amp;operatorStack);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (infix[i] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(infix[i])) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isdigit</span>(infix[i]) || <span class="built_in">isalpha</span>(infix[i])) &#123;</span><br><span class="line">            postfix[j++] = infix[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isOperator(infix[i])) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!isEmpty(&amp;operatorStack) &amp;&amp; getOperatorPrecedence(peek(&amp;operatorStack)) &gt;= getOperatorPrecedence(infix[i])) &#123;</span><br><span class="line">                postfix[j++] = pop(&amp;operatorStack);</span><br><span class="line">            &#125;</span><br><span class="line">            push(&amp;operatorStack, infix[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (infix[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            push(&amp;operatorStack, infix[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (infix[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!isEmpty(&amp;operatorStack) &amp;&amp; peek(&amp;operatorStack) != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                postfix[j++] = pop(&amp;operatorStack);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isEmpty(&amp;operatorStack) &amp;&amp; peek(&amp;operatorStack) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                pop(&amp;operatorStack); <span class="comment">// 弹出 &#x27;(&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;错误：括号不匹配\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;错误：无效的字符 &#x27;%c&#x27;\n&quot;</span>, infix[i]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(&amp;operatorStack)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (peek(&amp;operatorStack) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;错误：括号不匹配\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        postfix[j++] = pop(&amp;operatorStack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postfix[j] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 添加字符串终止符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前缀表达式及其求值方法"><a href="#前缀表达式及其求值方法" class="headerlink" title="前缀表达式及其求值方法"></a>前缀表达式及其求值方法</h2><p>前缀表达式又称为波兰表达式，它的特点是运算符在操作数的前面，如：$+ 1 <em> 2 3$，$- + 1 </em> + 2 3 4 5$，$+ 1 <em> 2 + 3 </em> 4 + 5 6$ 等等。</p><h3 id="前缀表达式的求值方法"><a href="#前缀表达式的求值方法" class="headerlink" title="前缀表达式的求值方法"></a>前缀表达式的求值方法</h3><p>前缀表达式的求值方法是：从右到左遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。</p><p>例如：$+ 1 * 2 3$ 的求值过程如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">读入字符</th><th style="text-align:center">当前栈</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">读入 3，进栈</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">3 2</td><td style="text-align:center">读入 2，进栈</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">6</td><td style="text-align:center">读入 <em>，出栈 2 和 3，计算 2 </em> 3 = 6，将 6 进栈</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">6 1</td><td style="text-align:center">读入 1，进栈</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">7</td><td style="text-align:center">读入 +，出栈 1 和 6，计算 1 + 6 = 7，将 7 进栈</td></tr></tbody></table></div><h3 id="C-实现前缀表达式的求值"><a href="#C-实现前缀表达式的求值" class="headerlink" title="C++ 实现前缀表达式的求值"></a>C++ 实现前缀表达式的求值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOperator</span><span class="params">(<span class="type">const</span> string&amp; token)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isNumeric</span><span class="params">(<span class="type">const</span> string&amp; token)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">evaluatePrefixExpression</span><span class="params">(<span class="type">const</span> vector&lt;string&gt;&amp; tokens)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;欢迎使用前缀表达式求值程序！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入前缀表达式，操作符和操作数之间用空格分隔，支持+、-、*、/：&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;输入 q 退出程序&quot;</span> &lt;&lt; endl;</span><br><span class="line">        string input;</span><br><span class="line">        <span class="built_in">getline</span>(cin, input);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (input == <span class="string">&quot;q&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 用户输入了&quot;q&quot;，退出程序</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">istringstream <span class="title">iss</span><span class="params">(input)</span></span>;</span><br><span class="line">        vector&lt;string&gt; tokens;</span><br><span class="line"></span><br><span class="line">        string token;</span><br><span class="line">        <span class="keyword">while</span> (iss &gt;&gt; token) &#123;</span><br><span class="line">            tokens.<span class="built_in">push_back</span>(token);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tokens.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;错误：输入为空，请重新输入表达式。&quot;</span> &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;输入 q 退出程序&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 继续下一次循环</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> result = <span class="built_in">evaluatePrefixExpression</span>(tokens);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isnan</span>(result)) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;表达式结果为：&quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;错误：无法计算表达式结果，请检查表达式是否正确。&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;感谢使用前缀表达式求值程序！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOperator</span><span class="params">(<span class="type">const</span> string&amp; token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (token == <span class="string">&quot;+&quot;</span> || token == <span class="string">&quot;-&quot;</span> || token == <span class="string">&quot;*&quot;</span> || token == <span class="string">&quot;/&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isNumeric</span><span class="params">(<span class="type">const</span> string&amp; token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : token) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(c) &amp;&amp; c != <span class="string">&#x27;.&#x27;</span> &amp;&amp; c != <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">evaluatePrefixExpression</span><span class="params">(<span class="type">const</span> vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">double</span>&gt; operandStack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = tokens.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">const</span> string&amp; token = tokens[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isNumeric</span>(token)) &#123;</span><br><span class="line">            operandStack.<span class="built_in">push</span>(<span class="built_in">stod</span>(token));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isOperator</span>(token)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (operandStack.<span class="built_in">size</span>() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;错误：操作数不足，无法进行操作。&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">return</span> NAN;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">double</span> operand1 = operandStack.<span class="built_in">top</span>();</span><br><span class="line">            operandStack.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">double</span> operand2 = operandStack.<span class="built_in">top</span>();</span><br><span class="line">            operandStack.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (token == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">                operandStack.<span class="built_in">push</span>(operand1 + operand2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">                operandStack.<span class="built_in">push</span>(operand1 - operand2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">                operandStack.<span class="built_in">push</span>(operand1 * operand2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (operand2 == <span class="number">0</span>) &#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;错误：除数为零，无法进行除法操作。&quot;</span> &lt;&lt; endl;</span><br><span class="line">                    <span class="keyword">return</span> NAN;</span><br><span class="line">                &#125;</span><br><span class="line">                operandStack.<span class="built_in">push</span>(operand1 / operand2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;错误：无效的表达式元素 \&quot;&quot;</span> &lt;&lt; token &lt;&lt; <span class="string">&quot;\&quot;，请检查表达式是否正确。&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> NAN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (operandStack.<span class="built_in">size</span>() != <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;错误：操作数和操作符数量不匹配，无法计算表达式结果。&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> NAN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> operandStack.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-实现前缀表达式的求值-1"><a href="#C-实现前缀表达式的求值-1" class="headerlink" title="C 实现前缀表达式的求值"></a>C 实现前缀表达式的求值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EXPRESSION_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable : 4996)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isOperator</span><span class="params">(<span class="type">const</span> <span class="type">char</span> token)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isNumeric</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* token)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">evaluatePrefixExpression</span><span class="params">(<span class="type">const</span> <span class="type">char</span>** tokens, <span class="type">int</span> numTokens)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;欢迎使用前缀表达式求值程序！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入前缀表达式，操作符和操作数之间用空格分隔，支持+、-、*、/：\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入 q 退出程序。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> input[MAX_EXPRESSION_SIZE];</span><br><span class="line">        fgets(input, <span class="keyword">sizeof</span>(input), <span class="built_in">stdin</span>);</span><br><span class="line">        input[<span class="built_in">strcspn</span>(input, <span class="string">&quot;\n&quot;</span>)] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 移除末尾的换行符</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input, <span class="string">&quot;q&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 用户输入了&quot;q&quot;，退出程序</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* delimiters = <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="type">char</span>* token = strtok(input, delimiters);</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* tokens[MAX_EXPRESSION_SIZE];</span><br><span class="line">        <span class="type">int</span> numTokens = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (token != <span class="literal">NULL</span> &amp;&amp; numTokens &lt; MAX_EXPRESSION_SIZE) &#123;</span><br><span class="line">            tokens[numTokens] = token;</span><br><span class="line">            numTokens++;</span><br><span class="line">            token = strtok(<span class="literal">NULL</span>, delimiters);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (numTokens == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;错误：输入为空，请重新输入表达式。\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入 q 退出程序。\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 继续下一次循环</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> result = evaluatePrefixExpression(tokens, numTokens);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isnan(result)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;表达式结果为：%g\n&quot;</span>, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;错误：无法计算表达式结果，请检查表达式是否正确。\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;感谢使用前缀表达式求值程序！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isOperator</span><span class="params">(<span class="type">const</span> <span class="type">char</span> token)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (token == <span class="string">&#x27;+&#x27;</span> || token == <span class="string">&#x27;-&#x27;</span> || token == <span class="string">&#x27;*&#x27;</span> || token == <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isNumeric</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* token)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; token[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(token[i]) &amp;&amp; token[i] != <span class="string">&#x27;.&#x27;</span> &amp;&amp; token[i] != <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">evaluatePrefixExpression</span><span class="params">(<span class="type">const</span> <span class="type">char</span>** tokens, <span class="type">int</span> numTokens)</span> &#123;</span><br><span class="line">    <span class="type">double</span> operandStack[MAX_EXPRESSION_SIZE];</span><br><span class="line">    <span class="type">int</span> top = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = numTokens - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* token = tokens[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isNumeric(token)) &#123;</span><br><span class="line">            operandStack[++top] = atof(token);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isOperator(token[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (top &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;错误：操作数不足，无法进行操作。\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> NAN;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">double</span> operand1 = operandStack[top--];</span><br><span class="line">            <span class="type">double</span> operand2 = operandStack[top--];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (token[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                operandStack[++top] = operand1 + operand2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                operandStack[++top] = operand1 - operand2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                operandStack[++top] = operand1 * operand2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> (operand2 == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;错误：除数为零，无法进行除法操作。\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> NAN;</span><br><span class="line">                &#125;</span><br><span class="line">                operandStack[++top] = operand1 / operand2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;错误：无效的操作符 \&quot;%s\&quot;，请检查表达式是否正确。\n&quot;</span>, token);</span><br><span class="line">                <span class="keyword">return</span> NAN;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;错误：无效的表达式元素 \&quot;%s\&quot;，请检查表达式是否正确。\n&quot;</span>, token);</span><br><span class="line">            <span class="keyword">return</span> NAN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (top != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;错误：操作数和操作符数量不匹配，无法计算表达式结果。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> NAN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> operandStack[top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前缀表达式的转换方法-中缀转前缀"><a href="#前缀表达式的转换方法-中缀转前缀" class="headerlink" title="前缀表达式的转换方法(中缀转前缀)"></a>前缀表达式的转换方法(中缀转前缀)</h3><p>将中缀表达式转换为前缀表达式的方法是：从右到左遍历中缀表达式的每个数字和符号，若是数字就输出，若是符号，则判断其与栈顶符号的优先级，是右括号或优先级不高于栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出前缀表达式为止。</p><p>例如：$1 + (2 + 3) * 4 - 5$ 的转换过程如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">读入字符</th><th style="text-align:center">当前栈</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">5</td><td style="text-align:center">5</td><td style="text-align:center">读入 5，进栈</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">读入 -，进栈</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">- 4</td><td style="text-align:center">读入 4，进栈</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">*</td><td style="text-align:center">读入 *，进栈</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">+</td><td style="text-align:center">读入 +，进栈</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">+ 3</td><td style="text-align:center">读入 3，进栈</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">+</td><td style="text-align:center">读入 +，进栈</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">+ 2</td><td style="text-align:center">读入 2，进栈</td></tr><tr><td style="text-align:center">(</td><td style="text-align:center">+ (</td><td style="text-align:center">读入 (，进栈</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">+ ( 1</td><td style="text-align:center">读入 1，输出</td></tr><tr><td style="text-align:center">空</td><td style="text-align:center">+</td><td style="text-align:center">依次出栈 + 和 (，输出</td></tr></tbody></table></div><p>转换后的前缀表达式为：$- * + 1 2 3 4 5$。</p><h3 id="C-实现中缀表达式转前缀表达式"><a href="#C-实现中缀表达式转前缀表达式" class="headerlink" title="C++ 实现中缀表达式转前缀表达式"></a>C++ 实现中缀表达式转前缀表达式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getOperatorPrecedence</span><span class="params">(<span class="type">char</span> op)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOperator</span><span class="params">(<span class="type">char</span> token)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOperand</span><span class="params">(<span class="type">char</span> token)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">infixToPrefix</span><span class="params">(<span class="type">const</span> string&amp; infixExpression)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;欢迎使用中缀表达式转前缀表达式程序！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入中缀表达式或输入 &#x27;q&#x27; 退出：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        string input;</span><br><span class="line">        <span class="built_in">getline</span>(cin, input);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (input == <span class="string">&quot;q&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 用户输入了&#x27;q&#x27;，退出程序</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string prefixExpression = <span class="built_in">infixToPrefix</span>(input);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!prefixExpression.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;前缀表达式为：&quot;</span> &lt;&lt; prefixExpression &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;错误：无法转换表达式，请检查表达式是否正确。&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;感谢使用中缀表达式转前缀表达式程序！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getOperatorPrecedence</span><span class="params">(<span class="type">char</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOperator</span><span class="params">(<span class="type">char</span> token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (token == <span class="string">&#x27;+&#x27;</span> || token == <span class="string">&#x27;-&#x27;</span> || token == <span class="string">&#x27;*&#x27;</span> || token == <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOperand</span><span class="params">(<span class="type">char</span> token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isalnum</span>(token);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">infixToPrefix</span><span class="params">(<span class="type">const</span> string&amp; infixExpression)</span> </span>&#123;</span><br><span class="line">    string prefixExpression;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; operatorStack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转中缀表达式，方便从右到左处理</span></span><br><span class="line">    string reversedInfix = infixExpression;</span><br><span class="line">    <span class="built_in">reverse</span>(reversedInfix.<span class="built_in">begin</span>(), reversedInfix.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> token : reversedInfix) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isOperand</span>(token)) &#123;</span><br><span class="line">            prefixExpression = token + prefixExpression;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isOperator</span>(token)) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!operatorStack.<span class="built_in">empty</span>() &amp;&amp; <span class="built_in">getOperatorPrecedence</span>(token) &lt; <span class="built_in">getOperatorPrecedence</span>(operatorStack.<span class="built_in">top</span>())) &#123;</span><br><span class="line">                prefixExpression = operatorStack.<span class="built_in">top</span>() + prefixExpression;</span><br><span class="line">                operatorStack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            operatorStack.<span class="built_in">push</span>(token);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            operatorStack.<span class="built_in">push</span>(token);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!operatorStack.<span class="built_in">empty</span>() &amp;&amp; operatorStack.<span class="built_in">top</span>() != <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                prefixExpression = operatorStack.<span class="built_in">top</span>() + prefixExpression;</span><br><span class="line">                operatorStack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!operatorStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                operatorStack.<span class="built_in">pop</span>(); <span class="comment">// 弹出匹配的右括号</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 括号不匹配</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!operatorStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (operatorStack.<span class="built_in">top</span>() == <span class="string">&#x27;(&#x27;</span> || operatorStack.<span class="built_in">top</span>() == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 括号不匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">        prefixExpression = operatorStack.<span class="built_in">top</span>() + prefixExpression;</span><br><span class="line">        operatorStack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prefixExpression;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-实现中缀表达式转前缀表达式-1"><a href="#C-实现中缀表达式转前缀表达式-1" class="headerlink" title="C 实现中缀表达式转前缀表达式"></a>C 实现中缀表达式转前缀表达式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable : 4996)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> arr[MAX_SIZE];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(Stack* s)</span> &#123;</span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Stack s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isFull</span><span class="params">(Stack s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.top == MAX_SIZE - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Stack* s, <span class="type">char</span> ch)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(*s)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack overflow!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;arr[++(s-&gt;top)] = ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">pop</span><span class="params">(Stack* s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(*s)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack underflow!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;arr[(s-&gt;top)--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">peek</span><span class="params">(Stack s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.arr[s.top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isOperator</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ch == <span class="string">&#x27;+&#x27;</span> || ch == <span class="string">&#x27;-&#x27;</span> || ch == <span class="string">&#x27;*&#x27;</span> || ch == <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">precedence</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">infixToPrefix</span><span class="params">(<span class="type">char</span>* infix, <span class="type">char</span>* prefix)</span> &#123;</span><br><span class="line">    Stack operators;</span><br><span class="line">    initStack(&amp;operators);</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">strlen</span>(infix) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">char</span> ch = infix[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) || (ch &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;z&#x27;</span>) || (ch &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;Z&#x27;</span>)) &#123;</span><br><span class="line">            prefix[j++] = ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            push(&amp;operators, ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!isEmpty(operators) &amp;&amp; peek(operators) != <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                prefix[j++] = pop(&amp;operators);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isEmpty(operators) &amp;&amp; peek(operators) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                pop(&amp;operators);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isOperator(ch)) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!isEmpty(operators) &amp;&amp; precedence(ch) &lt;= precedence(peek(operators))) &#123;</span><br><span class="line">                prefix[j++] = pop(&amp;operators);</span><br><span class="line">            &#125;</span><br><span class="line">            push(&amp;operators, ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(operators)) &#123;</span><br><span class="line">        prefix[j++] = pop(&amp;operators);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prefix[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    _strrev(prefix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> infix[MAX_SIZE], prefix[MAX_SIZE];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入中缀表达式[不要留空格] (输入q退出): &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, infix);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(infix, <span class="string">&quot;q&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;退出计算器。\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        infixToPrefix(infix, prefix);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;前缀表达式: %s\n&quot;</span>, prefix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://rdququ.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</category>
      
      
      <category domain="https://rdququ.top/tags/C%E8%AF%AD%E8%A8%80-C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">C语言,C++,数据结构与算法</category>
      
      
      <comments>https://rdququ.top/posts/29455a3d/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>DiffusionModel原理学习笔记</title>
      <link>https://rdququ.top/posts/aa051d3a/</link>
      <guid>https://rdququ.top/posts/aa051d3a/</guid>
      <pubDate>Thu, 19 Oct 2023 08:41:53 GMT</pubDate>
      
      <description>&lt;p&gt;去噪自动编码器&lt;/p&gt;
&lt;p&gt;Diffusion model 是一种深度生成模型（无监督生成模型），它属于：&lt;br&gt;机器学习 -&amp;gt; 无监督学习 -&amp;gt; 概率模型 -&amp;gt; 生成模型&lt;br&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>去噪自动编码器</p><p>Diffusion model 是一种深度生成模型（无监督生成模型），它属于：<br>机器学习 -&gt; 无监督学习 -&gt; 概率模型 -&gt; 生成模型<br><span id="more"></span></p><p><img src="DM归属.png" alt="分类图"></p><p>概率模型是为了求得数据的后验概率$P(Y|X)$或者联合验概率$P(X,Y)$<br>对于监督学习而言，判别模型主要是求后验概率，也就是通过输入的特征X去求标签信息Y。生成模型主要是未了求得联合概率，对于X，求出X与不同标签之间的联合概率，取最大的那个标签作为预测结果。</p><h3 id="隐空间和隐变量-latent-space-hidden-variables"><a href="#隐空间和隐变量-latent-space-hidden-variables" class="headerlink" title="隐空间和隐变量 (latent space/hidden variables)"></a>隐空间和隐变量 (latent space/hidden variables)</h3><p><img src="隐变量.png" alt="间接"></p><p>a 直接到 b 比较困难，所以可以通过间接变量 c 来实现。</p><h3 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h3><p><img src="autoencoder.png" alt="autoencoder"></p><p><img src="diffusion.png" alt="diffusion"> </p><p>$X_0$ 是原始的输入图像，$X_T$ 是 total noise</p><p>在从右往左的过程中的每一步都会给样本增加一个小的满足高斯分布的噪声，整个过程为一个一阶马尔可夫过程，这是一个正向扩散过程，如果把它反过来，也就是从左往右看上图，那么就是一个反向扩散过程。</p><p>正向分布的时候添加的噪声都是符合高斯分布的，那么这些噪声合并后仍然是处于高斯分布的。但是当我们逆推这一过程的时候，除非我们拥有整体数据集合，不然我们是没有办法直接求解的，通常来说我们会训练一个模型 $p<em>θ$来预测反向扩散过程的条件概率 $q(x</em>{t-1}|x<em>t)$.<br>通过这个模型，我们输入 $X_t$ 和 $t$ 可以预测出 $X</em>{t-1}$ 的条件概率分布(如果正向扩散每步增加的噪声够小,它可以被视为高斯分布)的均值 $μ<em>θ(x_t,t)$和方差 $\sum</em>θ(x<em>t,t)$，基于预测值,我们可以从 $x</em>{t-1}$的高斯分布 $p<em>θ(x</em>{t-1}|x<em>t)$中采样出 $X</em>{t-1}$ 的值，从而得到 $x_{t-1}$ 的一个可能的取值,后面以此类推,我们就可以逐步去噪生成一张图片.</p><p>这个模型在 DDPM 中是 U-net 网络 PixelCNN++.</p><p>简单来说,这里的反向传播,或者说是 decoder,又或者说是生成器,其实就是在简单的拟合正向部分的逆过程的每一小步.</p><p>当然,训练我们的噪声预测器需要大量的数据集,不过这仍然不值得担心,因为正向传播的每一步我们都是在给图像逐步加噪,我们可以轻松地获取从0到T每个过程的所有样本.<br><img src="UNet.png" alt="UNet"><br>上面这张图非常清晰的展现了 U-net 的训练.</p>]]></content:encoded>
      
      
      
      <category domain="https://rdququ.top/tags/DiffusionModel-ML-AI/">DiffusionModel, ML, AI</category>
      
      
      <comments>https://rdququ.top/posts/aa051d3a/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
