<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>test</title>
      <link href="/posts/d87f7e0c/"/>
      <url>/posts/d87f7e0c/</url>
      
        <content type="html"><![CDATA[<h1 id="贝塞尔曲线">贝塞尔曲线</h1><p>平滑的曲线，计算机图形学的天堂，线性代数的产物 同时这篇文章也是关于嵌入html与js的测试</p><span id="more"></span><p><strong>贝塞尔曲线方程</strong></p><p>$ P(t)= {<em>{i=0}^{n}} P_iB</em>{i,n}(t),t$</p><p>对于$ iN^* $</p><p>$ B_{i,n}(t)=C_n<sup>it</sup>i(1-t)<sup>{n-i}=t</sup>i(1-t)^{n-i} $</p><h2 id="推导过程">推导过程</h2><p>To be continue</p><h2 id="演示程序">演示程序</h2><p>搬运自知乎id 何方 原地址https://zhuanlan.zhihu.com/p/180508343 侵权删，等博主学习了一些前端后，会自己重写</p><body><style>        .buttonContainer button {            border-radius: 5px;            border: none;            background-color: #66ccff31;            height: 30px;            width: 54px;            box-shadow: 2px 2px 2px 2px rgba(0 0 0 / 0.4);            margin-right: 10px;        }    </style><canvas id="canvas" style="border: 1px solid" width="500%" height="500%"></canvas><div class="buttonContainer"><pre><code>    &lt;div&gt;        &lt;button id=&quot;draw&quot;&gt;画图&lt;/button&gt;        &lt;button id=&quot;reDraw&quot;&gt;重画&lt;/button&gt;        &lt;button id=&quot;clear&quot;&gt;清空&lt;/button&gt;        &lt;button id=&quot;radom&quot;&gt;随机&lt;/button&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script&gt;    const cv = document.getElementById(&quot;canvas&quot;);    const draw = document.getElementById(&quot;draw&quot;);    const clear = document.getElementById(&quot;clear&quot;);    const reDraw = document.getElementById(&quot;reDraw&quot;);    if (/Mobi|Android|iPhone/i.test(navigator.userAgent)) &#123;        cv.height = 290;        cv.width = 290;    &#125;    let points = [];    const ctx = cv.getContext(&quot;2d&quot;);    let offset = 0;    let timer;    function calcMiddlePoint(p1, p2) &#123;        return &#123; x: (p2.x - p1.x) * offset + p1.x, y: (p2.y - p1.y) * offset + p1.y &#125;;    &#125;    let finalPoints = [];    function drawLine() &#123;        let last = &#123;&#125;        ctx.strokeStyle = &quot;red&quot;;        ctx.lineWidth = 3;        ctx.beginPath();        finalPoints.forEach((&#123; x, y &#125;, index) =&gt; &#123;            if (index === 0) &#123;                ctx.moveTo(x, y)            &#125; else &#123;                ctx.lineTo(x, y)            &#125;        &#125;);        ctx.stroke();    &#125;    function drawLines(ps, color) &#123;        if (ps.length &lt; 2) &#123;            const &#123; x, y &#125; = ps[0];            finalPoints.push(&#123; x, y &#125;);            drawLine();            return;        &#125;        ctx.lineWidth = 1;        ctx.strokeStyle = color || &quot;green&quot;;        ctx.beginPath();        for (let i = 0; i &lt; ps.length; i++) &#123;            const &#123; x, y &#125; = ps[i];            if (i === 0) &#123;                ctx.moveTo(x, y);            &#125; else &#123;                ctx.lineTo(x, y);            &#125;        &#125;        ctx.stroke();        const pps = [];        for (let i = 0; i &lt; ps.length - 1; i++) &#123;            pps.push(calcMiddlePoint(ps[i], ps[i + 1], .5));        &#125;        drawLines(pps)    &#125;    function doDraw() &#123;        if (points.length &lt; 2) &#123;            alert(`无法画图，请至少指定2个点`);            return;        &#125;        timer &amp;&amp; clearInterval(timer);        drawLines(points, &#39;blue&#39;);        timer = setInterval(() =&gt; &#123;            offset += 0.001;            window.requestAnimationFrame(() =&gt; &#123;                ctx.clearRect(0, 0, cv.width, cv.height);                drawLines(points, &#39;blue&#39;);            &#125;);            if (offset &gt;= 1) &#123;                clearInterval(timer);            &#125;        &#125;, 1);    &#125;    reDraw.addEventListener(&quot;click&quot;, function () &#123;        finalPoints = [];        offset = 0;        ctx.clearRect(0, 0, cv.width, cv.height);        doDraw();    &#125;);    draw.addEventListener(&quot;click&quot;, doDraw);    clear.addEventListener(&quot;click&quot;, () =&gt; &#123;        points = [];        finalPoints = [];        offset = 0;        ctx.clearRect(0, 0, cv.width, cv.height);    &#125;);    cv.addEventListener(&quot;click&quot;, function (e) &#123;        points.push(&#123; x: e.offsetX, y: e.offsetY &#125;);        console.log(&quot;point:&quot;, &#123; x: e.offsetX, y: e.offsetY &#125;);        ctx.fillStyle = &quot;black&quot;;        ctx.beginPath();        ctx.arc(e.offsetX, e.offsetY, 2, 0, Math.PI * 2);        ctx.fill();    &#125;);    radom.addEventListener(&quot;click&quot;, () =&gt; &#123;        points = [];        finalPoints = [];        offset = 0;        ctx.clearRect(0, 0, cv.width, cv.height);        for (let i = 0; i &lt; 10; i++) &#123;            points.push(&#123; x: Math.random() * cv.width, y: Math.random() * cv.height &#125;)        &#125;        doDraw();    &#125;);&lt;/script&gt;</code></pre></body>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>不透明物体与半透明物体边缘算法与Unity Shader Graph 实现</title>
      <link href="/posts/223f372/"/>
      <url>/posts/223f372/</url>
      
        <content type="html"><![CDATA[<h2 id="前置知识">前置知识</h2><span id="more"></span><h3 id="归一化空间坐标-ndknormalized-device-coordinates">归一化空间坐标 NDK(Normalized Device Coordinates)</h3><p>在齐次裁剪空间的基础上进行透视除法或称齐次除法, 得到的坐标叫做NDC空间坐标。</p><p><a href="https://zhuanlan.zhihu.com/p/102758967">一篇文章彻底弄懂齐次裁剪 - 知乎 (zhihu.com)</a></p><h4 id="透视除法-齐次除法perspective-division-homogeneous-division">透视除法-齐次除法(<strong>perspective division</strong>-<strong>homogeneous division)</strong></h4><p>就是将齐次裁剪空间坐标positionCS的X,Y,Z分量都除以W分量。</p><p><a href="https://www.jianshu.com/p/7e701d7bfd79">写给大家看的“透视除法” —— 齐次坐标和投影 - 简书 (jianshu.com)</a></p><p><img src="https://pic4.zhimg.com/80/v2-4baca450c51c7f0eea873c42eeda0eef_720w.webp" /></p><h2 id="算法原理">算法原理</h2><h2 id="unity-shader-graph-实现">Unity Shader Graph 实现</h2><h3 id="scenedepth">SceneDepth</h3><blockquote><p>Provides access to the current <strong>Camera</strong> 's depth buffer using input <strong>UV</strong> , which is expected to be normalized screen coordinates. Note: Depth buffer access requires depth buffer to be enabled on the active <strong>Render Pipeline</strong> . This process is different per <strong>Render Pipeline</strong> . It is recommended you read the documentation of your active <strong>Render Pipeline</strong> for information on enabling the depth buffer. If the depth buffer is unavailable this <a href="https://link.zhihu.com/?target=https%3A//docs.unity3d.com/Packages/com.unity.shadergraph%406.9/manual/Node.html">Node</a> will return mid grey.</p></blockquote><p>也就是说SceneDepth Node是对深度纹理进行获取的节点，只不过获取的方法不同，而深度纹理中存储的是NDC坐标的深度值。</p><figure><img src="https://pic4.zhimg.com/80/v2-199f0cb63bdba7f81de4c826056dcbff_720w.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li>Linear01获取的是线性的范围为[0,1]的深度值。 &gt; 想要把Raw Depth转换成线性 ，并且从近平面到远平面为0-1的深度，就需要Linear 01 Depth，这时0.5深度就是视锥体一半的位置。 &gt;</li><li>Raw也就是深度纹理中存储的非线性，范围为[0,1]的值。 &gt; 表示深度缓冲的原始数据，普通的深度缓冲使用32位的浮点数表示深度，相机近平面的深度为0，远平面的深度为1。而Unity 使用了Reversed Z，这就使得近平面深度为1，而远平面深度为0，另外，如果相机的投影矩阵不是正交矩阵，那么深度缓冲中的深度就不是线性的，举个例子就是深度0.5代表的地方并不是视锥体一半的位置。 &gt;</li><li>Eye获取的是视角空间下的线性深度值，范围为[near, far]。 &gt; Linear Eye Depth中深度为1表示沿着摄像机Z轴，距离为1个单位的地方，2就是距离两个单位的地方，以此类推。 &gt;</li></ul><h3 id="screenposition">ScreenPosition</h3><blockquote><p>Provides access to the mesh vertex or fragment's <strong>Screen Position</strong> .</p></blockquote><figure><img src="https://pic3.zhimg.com/80/v2-439252aa4b98dac54ced99bf1460a58e_720w.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li>ScreenPosition在Default选项下会进行齐次除法运算（即除以w分量），这里的w范围为[0,1],也就是NDC下的w分量。经过透视除法的，左下角是（0，0）右上角是（1，1）的屏幕空间</li><li>在Raw选项下，不会进行齐次除法运算,这里的w范围是[Near, Far],是Clip Space中的w分量。未经过透视除法的，左下角是（0，0）右上角是（1，1）的屏幕空间</li><li>Center: 经过透视除法的，左下角是（-1，-1）右上角是（1，1）的屏幕空间</li><li>Tiled: 经过透视除法的，分成上下均等的四块组成，每块左下角是（0，0）右上角是（1，1）的屏幕空间</li></ul><p>在这里ScreenPosition的w分量的含义也就是ClipSpace下的w分量，范围是[Near, Far],而当xy除以w分量后，越远的顶点也就会除以越大的w分量，就会产生透视现象。</p><h3 id="存疑之处与我的观点证明">存疑之处与我的观点/证明</h3><p>博主<a href="https://www.zhihu.com/people/lute-li">Lute Li</a>，认为</p><blockquote><p>（Scene Depth是除开透明模型之外的深度，Screen Position是所有模型的深度，相减就是边缘）</p></blockquote><p>出处<a href="https://zhuanlan.zhihu.com/p/109547098">从头学ShaderGraph 5-护盾材质 - 知乎 (zhihu.com)</a></p><p><img src="https://pic2.zhimg.com/80/v2-fea83d5ed062c6bfe5dc8221e2d5d999_720w.webp" /></p><p><strong>(Vertex Shader) =&gt; Clip Space =&gt; (透视除法) =&gt; NDC =&gt; (视口变换) =&gt; Window Space =&gt; (Fragment Shader)</strong></p><p>现象很好观察，但是不知道原理，翻遍了官方文档和网上的教程也没能得到一个足够有说服力的解释，现在可以知道 SceneDepth 的 Eye 获取的是视角空间下的线性深度值，范围为[near, far]，ScreenPosition 的 w 分量是是 Clip Space 中未经过透视除法的值，范围也是[near, far]。我们知道物体自Eye/View/Camera Space(这玩意名字真多)到Cliping Space 要经过一次透视变换，或者说透视除法，所以实际上，Screen Graph 的 w 分量也许就是 Eye Space 下到相机的距离(不是深度，所以也存储了透明物体的距离)</p><figure><img src="image/不透明物体与半透明物体边缘算法与Unity-Shader-Graph-实现/1702390346535.png" alt="1702390346535" /><figcaption aria-hidden="true">1702390346535</figcaption></figure><p>上图的实验一定程度上看可以证明上文的观点。</p><p>有趣的是，当我们把 Surface Type 修改为Transparent, 场景中的透明与不透明物体的交界处出现了一道淡淡的白线</p><figure><img src="image/不透明物体与半透明物体边缘算法与Unity-Shader-Graph-实现/1702390608834.png" alt="1702390608834" /><figcaption aria-hidden="true">1702390608834</figcaption></figure><p>我们将 Comparison 节点的输入值 B 调大，交界处出现了明显的白线</p><figure><img src="image/不透明物体与半透明物体边缘算法与Unity-Shader-Graph-实现/1702390681409.png" alt="1702390681409" /><figcaption aria-hidden="true">1702390681409</figcaption></figure><figure><img src="image/不透明物体与半透明物体边缘算法与Unity-Shader-Graph-实现/1702390730401.png" alt="1702390730401" /><figcaption aria-hidden="true">1702390730401</figcaption></figure><p>我们知道，初始输出的两个节点的取值范围都是[n,f]，所以当我们把对比节点的输入值B调到1的时候，边界就很明显了。</p><p>现在，结果已经呼之欲出了，Scene Depth 节点的 Eye 输出的是深度值，我们知道，透明物体默认不会写入深度缓冲，Screen Position 输出的是简单的距离，故而相减可以得到边界。</p><h2 id="参考资料与引用">参考资料与引用</h2><ol type="1"><li><a href="https://zhuanlan.zhihu.com/p/535898515">unity urp 20 SceneDepth和ScreenPosition.w - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/347698766">Shader Graph中的Scene Depth和Screen Position - 知乎 (zhihu.com)</a></li><li><a href="https://www.bilibili.com/video/BV1sa411C7Xd/">2022版Unity Shader Graph教程04 水面 (上) 超简单ShaderGraph入门_哔哩哔哩_bilibili</a></li><li><a href="https://zhuanlan.zhihu.com/p/102758967">一篇文章彻底弄懂齐次裁剪 - 知乎 (zhihu.com)</a></li><li><a href="https://www.jianshu.com/p/7e701d7bfd79">写给大家看的“透视除法” —— 齐次坐标和投影 - 简书 (jianshu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/493733502">Unity Shader Graph 中深度纹理（Depth Texture）和屏幕空间坐标（Screen Position） - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/109547098">从头学ShaderGraph 5-护盾材质 - 知乎 (zhihu.com)</a></li><li><a href="https://carmencincotti.com/2022-05-02/homogeneous-coordinates-clip-space-ndc/#homogeneous-coordinates">Homogeneous Coordinates, Clip Space, and NDC | WebGPU | Carmen's Graphics Blog --- 齐次坐标、裁剪空间和 NDC |网络GPU |Carmen 的图形博客 (carmencincotti.com)</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity_GC_浅谈</title>
      <link href="/posts/e44777a7/"/>
      <url>/posts/e44777a7/</url>
      
        <content type="html"><![CDATA[<h2 id="unity-底层的内存分配">Unity 底层的内存分配</h2><h3 id="托管内存">托管内存</h3><p>Mono 和 IL2CPP 的脚本虚拟机(virtual machines =&gt; VMs)实现了托管内存系统(脚本内存系统)。这些VMs提供了数种受控内存环境。</p><h4 id="managed-heap-托管堆">Managed Heap 『托管堆』</h4><p>GC 自动控制的内存区域。</p><h4 id="scripting-stack-脚本栈">Scripting Stack 『脚本栈』</h4><p>在应用程序进入和退出任何代码范围时构建和展开</p><h4 id="native-vm-memory-本地虚拟机内存">Native VM Memory 『本地虚拟机内存』</h4><p>包含与 Unity 脚本层相关的内存，大多数情况下不需要主动管理。</p><h3 id="c-非托管内存">C# 非托管内存</h3><p>允许编写 C# 代码来访问本机内存以微调内存分配。 可以使用 Unity 核心 API 中的 Unity.Collections 命名空间（包括 NativeArray）和 Unity Collections 包中的数据结构来访问 C# 非托管内存。如果使用 Unity 的 C# Job 系统或 Burst，则必须使用 C# 非托管内存。</p><h3 id="native-memory-本机内存">Native Memory 『本机内存』</h3><h2 id="unity-应用的-gc-算法">Unity 应用的 GC 算法</h2><h3 id="boehmgc">BoehmGC</h3><h4 id="boehmgc-算法原理">BoehmGC 算法原理</h4><h4 id="boehmgc-的内存管理">BoehmGC 的内存管理</h4><h4 id="boehmgc-算法实现">BoehmGC 算法实现</h4><h4 id="mono-与-il2cpp-中的-boehmgc">MONO 与 IL2CPP 中的 BoehmGC</h4><h3 id="渐进式-gc">渐进式 GC</h3><h2 id="参考资料">参考资料</h2><ol type="1"><li><a href="https://zhuanlan.zhihu.com/p/623849906">Unity 垃圾回收GC的原理？</a></li><li><a href="https://zhuanlan.zhihu.com/p/265217138">Unity GC 学习总结</a></li><li><a href="https://zhuanlan.zhihu.com/p/41023320">解读MONO内存管理和回收！</a></li><li><a href="https://zhuanlan.zhihu.com/p/41398507">解读MONO内存管理：BOEHM GC原理及总结</a></li><li><a href="https://juejin.cn/post/6966954993869914119">Unity3D托管堆BoehmGC算法学习-内存分配篇</a></li><li><a href="https://juejin.cn/post/6968400262629163038">Unity3D托管堆BoehmGC算法学习-垃圾回收篇</a></li><li><a href="https://zhuanlan.zhihu.com/p/381859536?">【笔记】Unity内存分配和回收的底层原理</a></li><li><a href="https://docs.unity3d.com/Manual/performance-memory-overview.html">Memory in Unity Unity</a></li><li><a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">Garbage collection (computer science)</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UnityshaderGraph学习2021版</title>
      <link href="/posts/1fbb4100/"/>
      <url>/posts/1fbb4100/</url>
      
        <content type="html"><![CDATA[<p>学习笔记 <span id="more"></span></p><h2 id="创建">创建</h2><p>选择 URP 模板创建不需要配置环境 普通 3D 项目，包管理器安装 Universal RP, visual effect graph，设置中正常配置 Graphics</p><h2 id="光照模型">光照模型</h2><p>Create =&gt; ShaderGraph =&gt; URP =&gt; Lit Shader Graph</p><p>输入属性节点： <img src="输入属性节点.png" alt="输入属性节点" /></p><p>属性设置： <img src="属性设置.png" alt="属性设置" /></p><ul><li>Precision [精度] [single/half] half 性能更好</li></ul><p>在 Universal 中</p><ul><li>Material [材质]<ul><li>[sprite Custom] 自定义精灵</li><li>[sprite Lit] 精灵光照</li><li>[sprite Unlit] 精灵非光照</li><li>[Decal] 贴花</li><li>[Lit] 光照</li><li>[Unlit] 非光照</li></ul></li><li>Allow Material Override [允许材质覆盖] [勾选] 可以通过材质检查器修改某些图形属性。</li><li>workflow [工作流] [Specular/Metallic] [勾选] 镜面高光/金属工作流</li><li>Surface Type [表面类型] [Opaque/Transparent] [半透明/不透明]</li><li>Render Face [渲染面] [Front/Back/Double] [正面/背面/双面]</li><li>Depth Write [深度写入] [Auto/Force Enabled/Force Disabled] [自动/强制开启/强制关闭]</li><li>Depth Test [深度测试] [Never/Less/Equal/LessEqual/Greater/NotEqual/GreaterEqual/Always] [从不/小于/等于/小于等于/大于/不等于/大于等于/总是]</li><li>Alpha Clipping [Alpha裁剪] [勾选]</li><li>Receive Shadows [接收阴影] [勾选]</li><li>Fragment Normal Space [片段法线空间] [Tangent/World/View] [切线/世界/视图]</li><li>Clear Coat [清漆] [勾选]</li><li>Custom Editor GUI [自定义编辑器GUI]</li><li>Supports VFXGRAph [支持VFXGRAph] [勾选]</li></ul><p>顶点着色器: <img src="顶点着色器.png" alt="顶点着色器" /></p><p>片段着色器: <img src="片元着色器.png" alt="片元着色器" /></p><p>乘法节点 Multiply: 颜色叠加</p><h3 id="fragment">Fragment</h3><h4 id="base-color">Base Color</h4><p>主贴图，展现了模型的基本纹理 可以新建一个 Texture2D 属性，然后将其作为输入 <img src="UnityShaderGraphBaseColor.png" alt="UnityShaderGraphBaseColor" /></p><p>MainTexture 保持默认</p><h4 id="normal">Normal</h4><figure><img src="UnityShaderGraphNormal.png" alt="UnityShaderGraphNormal" /><figcaption aria-hidden="true">UnityShaderGraphNormal</figcaption></figure><p>注意 Sample Texture 2D 的 Type 要设置为 Normal NormalTexture 的 Mode 选择 Normal Map</p><h4 id="metallic">Metallic</h4><p><img src="UnityShaderGraphMetallic.png" alt="UnityShaderGraphMetallic" /> 保持默认</p><h4 id="smoothness">Smoothness</h4><figure><img src="UnityShaderGraphSmoothness.png" alt="UnityShaderGraphSmoothness" /><figcaption aria-hidden="true">UnityShaderGraphSmoothness</figcaption></figure><p>输出金属光泽度的 Alpha 通道与 Smoothness 通过 Multiply 乘法节点相乘, 得到输出值</p><h4 id="emission">Emission</h4><p><img src="UnityShaderGraphEmission.png" alt="UnityShaderGraphEmission" /> 自发光贴图与类型为 Boolean Keywork 的 EmissiveTexture 相乘来控制是否自发光，得到其输出值与 EmissionColor 相乘得到最终的输出值</p><h4 id="ao">AO</h4><p><img src="UnityShaderGraphAO.png" alt="UnityShaderGraphAO" /> 保持默认</p><h3 id="sub-graph">Sub Graph</h3><p>框选中对应节点右击 Convert to =&gt; Sub-graph</p><h3 id="轮廓光边缘光">轮廓光/边缘光</h3><p>Fresnel Effect</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AABB_Plane_intersection原理详解及Unity实现</title>
      <link href="/posts/2c23d1d4/"/>
      <url>/posts/2c23d1d4/</url>
      
        <content type="html"><![CDATA[<p>起因是我在学习 runtime 的 mesh 切割算法，需要判断目标 mesh 是否和切面相交（不相交的话我就不需要去处理了） <span id="more"></span> ## 前提知识</p><p>Unity 的 mesh 和 collider 都使用 AABB 包围盒</p><h3 id="什么是-aabb-包围盒">什么是 AABB 包围盒？</h3><p>AABB ==&gt; Axis Aligned Bounding Box (轴对齐边界框)</p><p>AABB（轴对齐边界框）是一个 3D 框。它的宽度/高度/深度不必相等，但宽度始终与 X 轴对齐，高度与 Y 轴对齐，深度与 Z 轴对齐。也就是说，这个盒子是不能旋转的。</p><h3 id="如何表示-aabb">如何表示 AABB？</h3><p>有两种常见的方法，存储最左边和最右边的角，或者存储中心点和盒子在每侧延伸多远的向量。</p><p>第一种：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> AABB</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Vector3 min;</span><br><span class="line">    <span class="keyword">public</span> Vector3 max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> AABB</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Vector3 center;</span><br><span class="line">    <span class="keyword">public</span> Vector3 extents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img src="AABB表示法.png" alt="AABB表示法" /><figcaption aria-hidden="true">AABB表示法</figcaption></figure><h2 id="算法">算法</h2><p>为了测试 AABB 和平面是否相交，我们首先必须将 AABB 的每个顶点投影到平面的法线上。这使我们 AABB 的所有顶点都在一条线上。</p><p>然后，我们检查离平面最远的顶点。如果与顶点对角线相对的顶点位于平面的另一侧，则我们有一个交点。</p><p>通用的 C# 代码如下，无论你的 AABB 是如何表示的(max/min 或 center/extents)，只需要稍作修改：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Test if AABB b intersects plane p</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">TestAABBPlane</span>(<span class="params">AABB b, Plane p</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Convert AABB to center-extents representation</span></span><br><span class="line">    Point c = (b.max + b.min) * <span class="number">0.5f</span>; <span class="comment">// Compute AABB center</span></span><br><span class="line">    Point e = b.max - c; <span class="comment">// Compute positive extents</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute the projection interval radius of b onto L(t) = b.c + t * p.n</span></span><br><span class="line">    <span class="built_in">float</span> r = e[<span class="number">0</span>]*Abs(p.n[<span class="number">0</span>]) + e[<span class="number">1</span>]*Abs(p.n[<span class="number">1</span>]) + e[<span class="number">2</span>]*Abs(p.n[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute distance of box center from plane</span></span><br><span class="line">    <span class="built_in">float</span> s = Dot(p.n, c) - p.d;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Intersection occurs when distance s falls within [-r,+r] interval</span></span><br><span class="line">    <span class="keyword">return</span> Abs(s) &lt;= r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="让我们来解析这段代码">让我们来解析这段代码</h3><ol type="1"><li>函数传入了目标 Mesh 的 AABB，和目标平面</li><li>进入后的两行假设你的 AABB 是用 max/min 表示的，如果你可以轻松调取 AABB 的 center 和 extents，那么这两行是可以被跳过的</li><li>下一段代码计算了 AABB 的投影半径，这个半径是 AABB 投影到平面法线上的最大距离。</li><li>其取 AABB 的范围和平面法线的绝对值的点积，用于确保计算出的长度是正值，因为两个向量中的元素都是正值或零。<span class="math display">\[n&#39; = (\lvert n_{x} \rvert,\lvert n_{y} \rvert,\lvert n_{z} \rvert) \\ \vec{e} \cdot \vec{n&#39;} = \lvert\vec{e} \rvert \lvert\vec{n&#39;} \rvert \cos \theta \\ \lvert\vec{n&#39;} \rvert =1 \\\vec{e} \cdot \vec{n&#39;} = \lvert\vec{e} \rvert  \cos \theta\]</span></li><li>下面计算了 AABB 中心点到平面的距离，计为 s</li><li>最后的返回值即为 AABB 自身在平面法线上的距离和其中心到平面距离长短的判断</li></ol><h3 id="unity-实现">Unity 实现</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">BoundPlaneIntersect</span>(<span class="params">Mesh mesh, <span class="keyword">ref</span> Plane plane</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Compute projection interval radius</span></span><br><span class="line">        <span class="built_in">float</span> r = mesh.bounds.extents.x * Mathf.Abs(plane.normal.x) +</span><br><span class="line">            mesh.bounds.extents.y * Mathf.Abs(plane.normal.y) +</span><br><span class="line">            mesh.bounds.extents.z * Mathf.Abs(plane.normal.z);<span class="comment">//做点乘，得出mesh包围盒的范围在平面法线上的投影，包围盒在平面法线方向上的最大距离</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Compute distance of box center from plane</span></span><br><span class="line">        <span class="built_in">float</span> s = Vector3.Dot(plane.normal, mesh.bounds.center) - (-plane.distance);<span class="comment">//前面点乘得mesh中心在平面法线上的投影，这是为了确保计算出的距离和后面的平面距离在同一方向</span></span><br><span class="line">        <span class="comment">//如果法线面朝内，后- (-plane.distance)为正，前mesh中心在与相对原点相交且与平面平行的平面‘靠近平面的一侧，Vector3.Dot(plane.normal, mesh.bounds.center)为负，符合逻辑</span></span><br><span class="line">        <span class="comment">//因为mesh中心和平面在同一侧，距离为相见</span></span><br><span class="line">        <span class="comment">//若mesh中心在与 相对原点相交且与平面平行的平面‘ 远离平面的一侧，就是说mesh中心与平面中间相隔了一个原点，那么前后就都是同号，符合逻辑</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Intersection occurs when distance s falls within [-r,+r] interval</span></span><br><span class="line">        <span class="keyword">return</span> Mathf.Abs(s) &lt;= r;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料">参考资料</h2><ol type="1"><li><a href="https://gdbooks.gitbooks.io/3dcollisions/content/Chapter1/aabb.html">AABB - Axis Aligned Bounding Box</a></li><li><a href="https://docs.unity.cn/cn/2021.3/ScriptReference/Bounds.html">Bounds-Unity_Documentation</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity底层如何处理C#</title>
      <link href="/posts/c896f832/"/>
      <url>/posts/c896f832/</url>
      
        <content type="html"><![CDATA[<h2 id="关键词">关键词</h2><ul><li>.NET mono 虚拟机</li><li>IL2CPP <span id="more"></span> ### 为什么选择 mono</li></ul><p>Mono 是一个开源的 .NET 框架的实现，它可以在 Linux、Mac、Windows 等平台上运行，而且可以在这些平台上编译出可执行文件。</p><p>开源、跨平台、Mono的开发工具( MonoDevelop 现在已被弃用)</p><h3 id="为什么推出-il2cpp">为什么推出 IL2CPP</h3><ul><li>Mono 没有合法身份， 微软收购之后的版权问题</li><li>Mono 虚拟机 解释执行 .NET 字节码，效率低</li><li>有些平台不允许内置 .net 虚拟机 (eg. iOS)</li><li>如果有新的平台出现，Mono 难以为其提供支持(跨不了平台咯)，移植很麻烦(eg. WebGL)</li></ul><p>IL: Intermediate Language .NET框架中间语言, .NET字节码 IL2CPP: IL to C++，将IL转换为C++代码 --&gt; 编译为可执行文件 --&gt; native platform</p><p>Unity:</p><ol type="1"><li>Unity C/C++ 以及 native 的开发 --&gt; 跨平台的 runtime (xcode, android studio)</li><li>Unity 开发者脚本语言(C#) --&gt; .NET字节码 --&gt; .dll --&gt; IL code --&gt; IL2CPP --&gt; C++</li><li>C# GC --&gt; c++ 为其提供支持 IL2CPP vm:支持 C# .NET 独有的特性，如反射，泛型，委托，lambda表达式等</li></ol><h3 id="il2cpp-做了什么有什么优势">IL2CPP 做了什么？有什么优势？</h3><ol type="1"><li>跨平台可以执行问题 --&gt; Unity --&gt;&gt; 移植 IL2CPP --&gt; .NET 版本问题</li><li>性能获得提升 --&gt; 基于 IL2CPP 发布(而不是 Mono)</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线性代数在游戏开发中的基础和简单应用</title>
      <link href="/posts/90745bbc/"/>
      <url>/posts/90745bbc/</url>
      
        <content type="html"><![CDATA[<h2 id="坐标系">坐标系</h2><ul><li>笛卡尔坐标系</li><li>圆柱坐标系 垂直“高度与” <span class="math inline">\(h\)</span> 、从垂直轴发出的辐射轴 <span class="math inline">\(r\)</span> 、偏航角(yaw) <span class="math inline">\(\theta\)</span></li><li>球坐标系 俯仰角(pitch) <span class="math inline">\(\phi\)</span> 、偏航角(yaw) <span class="math inline">\(\theta\)</span> 、半径长度 <span class="math inline">\(r\)</span> eg. 经纬线 <span id="more"></span> ### 笛卡尔坐标系的左手系和右手系</li></ul><p>手握拳，伸出大拇指，四指从 <span class="math inline">\(x\)</span> 轴指向 <span class="math inline">\(y\)</span> 轴，大拇指指向 <span class="math inline">\(z\)</span> 轴，这就是右手系。</p><p>反之为左手系。</p><h2 id="向量vector">向量(vector)</h2><p>在 n 维空间中包含 modulus (模)和 direction (方向)的量。</p><h3 id="模长">模长</h3><p>向量的模长是向量的长度，用 <span class="math inline">\(||\vec{v}||\)</span> 表示。</p><p>$ |||| =  $</p><h4 id="magic-number-卡马克快速平方根">magic number (卡马克快速平方根)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">Q_rsqrt</span><span class="params">( <span class="type">float</span> number )</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> i;</span><br><span class="line">  <span class="type">float</span> x2, y;</span><br><span class="line">  <span class="type">const</span> <span class="type">float</span> threehalfs = <span class="number">1.5F</span>;</span><br><span class="line"></span><br><span class="line">  x2 = number * <span class="number">0.5F</span>;</span><br><span class="line">  y = number;</span><br><span class="line">  i = * ( <span class="type">long</span> * ) &amp;y;                       <span class="comment">// evil floating point bit level hacking</span></span><br><span class="line">  i = <span class="number">0x5f3759df</span> - (i &gt;&gt; <span class="number">1</span>);                 <span class="comment">// what the fuck?</span></span><br><span class="line">  y = * ( <span class="type">float</span> * ) &amp;i;</span><br><span class="line">  y = y * (threehalfs - ( x2 * y * y ) );    <span class="comment">// 1st iteration</span></span><br><span class="line">  y = y * (threehalfs - ( x2 * y * y ) );    <span class="comment">// 2nd iteration, this can be removed</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.bilibili.com/video/BV18j411i7bp">科普视频</a></p><p><a href="http://www.beyond3d.com/content/articles/8/">真正的作者</a></p><h3 id="归一化和单位向量">归一化和单位向量</h3><h3 id="三角形法则加减法">三角形法则（加减法）</h3><h3 id="点积">点积</h3><ul><li>投影的计算</li><li>是否共线</li></ul><h3 id="叉积">叉积</h3><ul><li>右手法则的原理</li><li>点在三角形的内/外？</li></ul><h2 id="线性插值-lerp">线性插值 (Lerp)</h2><h2 id="矩阵">矩阵</h2><h3 id="用矩阵表示点和向量">用矩阵表示点和向量</h3><h3 id="单位矩阵">单位矩阵</h3><h3 id="矩阵乘法">矩阵乘法</h3><h3 id="矩阵的转置">矩阵的转置</h3><h3 id="逆矩阵于逆矩阵的求法">逆矩阵于逆矩阵的求法</h3><p><a href="https://blog.csdn.net/daduzimama/article/details/120509856">逆矩阵的求法</a></p><h3 id="伴随矩阵">伴随矩阵</h3><h3 id="正交矩阵">正交矩阵</h3><h3 id="齐次坐标-来不及就不讲"><em>齐次坐标</em> (来不及就不讲)</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>引擎开发实战学习笔记</title>
      <link href="/posts/b15b4e49/"/>
      <url>/posts/b15b4e49/</url>
      
        <content type="html"><![CDATA[<p>记录 <span id="more"></span></p><ol type="1"><li>EntryPoint</li><li>Logging</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Component-Based &amp; Component-Oriented Programming</title>
      <link href="/posts/c63a25c3/"/>
      <url>/posts/c63a25c3/</url>
      
        <content type="html"><![CDATA[<p>一点关于 Component 的思考</p><span id="more"></span><h2 id="前置知识">前置知识</h2><h3 id="面向对象编程-object-oriented-programming">面向对象编程 Object Oriented Programming</h3><h4 id="继承">继承</h4><h5 id="实现继承">实现继承</h5><p>让派生类可以使用基类的接口和实现，而不需要重新编写相同的代码。目的是代码的复用。 但是实现继承会导致派生类和基类之间的强耦合，当基类的实现发生变化时，派生类也需要跟着变化。</p><h5 id="接口继承">接口继承</h5><p>接口继承是指派生类只继承基类的接口，而不继承基类的实现。目的是让更高层的调用者不需要关注具体细节，可以一视同仁的去处理他见到的所以对象。我们也会把这种思想叫做“归一化”，典型的就是<code>toString()</code>方法。</p><p>反过来也一样，高层的调用者不需要对底层的实现指手画脚，最好连告知都不需要告知他们。我们把这种策略叫做“封装”</p><h4 id="缺点">缺点</h4><ul><li>代码复用性相对差</li><li>实际开发中，对象缺少明显的父子继承关系</li><li>实现继承的强耦合性</li></ul><p>游戏世界的对象是绝对复杂的，再父子继承的过程中，我们几乎没办法找到一个父类或者祖父类让所有子类都心甘情愿的继承他。</p><p>下面可以举一个小栗子</p><p>我们有一个 <code>水陆空三栖核能魔法混动运兵器</code>，那么这个类该继承自谁呢？</p><p>或许你能搞定他的父类，但是你能搞定他的祖父类吗？战车？船只？还是飞机？</p><p>或许你会觉得这个例子太过刁钻了，但事实上，哪怕是现实世界的对象，纯粹的 OO 也会心有余而力不足。比如，弓骑兵到底是骑兵的子类还是弓手的子类？还有那个经久不衰的笑话，连裤袜倒是改继承自裤子还是袜子？虽然最高法告诉我们连裤袜就是连裤袜，但是对于一种编程范式来说，模糊和冗余是致命的。</p><p>这就是这节课我为什么要和大家谈面向组件开发。</p><h2 id="什么是面向组件编程-component-oriented-programming">什么是面向组件编程 Component-Oriented Programming</h2><h3 id="什么是组件">什么是组件</h3><p>组件的本质，就是把一些经常使用的功能或者行为抽离出来，封装成一个个独立的模块，在要使用的时候想乐高积木或者 Switch 的游戏卡带一样，组装起来或者插进我们想要构建功能的对象中就可以了。这种性质，我们也称为 PnP，即 Plug and Play, 即插即用。大家以后要熟悉这个词，在很多领域都会大量出现。</p><h2 id="另一种解决方案面向数据编程-data-oriented-programming">另一种解决方案——面向数据编程 Data-Oriented Programming</h2><h2 id="没有银弹">没有银弹</h2><p>"A":"a" "B":"b" "Sprite":4</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101Notes</title>
      <link href="/posts/6206937d/"/>
      <url>/posts/6206937d/</url>
      
        <content type="html"><![CDATA[<p>GAMES101Notes</p><span id="more"></span><h2 id="leture-3-transform">Leture 3 Transform</h2><ul><li>Modeling -&gt;transformation, rotation, scaling eg. Camera &amp; IK</li><li>Viewing -&gt; (3D to 2D)projection</li></ul><h3 id="scale">Scale</h3><p><span class="math display">\[x&#39; = sx \\ y&#39; = sy\]</span></p><p><span class="math display">\[\begin{bmatrix}x&#39; \\y&#39; \\\end{bmatrix} =\begin{bmatrix}s &amp; 0 \\0 &amp; s \\\end{bmatrix}\begin{bmatrix}x \\y \\\end{bmatrix}\]</span></p><p><span class="math display">\[\begin{bmatrix}x&#39; \\y&#39; \\\end{bmatrix} =\begin{bmatrix}s_x &amp; 0 \\0 &amp; s_y \\\end{bmatrix}\begin{bmatrix}x \\y \\\end{bmatrix}\]</span></p><h3 id="reflection-matrix">Reflection Matrix</h3><p><span class="math display">\[x&#39; = -x \\y&#39; = -y\]</span></p><p><span class="math display">\[\begin{bmatrix}x&#39; \\y&#39; \\\end{bmatrix} =\begin{bmatrix}-1 &amp; 0 \\0 &amp; -1 \\\end{bmatrix}\begin{bmatrix}x \\y \\\end{bmatrix}\]</span></p><h3 id="shear-matrix">Shear Matrix</h3><p><span class="math display">\[x&#39; = x + ay \\y&#39; = y + bx\]</span></p><p><span class="math display">\[\begin{bmatrix}x&#39; \\y&#39; \\\end{bmatrix} =\begin{bmatrix}1 &amp; a \\b &amp; 1 \\\end{bmatrix}\begin{bmatrix}x \\y \\\end{bmatrix}\]</span></p><h3 id="rotateabount-origin00ccw-by-default绕原点逆时针">Rotate(abount origin<span class="math inline">\((0,0)\)</span>,CCW by default)『绕原点，逆时针』</h3><p><span class="math display">\[x&#39; = xcos\theta - ysin\theta \\y&#39; = xsin\theta + ycos\theta\]</span></p><p><span class="math display">\[\begin{bmatrix}x&#39; \\y&#39; \\\end{bmatrix} =\begin{bmatrix}cos\theta &amp; -sin\theta \\sin\theta &amp; cos\theta \\\end{bmatrix}\begin{bmatrix}x \\y \\\end{bmatrix}\]</span></p><p><span class="math display">\[R = \begin{bmatrix}cos\theta &amp; -sin\theta \\sin\theta &amp; cos\theta \\\end{bmatrix}\]</span></p><h3 id="linear-transform-matricesof-the-same-dimension相同">Linear Transform = Matrices(of the same dimension)『相同』</h3><p><span class="math display">\[x&#39; = ax + by \\y&#39; = cx + dy\]</span></p><p><span class="math display">\[\begin{bmatrix}x&#39; \\y&#39; \\\end{bmatrix} =\begin{bmatrix}a &amp; b \\c &amp; d \\\end{bmatrix}\begin{bmatrix}x \\y \\\end{bmatrix}\]</span></p><p><span class="math display">\[x&#39; = Mx\]</span></p><h3 id="translation">Translation</h3><p><span class="math display">\[x&#39; = x + t_x\\y&#39; = y + t_y\]</span></p><p><span class="math display">\[\begin{bmatrix}x&#39; \\y&#39; \\\end{bmatrix} =\begin{bmatrix}1 &amp; 0 \\0 &amp; 1 \\\end{bmatrix}\begin{bmatrix}x \\y \\\end{bmatrix} +\begin{bmatrix}t_x \\t_y \\\end{bmatrix}\]</span></p><p><span class="math display">\[\begin{bmatrix}x&#39; \\y&#39; \\\end{bmatrix} =\begin{bmatrix}a &amp; b \\c &amp; d \\\end{bmatrix}\begin{bmatrix}x \\y \\\end{bmatrix} +\begin{bmatrix}t_x \\t_y \\\end{bmatrix}\]</span></p><p>显然，平移不是线性变换</p><p>但是我们想要有一个大统一的概念可以描述这些变换</p><h3 id="homogeneous-coordinates齐次坐标">Homogeneous Coordinates『齐次坐标』</h3><p>Add a third coordinate <span class="math inline">\(w\)</span> to <span class="math inline">\((x,y)\)</span></p><ul><li>2D point: <span class="math inline">\(= (x,y,1)^T\)</span></li><li>2D vector: <span class="math inline">\(= (x,y,0)^T\)</span></li></ul><p>Maxtrix representation of translation</p><p><span class="math display">\[\begin{bmatrix}x&#39; \\y&#39; \\w&#39; \\\end{bmatrix} =\begin{bmatrix}1 &amp; 0 &amp; t_x \\0 &amp; 1 &amp; t_y \\0 &amp; 0 &amp; 1 \\\end{bmatrix} ·\begin{bmatrix}x \\y \\1 \\\end{bmatrix} =\begin{bmatrix}x + t_x \\y + t_y \\1 \\\end{bmatrix}\]</span></p><p><span class="math inline">\(w\)</span> 的意义是什么呢？</p><p>In homogeneous coordinates, <span class="math inline">\(\begin{bmatrix}x \\y \\w \\\end{bmatrix}\)</span> is the 2D point<span class="math inline">\(\begin{bmatrix}\frac{x}{w} \\\frac{y}{w} \\1\end{bmatrix}, w \neq 0\)</span></p><h3 id="d-transformations">2D transformations</h3><h4 id="scale-1">scale</h4><p><span class="math display">\[S(s_x,s_y) = \begin{bmatrix}s_x &amp; 0 &amp; 0 \\0 &amp; s_y &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span></p><p><span class="math display">\[S(s_x,s_y) = \begin{bmatrix}s_x &amp; 0 &amp; 0 \\0 &amp; s_y &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span></p><h4 id="rotate">rotate</h4><p><span class="math display">\[R(\theta) = \begin{bmatrix}cos\theta &amp; -sin\theta &amp; 0 \\sin\theta &amp; cos\theta &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span></p><h4 id="shear">shear</h4>$ H(a,b) =<span class="math display">\[\begin{bmatrix}1 &amp; a &amp; 0 \\b &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span><p>$</p><h4 id="translate">translate</h4>$ T(t_x,t_y) =<span class="math display">\[\begin{bmatrix}1 &amp; 0 &amp; t_x \\0 &amp; 1 &amp; t_y \\0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span><p>$</p><h3 id="inverse-transform">Inverse transform</h3><p>逆变换刚好对应逆矩阵</p><h2 id="lecture-4-transformation-cont">Lecture 4 Transformation Cont</h2><p><a href="https://blog.csdn.net/daduzimama/article/details/120509856">逆矩阵的求法</a></p><p>当一个矩阵的逆等同于他的伴随矩阵，那么这个矩阵是正交矩阵。</p><p>旋转矩阵是正交矩阵</p><h3 id="d-transformations-1">3D transformations</h3><ul><li>Scale $ S(s_x,s_y,s_z) =<span class="math display">\[\begin{bmatrix}s_x &amp; 0 &amp; 0 &amp; 0 \\0 &amp; s_y &amp; 0 &amp; 0 \\0 &amp; 0 &amp; s_z &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span>$</li><li>Translate $ T(t_x,t_y,t_z) =<span class="math display">\[\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; t_x \\0 &amp; 1 &amp; 0 &amp; t_y \\0 &amp; 0 &amp; 1 &amp; t_z \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span>$</li><li>Rotate(Around x-, y-, z-axis) $ R_x() =<span class="math display">\[\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; cos\theta &amp; -sin\theta &amp; 0 \\0 &amp; sin\theta &amp; cos\theta &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span>\ $ $ R_y() =<span class="math display">\[\begin{bmatrix}cos\theta &amp; 0 &amp; sin\theta &amp; 0 \\0 &amp; 1 &amp; 0 &amp; 0 \\-sin\theta &amp; 0 &amp; cos\theta &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span>\ $ $ R_z() =<span class="math display">\[\begin{bmatrix}cos\theta &amp; -sin\theta &amp; 0 &amp; 0 \\sin\theta &amp; cos\theta &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span>$</li></ul><h4 id="rodrigues-rotation-formula罗德里格斯旋转公式">Rodrigues' Rotation Formula『罗德里格斯旋转公式』</h4><p>Rotation by angle <span class="math inline">\(\alpha\)</span> around axis <span class="math inline">\(n\)</span></p>$ (,) = cos() + (1-cos())^T + sin()N\ N =<span class="math display">\[\begin{bmatrix}0 &amp; -n_z &amp; n_y \\n_z &amp; 0 &amp; -n_x \\-n_y &amp; n_x &amp; 0 \\\end{bmatrix}\]</span><p>$</p><h3 id="viewing-transformation观测变换">Viewing transformation『观测变换』</h3><h3 id="view-camera-transformation视图变换">View / Camera transformation『视图变换』</h3><h3 id="projection-transformation投影变换">Projection transformation『投影变换』</h3><h4 id="orthographic-projection正交投影">Orthographic projection『正交投影』</h4><ul><li>相机置于原点，面朝 -z 轴</li><li>丢掉 z 轴</li><li>Translate and scale to <span class="math inline">\([-1,1]^2\)</span></li></ul><h5 id="in-general">In general</h5><ul><li>We want to map a cuboid <span class="math inline">\([l,r] \times [b,t] \times [\boldsymbol f,\boldsymbol n]\)</span> to the "canonical" cube<span class="math inline">\([-1,1]^3\)</span></li></ul><h6 id="transformation-matrix">Transformation matrix</h6><p>Translate(center to origin) -&gt; Scale(length/width/height to 2)</p>$ M_{ortho} =<span class="math display">\[\begin{bmatrix}\frac{2}{r-l} &amp; 0 &amp; 0 &amp; 0 \\0 &amp; \frac{2}{t-b} &amp; 0 &amp; 0 \\0 &amp; 0 &amp; \frac{2}{\boldsymbol n-\boldsymbol f} &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span>·<span class="math display">\[\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; -\frac{r+l}{2} \\0 &amp; 1 &amp; 0 &amp; -\frac{t+b}{2} \\0 &amp; 0 &amp; 1 &amp; -\frac{\boldsymbol n+\boldsymbol f}{2} \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span>=<span class="math display">\[\begin{bmatrix}\frac{2}{r-l} &amp; 0 &amp; 0 &amp; -\frac{r+l}{r-l} \\0 &amp; \frac{2}{t-b} &amp; 0 &amp; -\frac{t+b}{t-b} \\0 &amp; 0 &amp; \frac{2}{\boldsymbol n-\boldsymbol f} &amp; -\frac{\boldsymbol n+\boldsymbol f}{\boldsymbol n-\boldsymbol f} \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span><p>$</p><h4 id="perspective-projection透视投影">Perspective projection『透视投影』</h4><ul><li>First "aquish" the frustum into a cuboid <span class="math inline">\((n \rightarrow n, f \rightarrow f)(M_{persp \rightarrow ortho})\)</span></li><li>Do orthographic projection</li></ul><ol type="1"><li><p>In order to find a transformation</p><ul><li>Find the relationship between transformed points <span class="math inline">\((x&#39;,y&#39;,z&#39;)\)</span> and original points <span class="math inline">\((x,y,z)\)</span></li><li><span class="math inline">\(y&#39; = \frac{n}{z}y\\ x&#39; = \frac{n}{z}x\)</span> --&gt; similar to <span class="math inline">\(y&#39;\)</span></li></ul></li><li><p>In homogeneous corrdinates</p></li></ol>$<span class="math display">\[\begin{bmatrix}x \\y \\z \\1 \\\end{bmatrix} \xrightarrow{M_{persp \rightarrow ortho}}\begin{bmatrix}\frac{n}{z}x \\\frac{n}{z}y \\unknown \\1 \\\end{bmatrix} \xlongequal{mult. by z}\begin{bmatrix}nx \\ny \\unknown \\z \\\end{bmatrix}\]</span><p>$</p><p>显然，我们可以逆推出 <span class="math inline">\(M_{persp \rightarrow ortho}\)</span> 长这样</p>$ M_{persp ortho} =<span class="math display">\[\begin{bmatrix} n &amp; 0 &amp; 0 &amp; 0 \\0 &amp; n &amp; 0 &amp; 0 \\? &amp; ? &amp; ? &amp; ? \\0 &amp; 0 &amp; 1 &amp; 0 \\\end{bmatrix}\]</span><p>$</p><p>近和远处的 <span class="math inline">\(z\)</span> 不会发生变化</p><p>把 z 代换成 n，n 是我们取得特殊定值</p>$<span class="math display">\[\begin{bmatrix}x \\y \\z \\1 \\\end{bmatrix}\]</span>=<span class="math display">\[\begin{bmatrix}nx \\ny \\unknown \\z \\\end{bmatrix} \xrightarrow{replace\space z\space with\space n}\begin{bmatrix}x \\y \\n \\1 \\\end{bmatrix} \rightarrow\begin{bmatrix}nx \\ny \\n^2 \\n \\\end{bmatrix}\]</span><p>$</p><p>我们现在要求解第三行，且我们知道 x 轴和 y 轴对 z 轴没有影响, 因为最终的结果中没有 x 和 y</p>$<span class="math display">\[\begin{bmatrix}0\space 0\space A\space B\end{bmatrix}\]</span>·<span class="math display">\[\begin{bmatrix}x \\y \\n \\1 \\\end{bmatrix}\]</span><p>= n^2 $</p><p>我们可以推出</p>$<span class="math display">\[\begin{bmatrix}0 &amp; 0 &amp; A &amp; B\end{bmatrix}\]</span>·<span class="math display">\[\begin{bmatrix}x \\y \\n \\1 \\\end{bmatrix}\]</span><p>= n^2  An + B = n^2 $</p><p>我们又知道任何点的 z 坐标在远平面上都不会变化，所以我们可以推出</p>$<span class="math display">\[\begin{bmatrix}0 \\0 \\f \\1 \\\end{bmatrix} \Rightarrow\begin{bmatrix}0 \\0 \\f \\1 \\\end{bmatrix}\]</span>==<span class="math display">\[\begin{bmatrix}0 \\0 \\f^2 \\f \\\end{bmatrix} \Rightarrow\]</span><p>Af + B = f^2 $</p><p>解得</p><p>$ A = n+f \ B = -nf $</p><p>所以</p>$ M_{persp ortho} =<span class="math display">\[\begin{bmatrix} n &amp; 0 &amp; 0 &amp; 0 \\0 &amp; n &amp; 0 &amp; 0 \\0 &amp; 0 &amp; n+f &amp; -nf \\0 &amp; 0 &amp; 1 &amp; 0 \\\end{bmatrix}\]</span><p>$</p>$ M_{persp} = M_{ortho} · M_{persp ortho} =<span class="math display">\[\begin{bmatrix}\frac{2}{r-l} &amp; 0 &amp; 0 &amp; -\frac{r+l}{r-l} \\0 &amp; \frac{2}{t-b} &amp; 0 &amp; -\frac{t+b}{t-b} \\0 &amp; 0 &amp; \frac{2}{\boldsymbol n-\boldsymbol f} &amp; -\frac{\boldsymbol n+\boldsymbol f}{\boldsymbol n-\boldsymbol f} \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{bmatrix}\]</span>·<span class="math display">\[\begin{bmatrix} n &amp; 0 &amp; 0 &amp; 0 \\0 &amp; n &amp; 0 &amp; 0 \\0 &amp; 0 &amp; n+f &amp; -nf \\0 &amp; 0 &amp; 1 &amp; 0 \\\end{bmatrix}\]</span>=<span class="math display">\[\begin{bmatrix}\frac{2n}{r-l} &amp; 0 &amp; \frac{r+l}{r-l} &amp; 0 \\0 &amp; \frac{2n}{t-b} &amp; \frac{t+b}{t-b} &amp; 0 \\0 &amp; 0 &amp; \frac{n+f}{n-f} &amp; \frac{2nf}{n-f} \\0 &amp; 0 &amp; 1 &amp; 0 \\\end{bmatrix}\]</span><p>$</p><h2 id="rasterizationtriangles光栅化">Rasterization(Triangles)光栅化</h2><p>定义 field of view(fovY)垂直的可视角度 和 aspect ratio(w/h)屏幕长宽比 <img src="垂直可视角度和屏幕长宽比.png" alt="垂直可视角度和屏幕长宽比" /> n:near, t:top, b:bottom, l:left, r:right</p><p>视口变换</p><p><span class="math display">\[\begin{bmatrix}x \\y \\z \\1 \\\end{bmatrix} =\begin{bmatrix}\frac{w}{2} &amp; 0 &amp; 0 &amp; \frac{w}{2} \\0 &amp; \frac{h}{2} &amp; 0 &amp; \frac{h}{2} \\0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{bmatrix}·\begin{bmatrix}x \\y \\z \\1 \\\end{bmatrix}\]</span></p><h3 id="sample-采样">Sample 『采样』</h3><ul><li>Sample if center of pixel is inside triangle</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">Inside</span>(<span class="params">tri,x,y</span>)</span> =&gt; Point(x,y) <span class="keyword">in</span> tri ? <span class="number">1</span> : <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> y = <span class="number">0</span>; y &lt; h; y++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> x = <span class="number">0</span>; x &lt; w; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        image[x][y] = Inside(tri,x + <span class="number">0.5f</span>,y + <span class="number">0.5f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">做叉积判断点 Q 是否在 tri 内</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">P0</span></span><br><span class="line"><span class="comment">|\</span></span><br><span class="line"><span class="comment">| \    *Q</span></span><br><span class="line"><span class="comment">|  \</span></span><br><span class="line"><span class="comment">|___\P2</span></span><br><span class="line"><span class="comment">P1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>采样率低 =&gt; 走样 =&gt; 锯齿...</p><h3 id="anti-aliasing反走样抗锯齿">Anti-aliasing『反走样/抗锯齿』</h3><p>采样之前做一个滤波(filtering)</p><ul><li>Frequency『频率』</li><li>Frequency domain『频域』</li></ul><h4 id="数字信号处理相关的前置知识">数字信号处理相关的前置知识</h4><p>傅里叶变换 =&gt; 把函数从时域转换到频域 <img src="时域到频域.png" alt="时域到频域" /></p><ul><li>Low-pass filter『低通滤波器』</li><li>High-pass filter『高通滤波器』</li><li>Band-pass filter『带通滤波器』</li><li>Band-stop filter『带阻滤波器』</li><li>Gaussian filter『高斯滤波器』</li><li>Box filter『盒子滤波器』 ...</li></ul><p>Filtering = Convolution『卷积』= Average『平均』= Blurring『模糊』</p><p>时域卷积 = 频域乘积</p><figure><img src="时域图到频谱图.png" alt="时域图到频谱图" /><figcaption aria-hidden="true">时域图到频谱图</figcaption></figure><p>采样是重复原始信号的频谱</p><ul><li>采样定理: 在进行模拟/数字信号的转换过程中，当采样频率fs.max大于信号中最高频率fmax的2倍时(fs.max&gt;2fmax)，采样之后的数字信号完整地保留了原始信号中的信息，一般实际应用中保证采样频率为信号最高频率的2.56～4倍；采样定理又称奈奎斯特定理。</li></ul><p><a href="https://zhuanlan.zhihu.com/p/74736706">采样定理，频谱混叠和傅里叶变换 深入理解</a></p><p>这篇文章很好地解释了为什么"对于一个连续的信号采样，采样后的频谱相当于将采样前的频谱进行延拓" <a href="https://www.projectrhea.org/rhea/index.php/2015_Fall_ECE_438_Boutin_A_visual_explanation_of_aliasing_and_repetition_with_the_DTFT_Erik_Swan">A visual explanation of aliasing and repetition with the DTFT</a></p><blockquote><p>时域采样得到的离散信号并不只代表这个时域信号，有无数多个频率不同的信号的采样结果是一样的，也就导致了频域上的周期延拓</p></blockquote><p>有无数个高频分量可以匹配相同的离散数据，因此离散信号的频域包含所有这些频率。 <img src="连续信号采样频谱拓展的解释.gif" alt="连续信号采样频谱拓展的解释" /></p><p>当延拓的图形重合的时候，我们就认定这时候发生了走样。</p><p>要反走样，最直接的办法就是增加采样率，在现实中的意义就是“换一个更好的分辨率更好的显示器”（让图形之间离得更远） 从算法/软件角度来说，我们也可以采用之前的在采样前添加滤波的方法。我们可以给图像添加一个低通滤波，把高频的信息去掉。（让图形更瘦）</p><h4 id="antialiasing-by-supersampling超采样msaa">Antialiasing By Supersampling『超采样』(MSAA)</h4><p>将一个像素近似认为更多的像素 =&gt; 给一个像素内部增加更多的采样点 =&gt; 工业界的做法</p><h4 id="fast-approximate-antialiasing快速近似反走样抗锯齿fxaa">Fast Approximate Antialiasing『快速近似反走样/抗锯齿』(FXAA)</h4><p>图像的后期处理 =&gt; 通过图像匹配的办法把存在锯齿的边界找到，并且更换成没有锯齿的边界 =&gt; 效率高</p><h4 id="temporal-antialiasing时域反走样抗锯齿taa">Temporal Antialiasing『时域反走样/抗锯齿』(TAA)</h4><p>静态场景中 =&gt; 复用上一帧感知的结果 =&gt; 相当于把 MSAA 对应的样本分布在了时间上，并且在当前帧没有引入任何额外操作</p><h3 id="z-buffering深度缓冲">Z-buffering『深度缓冲』</h3><h4 id="painters-algorithm画家算法">Painter's Algorithm『画家算法』</h4><h5 id="基本思想">基本思想</h5><p>先将画面中的物体按其距离观察点的远近进行排序，结果存放在一张线形表中。距观察点远者称其优先级高，放在表头,距观察点近者称其优先级低，放在表尾，这张表称为深度优先级表。</p><p>然后按照从表头到表尾的顺序逐个绘制物体。由于距观察者近的物体在表尾最后画出，它覆盖了远处的物体，最终在屏幕上产生了正确的遮挡关系。</p><h5 id="缺陷">缺陷</h5><figure><img src="画家算法的缺陷.png" alt="画家算法的缺陷" /><figcaption aria-hidden="true">画家算法的缺陷</figcaption></figure><h4 id="z-buffer">Z-Buffer</h4><ul><li>frame buffer 存贮当前看到的场景</li><li>depth buffer 存储每个像素所看到的几何物体最浅的深度的信息</li></ul><figure><img src="深度缓存.png" alt="深度缓存" /><figcaption aria-hidden="true">深度缓存</figcaption></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Initialize depth buffer to +∞</span><br><span class="line"></span><br><span class="line">During rasterization:</span><br><span class="line">  <span class="keyword">for</span>(each triangle T)</span><br><span class="line">    <span class="keyword">for</span>(each sample (x,y,z) in T)</span><br><span class="line">      <span class="keyword">if</span>(z &lt; zbuffer[x,y])<span class="comment">// 如果该像素的深度小于此坐标深度缓存记录的深度</span></span><br><span class="line">        zbuffer[x,y] = z;<span class="comment">//更新深度</span></span><br><span class="line">        framebuffer[x,y] = color;<span class="comment">//更新 rgb</span></span><br></pre></td></tr></table></figure><p>处理不了透明物体</p><h3 id="shading着色">Shading『着色』</h3><p>The process of applying a material to an object.</p><h4 id="blinnphong-reflection-model布林-冯反射模型">Blinn–Phong reflection model『布林-冯反射模型』</h4><p>经验模型</p><ul><li>Ambient『环境光』</li><li>Diffuse『漫反射』</li><li>Specular『镜面反射/高光』</li></ul><p>Compute light reflected toward camera at a specific <strong>shading point</strong> Inputs:</p><ul><li>Viewer direction，观察方向，使用v表示</li><li>Surface normal，法线方向，使用n表示</li><li>Light direction，光线方向，使用l(小写的L)表示</li></ul><figure><img src="shading_point.png" alt="shading_point" /><figcaption aria-hidden="true">shading_point</figcaption></figure><p>Shading is Local =&gt; 着色不考虑其他物体的影响，只考虑着色点自身，故而只有明暗，没有阴影</p><h5 id="diffuse-reflection">Diffuse Reflection</h5><p>从接收角度看： In general, light per unit area is proportional to the cosine of the angle between the light direction and the surface normal =&gt; <span class="math inline">\(\cos\theta=l\cdot n\)</span></p><p>从输出角度看 <img src="LightFalloff.png" alt="LightFalloff" /> 光的能量会在传播中被“稀释”，一个单位面积上接收到的光的能量和光线传播的距离的平方成反比 =&gt; <span class="math inline">\(I/r^2\)</span> =&gt; 球！</p><p>综合来看</p><p><span class="math display">\[L_d = k_d(I/r^2)max(0,\vec{n}\cdot\vec{l})\]</span></p><p><span class="math inline">\(L_d\)</span> is diffusely <span class="math inline">\(k_d\)</span> is diffuse coefficient(color) <span class="math inline">\(I/r^2\)</span> is energy arrived at the shading point <span class="math inline">\(max(0,\vec{n}\cdot\vec{l})\)</span> is energy recevied by the shading point</p><p>观察方向对漫反射像完全没有影响 =&gt; 因为反射是完全随机的，因此可以认为漫反射光在任何反射方向上的分布都是一样的</p><h5 id="specular-highlights">Specular highlights</h5><p><img src="Specular_Term0.png" alt="Specular_Term0" /> 观察方向接近反射方向的时候才能观察到高光像 <img src="Specular_Term.png" alt="Specular_Term" /></p><p>v close to mirror direction(观察方向接近反射方向) &lt;=&gt; half vector near normal(半程向量接近法线向量)</p><p><span class="math display">\[\vec{h} = bisector(\vec{v},\vec{l}) = \frac{\vec{l}+\vec{v}}{||\vec{l}+\vec{v}||}\]</span></p><p><span class="math display">\[\begin{alignat}{2}L_s = k_s(I/r^2)max(0, \cos\alpha)^p\\ = k_s(I/r^2)max(0,\vec{n}\cdot\vec{h})^p\end{alignat}\]</span></p><p><span class="math inline">\(\alpha\)</span> is the angle between <span class="math inline">\(\vec{h}\)</span> and <span class="math inline">\(\vec{n}\)</span> <span class="math inline">\(p\)</span> is the shininess coefficient =&gt; Increasing p narrows the reflection lobe 『增大 p 可以缩小反射波瓣』 =&gt; 取值范围(100,200)</p><h5 id="ambient-lighting">Ambient lighting</h5><p><span class="math display">\[L_a = k_a I_a\]</span></p><p>环境光可以被简单的视为一个常数，尤其是在 Blinn–Phong model 中，但实际上他比这复杂得多 <span class="math inline">\(L_a\)</span> is reflected ambient light <span class="math inline">\(k_a\)</span> is ambient coefficient</p><figure><img src="Ambient.png" alt="Ambient" /><figcaption aria-hidden="true">Ambient</figcaption></figure><h5 id="将所有的项都加起来">将所有的项都加起来</h5><p><span class="math display">\[\begin{alignat}{2}L &amp; = L_a + L_d + L_s \\&amp; = k_a I_a + k_d(I/r^2)max(0,\vec{n}\cdot\vec{l}) + k_s(I/r^2)max(0,\vec{n}\cdot\vec{h})^p\end{alignat}\]</span></p><p>参考： <a href="https://zhuanlan.zhihu.com/p/442023993">Blinn-Phong光照模型从定义到实现</a></p><h4 id="shading-frequency着色频率">Shading Frequency『着色频率』</h4><ul><li>每个平面做一次shading =&gt; Flat shading</li><li>每个顶点做一次shading =&gt; Gouraud shading</li><li>每个像素做一次shading =&gt; Phong shading</li></ul><h5 id="顶点法线">顶点法线</h5><p>下图展示了一个简单的求法 <img src="顶点法线.png" alt="顶点法线" /> 把目标顶点所关联的面的法线向量求和取平均，即可得到目标顶点的法线向量</p><p><span class="math display">\[N_v = \frac{\sum_{i=1}^n N_i}{||\sum_{i=1}^n N_i||}\]</span></p><p>如果对三角形面进行加权，可以得到更精确的计算结果</p><h5 id="像素法线">像素法线</h5><p>已经得知了顶点法线后，问题可以转化为如何得到三角形面内部的一个平滑过渡的法线(假设三角形面大于至少一个像素) =&gt; 重心坐标 + 归一化</p><h4 id="graphics-real-time-rendering-pipeline图形管线">Graphics (Real-time Rendering) Pipeline『图形管线』</h4><figure><img src="GraphicsPipeline.png" alt="GraphicsPipeline" /><figcaption aria-hidden="true">GraphicsPipeline</figcaption></figure><p><a href="/http://shadertoy.com/view/ld3Gz2">shader toy</a> GPU 高度并行化处理</p><h4 id="texture-mapping纹理映射">Texture Mapping『纹理映射』</h4><p>在纹理上定义一个坐标系(u,v)(就是我们常说的 UV)，然后把纹理坐标映射到纹理上 =&gt; u 和 v 的取值范围是[0,1]</p><p>纹理要设计好在上下左右重复的时候无缝衔接 =&gt; tiled =&gt; method eg. Wang tiling</p><h4 id="interpolation插值">Interpolation『插值』</h4><h5 id="barycentric-coordinates重心坐标">Barycentric Coordinates『重心坐标』</h5><figure><img src="image/GAMES101Notes/三角形里的重心坐标.png" title="三角形里的重心坐标" alt="三角形里的重心坐标" /><figcaption aria-hidden="true">三角形里的重心坐标</figcaption></figure><p>如果 <span class="math inline">\(\alpha,\beta,\gamma\)</span> 的和为1，那么点一定和三角形在同一平面，如果三者的值都大于0，那么点一定在三角形内。</p><p>原理的数学证明：</p><p>设笛卡尔坐标系下某一平面内三点<span class="math inline">\(A,B,C,P\)</span>.</p><p>向量<span class="math inline">\(\vec{OP}\)</span> 可以表示为 <span class="math inline">\(\vec{OC}+m\vec{CB}+n\vec{BA}=(1-m)\vec{OC}+(m-n)\vec{OB}+n\vec{OA}\)</span></p><p>故</p><p><span class="math inline">\(\alpha=n\\\beta=m-n\\\gamma=1-m\)</span></p><p>显然，<span class="math inline">\(\alpha+\beta+\gamma=1\)</span></p><p>在平面<span class="math inline">\(ABCP\)</span>内，向量<span class="math inline">\(\vec{OP}\)</span> 仍然可以表示为 <span class="math inline">\(\vec{OC}+m\vec{CB}+n\vec{BA}=(1-m)\vec{OC}+(m-n)\vec{OB}+n\vec{OA}\)</span></p><p>要让 P 在 ABC 内，显然要使 m 的取值范围取 (0,1)，n 的取值范围取 (0,m)</p><h2 id="参考资料">参考资料</h2><ol type="1"><li><a href="https://www.bilibili.com/video/BV1X7411F744">闫令祺-GAMES101</a></li><li><a href="https://zhuanlan.zhihu.com/p/74736706">采样定理，频谱混叠和傅里叶变换 深入理解</a></li><li><a href="https://www.projectrhea.org/rhea/index.php/2015_Fall_ECE_438_Boutin_A_visual_explanation_of_aliasing_and_repetition_with_the_DTFT_Erik_Swan">A visual explanation of aliasing and repetition with the DTFT</a></li><li><a href="https://zhuanlan.zhihu.com/p/442023993">Blinn-Phong光照模型从定义到实现</a></li><li><a href="/http://shadertoy.com/view/ld3Gz2">shader toy</a></li><li><a href="https://blog.csdn.net/qq_38065509/category_9873936.html">剑 来!'s 计算机图形学笔记</a></li><li><a href="https://zhuanlan.zhihu.com/p/144360079">计算机图形学补充1：重心坐标(barycentric coordinates)详解及其作用 - 知乎 (zhihu.com)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习向 </category>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAMES101Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES104Notes</title>
      <link href="/posts/32cb02ce/"/>
      <url>/posts/32cb02ce/</url>
      
        <content type="html"><![CDATA[<p>GAMES104Notes</p><span id="more"></span><figure><img src="GAMES104_Zoo%20of%20Game%20Engines-1.png" alt="AMES104_Zoo of Game Engines-1" /><figcaption aria-hidden="true">AMES104_Zoo of Game Engines-1</figcaption></figure><figure><img src="GAMES104_Middlewares.png" alt="GAMES104_Middlewares" /><figcaption aria-hidden="true">GAMES104_Middlewares</figcaption></figure><h2 id="引擎的基本架构">引擎的基本架构</h2><p>自顶向底的五层架构</p><ul><li>Tool Layer 工具链和编辑环境</li><li>Function Layer 游戏逻辑设计</li><li>Resource Layer 处理存储不同种类的文件资源</li><li>Core Layer 构建功能</li><li>Platform Layer 硬件的运行环境，输入设备的差别，软件的发布平台</li></ul><h3 id="resource-layer">resource layer</h3><p>importing: resource -&gt; asset</p><p>全局唯一编号: GUID</p><p>Runtime Asset Manager</p><p>Manager Asset Life Cycle</p><h3 id="function-layer">Function Layer</h3><p>tick &amp; frame</p><p>Multi-threading</p><h3 id="core-layer">Core Layer</h3><p>Math Library</p><p>Math Efficiency eg. Quick and dirty hacks</p><ul><li>Carmack's 1/sqrt(x)</li><li>Magic number</li></ul><p>eg. SIMD<img src="SIMD-1.png" alt="Alt text" /></p><p>Data Structure and Containers</p><p>Memory Management</p><p>Foundation of Game Engine</p><h3 id="platform-layer">Platform Layer</h3><p>Target on Different Platform</p><p>Graphics API eg. Render Hardware Interface(RHI)</p><p>Hardware Architecture</p><h3 id="tool-layer">Tool Layer</h3><p>Allow Anyone to Create Game</p><p>Digital Content Creation(DCC)</p><h2 id="如何构建游戏世界">如何构建游戏世界</h2><h3 id="game-objectgo">game object(GO)</h3><h4 id="property">property</h4><h4 id="behavior">behavior</h4><h4 id="oop-vs.-component">OOP vs. Component</h4><p>OOP 也符合直觉，但是在复杂的游戏世界中并没有非常清晰的父子继承关系。</p><p>现在更多地使用 Component 的方式，将游戏对象的行为分解为多个组件，每个组件只负责一种行为。</p><h4 id="component-based-tick">Component-based Tick</h4><p>和曾经分GO Tick不同，现在是分Component Tick。由于 pipeline 效率更高</p><h4 id="go-间通信">GO 间通信</h4><ul><li>Hard Code</li><li>Event</li><li>uid</li></ul><h4 id="scene-management">Scene Management</h4><ol type="1"><li><p>No division &amp; Drived by grid</p></li><li><p>Spatial Data Structures</p><ul><li>Quadtree</li><li>Octree</li><li>Binary Space Partitioning(BSP)</li><li>Bounding Volume Hierarchy(BVH)</li><li>Scene Graph</li></ul></li></ol><h2 id="rendering">Rendering</h2><h3 id="basics-of-game-rendering">Basics of Game Rendering</h3><h4 id="gpu">GPU</h4><h5 id="simdsingle-instruction-multiple-data单指令多数据">SIMD(Single Instruction Multiple Data/单指令多数据)</h5><p><code>SMID_ADD c, a, b</code></p><h5 id="simtsingle-instruction-multiple-thread单指令多线程">SIMT(Single Instruction Multiple Thread/单指令多线程)</h5><p><code>SIMT_ADD c, a, b</code></p><h5 id="gpu-architecture">GPU Architecture</h5><ul><li>GPC(Graphics Processing Cluster)</li><li>SM(Streaming Multiprocessor)</li><li>Texture Units</li><li>CUDA Core</li><li>Warp</li></ul><figure><img src="GAMES101_GPU_Architecture.png" alt="GPU Architecture" /><figcaption aria-hidden="true">GPU Architecture</figcaption></figure><h5 id="data-flow-from-cpu-to-gpu">Data Flow From CPU to GPU</h5><ul><li>CPU and Main Memory</li><li>CPU to GPU</li><li>GPU and Video Memory</li></ul><p>尽可能让数据单向传输，从 CPU 到 GPU 尽可能不要从 GPU 里读数据</p><h5 id="be-aware-of-cache-efficiency">Be Aware of Cache Efficiency</h5><p>数据一定要放在一起为 Cache(缓存) 做准备</p><h5 id="gpu-bounds-and-performance">GPU Bounds and Performance</h5><h4 id="renderable">Renderable</h4><h5 id="mesh">Mesh</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span></span><br><span class="line">&#123;</span><br><span class="line">  Vector3 m_position;</span><br><span class="line">  <span class="comment">// other attributes</span></span><br><span class="line">  UByte4 m_color;</span><br><span class="line">  Vector3 m_normal;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mesh</span></span><br><span class="line">&#123;</span><br><span class="line">  Vertex m_vertex[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>Vertex Data<ul><li>Vertex declaration</li><li>Vertex buffer</li></ul></li><li>Index Data<ul><li>Index declaration</li><li>Index buffer</li></ul></li></ul><p>Triangle Strip 利好 Cache</p><h3 id="material-shader-and-lighting">Material, Shader, and Lighting</h3><h3 id="special-rendering">Special Rendering</h3><h3 id="pipeline">Pipeline</h3>]]></content>
      
      
      <categories>
          
          <category> 学习向 </category>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
            <tag> 游戏引擎 </tag>
            
            <tag> GAMES104 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2D图形——渲染、精灵和简单应用</title>
      <link href="/posts/220dd5af/"/>
      <url>/posts/220dd5af/</url>
      
        <content type="html"><![CDATA[<p>2D 渲染基础</p><span id="more"></span><h2 id="像素缓冲区和垂直同步">像素缓冲区和垂直同步</h2><h3 id="crt-显示器基础">CRT 显示器基础</h3><p>现在大家用的比较多的是液晶显示器(LCD), 在早先年，大家用的 CRT 显示器比较多，也就是阴极管射线显示器。LCD 通过控制是否透光来控制亮和暗，当色彩不变时，液晶也保持不变，这样就无须考虑刷新率的问题。对于画面稳定、无闪烁感的液晶显示器，刷新率不高但图像也很稳定。不过对于我们今天要谈的游戏来说，缺点就很明显了，其相应速度不够，画面有时候会有重影。</p><p>当然，我们这节课的主题是 2D 游戏渲染基础，和大家聊显示器主要也是让大家更好的了解我们渲染操作生成后呈现的载体。</p><p>其实 LCD 和 CRT 显示器在刷新上的原理是差不多的，当然我们前面也说了，在早点年，CRT 显示器是当时的主流，综合考虑，也是为了让大家了解 2D 渲染这项技术在诞生之初的显示设备的环境，我打算从 CRT 显示器的角度带大家聊聊显示器的工作原理。</p><p>大家高中信息课应该教过，在 CRT 显示器内部，绘制图形是通过电子枪发射电子流完成的。这样讲可能比较抽象。其实，在显示器内部有一层荧光板，荧光板上面有一些荧光粉末，红绿蓝三种颜色的荧光粉末，单色的荧光粉末会聚集起来形成一个小小的荧光单元。红绿蓝三种单元各出一个聚集在一起就是一个像素点，密密麻麻的像素点就充斥在荧光板上了。 电子枪则会一口气发射三注电子流，很好理解，这些电子流依次打在了 RGB 三色上，由于电子流的强度不一样，每个像素点的红绿蓝三色的光也不一样，通过空间混色法，每个像素点就会呈现出不同的颜色。</p><p>当然，电子流的能量是有限的，这些荧光粉很快就会熄灭，所以电子枪需要不断的发射电子流，这样才能保证荧光粉不断的发光，显示器才能一直显示图像。这就是刷新了。</p><p>不过要想让画面动起来，而不是显示器上某个像素点一直再发不同的光，然而其他地方却一片黑，我们的电子流就要去射击不同的像素点，让整个显示器都呈现出画面。我们管这叫扫描。当然这里也运用到了人眼的视觉残留效应，想必大家很清楚。</p><p>当然扫描也不是乱扫的，是有章法有规则的，请看下图。</p><figure><img src="CRT显示器扫描.png" alt="CRT显示器扫描" /><figcaption aria-hidden="true">CRT显示器扫描</figcaption></figure><p>这张图大家肯定超级熟悉吧。电子枪从左上角向右扫，然后再从右向左扫，直到扫完整个屏幕。欸，我估计聪明的小伙伴已经发现了，这个扫描线不是绝对水平的，而是略微带一点倾斜。这也是为了让扫描线能扫过整个屏幕而不是只在一条横线上来回扫。从左向右扫的每条扫描线都略微下坡，其实这个下坡的度数是可以算出来的，其斜率大约为 -1/水平分辨率, 非常好算，我就不带大家算一遍了。</p><h4 id="消隐期-blank">消隐期 BLANK</h4><p>其实，在 CRT 显示器中，从右向左的这一条扫描线往往不会真实的扫描，而是消隐，大家可以理解为电子枪在这段时间不喷了，画面上一片漆黑。这个时间段我们称为<strong>行消隐期(HBLANK)</strong>，也可以叫做水平回扫。</p><p>啥是行？电子束既要作水平方向的运动，又要作垂直方向的运动。前者形成一行的扫描，称为行扫描，后者形成一幅画面的扫描，称为场扫描。</p><p>当电子流从左上角扫到右下角后，屏幕就完成了一帧的渲染，不过这时候电子枪指着右下角啊，难道说下一帧是从右下角原路返回右上角吗？听起来好像效率挺高的，不过我们实际上不会这么干。而是让电子枪直接从右下角跳到右上角，然后再从右上角开始扫描。电子枪从右下角移动到左上角的的过程，我们称作<strong>场消隐期(VBLANK)</strong>，也可以叫做垂直回扫。同样的，这段时间内，画面上也是一片漆黑的。</p><h4 id="垂直同步">垂直同步</h4><p>前面我们已经谈过了画面撕裂的原理，是渲染帧数超过刷新率，在显示器才显示到一半时就粗暴的给他塞了新的画面进去。 那后来人是怎么解决这个问题的呢？很简单，就是在显示器刷新的时候，我们不提交渲染，直到等显示器刷新完了。这样就不会出现画面撕裂的问题了。这个技术就是<strong>垂直同步(VSYNC)</strong>。</p><p>简单来说就是渲染循环受到真实刷新率的支配嘛。让游戏渲染的输出频率对标设备的刷新率，游戏的主循环又会和渲染循环相互制约，游戏的帧率也就被限制在了设备的刷新率上。当然这也会造成输入延迟，这一点不理解的同学可以去听我上一节的课，讲的很清楚。</p><p>下面来点<strong>套话</strong><br />为了同步显示屏的显示过程和控制器，控制器会产生一系列的定时信号。当电子枪换行进行扫描时，控制器会发出一个<strong>水平同步信号 HSync</strong>；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，控制器会发出一个<strong>垂直同步信号 VSync</strong>。</p><p>VSYNC信号有效时，表示一帧数据的开始。</p><h3 id="像素缓冲区">像素缓冲区</h3><p>缓冲区是一个很好理解的概念，图像从我们的 GPU 到屏幕上并不是实时的一步到位的。在 GPU 内存上有一系列的缓冲区用来暂存渲染数据。</p><p>我们在屏幕上展示出来的图像实际上是存储来 GPU 内存里面的。现代的硬件也足够支撑高分辨率的图像存在内存中，然而，这并不意味着我们就可以高枕无忧了。游戏循环仍然要像我们之前反复强调的那样考虑到 CRT(或者其他什么) 的电子枪。请试想，当 CRT 喷枪才在屏幕中喷到一半的时候，缓冲区就写入了新的数据，等这帧渲染完成后，显示器就会显示出一半新的画面，一半旧的画面，这就是我们前面说的画面撕裂。更糟糕的是，新数据提交的时候，上一帧还没开始绘制，那么就不是说屏幕中同时存在新的和旧的画面了，而是直接丢失了上一帧的画面。</p><p>为了解决这个问题，早期的开发者想出了一种现在我们已经很难接受的办法，那就是等到场消隐期再开始渲染，但这样的做法带来的弊端也很明显，游戏循环被完全锁死在了显示器的刷新率上了。</p><p>当然，还有另一种解决方案-多缓冲技术。我们可以在 GPU 内存中准备多个缓冲区，游戏循环可以将图像写入缓冲区A，这时屏幕正在绘制缓冲区B，等到下一帧，屏幕显示缓冲区A，游戏循环则将图像写入缓冲区B，由于屏幕和游戏循环的工作是交替进行的，所以我们可以保证屏幕显示的是完整的一帧画面。</p><p>为了完全消灭画面撕裂，缓冲区的交换必须在场消隐期进行，这就是我们之前一直说的<strong>垂直同步</strong>。</p><p>当然，这种技术的前提有两个，一个是交换缓冲区的速度足够快，在绝大多数场景下，这一点是不会变的，然而第二点则是等待 VBLANK。首先你得把游戏里面垂直同步的开关打开，缓冲区的交换才会等待垂直同步。有一些玩家为了追求极致的帧率和更低的输入延迟会关闭垂直同步，然而他们的屏幕刷新率又远低于游戏帧率，那么画面撕裂仍然会存在，缓冲区的存在只是一定程度的减缓了这种现象。</p><p>当然，有双缓冲区也有三缓冲区，甚至更多，为了画面的稳定和帧率的平滑，他们放弃了较短的输入延迟。</p><h2 id="精灵-sprite">精灵 Sprite</h2><h3 id="为什么是精灵-sprite">为什么是『精灵 · Sprite』？</h3><p>Sprite 是 德州仪器(TI)的工程师 Daniel Hillis 在 1970 年代后期创造的一个术语，也有一种说法，该词汇来自于 TI 的经理 David Ackley。</p><p>在计算机图形学和游戏开发领域，Sprite 指的是集成到更大场景中的独立悬浮于帧缓冲之上的的二维位图(Textrue2D)，其更多的用来表示游戏角色或者其他动态对象。</p><p>想象一下，你有一张图片作为游戏的背景——还有另外一张图片漂浮在这个作为背景的图片上，在游戏更新的过程中，后者会移动，旋转，缩放，甚至是可交互的，就像神话中的『幽灵』或者说『精灵』。</p><h3 id="画家算法">画家算法</h3><h4 id="基本思想">基本思想</h4><p>先将画面中的物体按其距离观察点的远近进行排序，结果存放在一张线形表中。距观察点远者称其优先级高，放在表头,距观察点近者称其优先级低，放在表尾，这张表称为深度优先级表。</p><p>然后按照从表头到表尾的顺序逐个绘制物体。由于距观察者近的物体在表尾最后画出，它覆盖了远处的物体，最终在屏幕上产生了正确的遮挡关系。</p><h3 id="精灵动画">精灵动画</h3><p>就像所有动画一样，精灵动画也是运用的人眼的视觉残留效应，那么当然，一组精灵动画就需要一组精灵图片，为了让你的游戏人物的行动看起来足够流畅，一秒完成的动作至少也需要24张图片，一个简单攻击动作的精灵图量往往在8张以上。</p><h3 id="精灵表单">精灵表单</h3><p>为了保证精灵完全对其，我们通常要求美术绘制的角色起码得是同一个尺寸，在过去，这个尺寸往往是 <span class="math inline">\(2^n\)</span> 次方，这也是许多库内部规定好的。当然，我们现在已经不追 <span class="math inline">\(2^n\)</span> 次方了，但是仍然需要一个角色一系列的动画帧保持相同的大小，并且，别的角色也最好按照设定保持类似的比例。</p><p>许多美术给图喜欢一张一张的给，那么这其实是让每张图片都成为以一个单独的纹理，并且图片中也会存在大量的留白，虽然现代引擎对这一类资源做过优化，但是不管是对内存，还是对程序员（有些美术给图之后往往就甩手不管图片的裁剪了）的头发来说，这都是一件很痛苦的事情。</p><p>一个更好的做法是将所有的动画帧放在一张图片上，这张图片，我们叫做精灵表单，这张表单上的图片，我们希望间距足够小，并且成行成列的对齐，这样不仅能节省不少内存空间，还可以让处理素材更加快捷。 <img src="AttackCombo.png" alt="AttackCombo" /> 下面我提供一个打包的小工具，大家可以试试。 <a href="https://www.codeandweb.com/texturepacker">TexturePacker</a></p><p>当然，游戏引擎对图片的大小，长和宽都是有限制的。最好不要把所有图片都塞进一张精灵表里。</p><h2 id="滚屏">滚屏</h2><p>在以前简单的 2D 游戏中，比如俄罗斯方块一类，游戏中所有元素都可以在一张固定大小的小小屏幕中展现出来，但随着玩法的更新迭代，游戏的世界也越来越大，再也不是一张固定大小的图片能承载的下的了。屏幕的大小没有办法改变，但实际上可显示的图片是可与改变的，想象一下，你面前有一张巨大的画布，你用一个木框去框住一小部分，这时候你再扯动，这时候这张远超木框大小的画布的全部内容就都可以再一个小小的屏幕中全部展现出来。</p><h3 id="单轴滚屏">单轴滚屏</h3><p>单轴滚动顾名思义，就是屏幕在单个轴上滚动，其实现原理也特别简单。你可以按照屏幕大小绘制出一连串的图片，在游戏进行时只需要同时绘制出两张图片就可以。图片绘制的时机你可以采用时间计算，也可以采用Trigger或者射线检测，当你给你的每张图片都加上ID，你就可以非常自由的控制下一张改出现那一张图片了。又或者你的玩家吃到什么道具，同样可以很方便的影响到下一张图片的绘制。</p><h3 id="无限滚屏">无限滚屏</h3><p>无限滚屏的原理其实和上面的单轴没有任何区别，只是说上面的图片出现顺序可能是写在策划表里的，而无限滚动是做一个循环或者随机打散组成序列。</p><h3 id="平行滚屏">平行滚屏</h3><p>当然，制作过 2D 横版卷轴游戏的同学可能会知道，我们的背景实质上是分层的，远景，中景，近景，他们的移动都是有不同的速率的。</p><p>这会让你的游戏看起来更加真实，美术绝赞。</p><h3 id="四向滚屏">四向滚屏</h3><p>四向滚屏的数学运算确实比单轴滚屏难了一个维度，但其实解决方案也是很多的。你可以选定一个坐标原点，以你的图片的长宽为x,y轴的单位长度构建一个坐标系，后面就是简单的数学问题了。一个很简单的很符合直觉的解决方案是，渲染你的角色所在的矩阵四角的图片。实际上就是你的角色所在的矩阵的四个点为中心渲染出图片。 很简单的算法吧，一句话就可以描述。</p><h2 id="瓦片地图">瓦片地图</h2><p>素材复用在现代游戏中是很重要的一环，相信大家都没法接受每一关都需要重新绘制一遍，尤其是对于游戏地图来说，很多花草竹石在每个场景中也都大同小异。</p><p>瓦片地图把游戏世界划分成等分的网格（可以是等六边形也可以是平行四边形或者其他什么形状），每个方块都有其对应的精灵。一般来说游戏引擎都会提供一个瓦片地图的编辑器，一张画布，上面来绘制你的地图，一个调色板，上面是你将采用的精灵。</p><h2 id="参考资料">参考资料</h2><ol type="1"><li><p><a href="https://vibaike.com/130533/">光栅扫描</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/412713532">液晶屏刷新原理和时序</a></p></li><li><p><a href="https://chillstepp.github.io/2020/07/17/AHU%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/">AHU计算机图形学</a></p></li><li><p><a href="https://handwiki.org/wiki/Sprite_(computer_graphics)">Sprite (computer graphics)</a></p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity rectTransform 解析</title>
      <link href="/posts/462539dc/"/>
      <url>/posts/462539dc/</url>
      
        <content type="html"><![CDATA[<p><a href="https://docs.unity3d.com/ScriptReference/RectTransform.html">官方文档地址</a> <span id="more"></span> - anchoredPosition 锚点位置 不要使用 position 也不要使用 <strong>localPosition</strong>. 数据类型是 Vector2 The position of the pivot of this RectTransform relative to the anchor reference point. 相对于锚点参照点的轴枢位置</p><ul><li><p>pivot 锚点 数据类型是 Vector2 The normalized position in this RectTransform that it rotates around. 在此 RectTransform 中环绕的归一化位置。 (0,0) 为左下角，(1,1) 为右上角.</p></li><li><p>sizeDelta 大小 数据类型是 Vector2 The size of this RectTransform relative to the distances between the anchors. 相对于锚点之间的距离，此 RectTransform 的大小。 If the anchors are together, sizeDelta is the same as size. If the anchors are in each of the four corners of the parent, the sizeDelta is how much bigger or smaller the rectangle is compared to its parent. 如果锚点在一起，则 sizeDelta 与 size 相同。如果锚点分别位于父对象的四个角上，那么 sizeDelta 就是矩形相对于父对象的大小。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>南京邮电大学校大学生科学技术协会软件研发部游戏组授课计划</title>
      <link href="/posts/e5afc9d6/"/>
      <url>/posts/e5afc9d6/</url>
      
        <content type="html"><![CDATA[<h2 id="gameplay-programming-exprience">GamePlay Programming Exprience</h2><span id="more"></span><h3 id="导论">0.导论</h3><h3 id="游戏循环时间和计算">1.游戏循环,时间和计算</h3><h3 id="d图形渲染精灵和简单应用">2.2D图形——渲染、精灵和简单应用</h3><h3 id="游戏中的线性代数">3.游戏中的线性代数</h3><h3 id="d图形初探坐标与世界变换">4.3D图形初探——坐标与世界变换</h3><h3 id="d图形再探光照与着色">5.3D图形再探——光照与着色</h3><h3 id="游戏输入输入设备和输入系统">6.游戏输入——输入设备和输入系统</h3><h3 id="声音和数字信号处理">7.声音和数字信号处理</h3><h3 id="碰撞检测算法和数值积分法求解物理运动">8.碰撞检测算法和数值积分法求解物理运动</h3><h3 id="有趣摄像机的实现与算法">9.有趣摄像机的实现与算法</h3><h3 id="浅谈游戏ai-不止a-fsm和状态树">10.浅谈游戏AI, 不止A*, FSM和状态树</h3><h3 id="ui设计中间件和本地化">11.UI设计，中间件和本地化</h3><h3 id="脚本语言和数据格式">12.脚本语言和数据格式</h3><h3 id="网络游戏概述">13.网络游戏概述</h3><h2 id="unity-进阶">Unity 进阶</h2><h2 id="ue5-3d-arpg">UE5 3D ARPG</h2><h3 id="ue5界面介绍与基础建模">1.UE5界面介绍与基础建模</h3><h3 id="熟悉蓝图脚本与enhancedinputsystem">2.熟悉蓝图脚本与EnhancedInputSystem</h3><h3 id="u踏上ue的gameplay架构">3.U++?踏上UE的GamePlay架构</h3><h3 id="骨骼绑定射线追踪教你使用aactor">4.骨骼绑定？射线追踪？教你使用AActor</h3><h3 id="背包血条快来探索ue的前端uwdiget">5.背包、血条——快来探索UE的前端UWdiget</h3><h3 id="狠狠存进来ue数据表">6.狠狠存进来——UE数据表</h3><h3 id="既然把player讲的差不多了那就开始我们的ai-controller与行为树吧">6.既然把Player讲的差不多了——那就开始我们的AI Controller与行为树吧！</h3><h3 id="特效环节niagara系统">7.特效环节——Niagara系统</h3><h3 id="终于结束了gameplay那......开始我们的gas与game-feature战斗吧">8.终于结束了GamePlay，那......开始我们的GAS与Game Feature战斗吧</h3>]]></content>
      
      
      <categories>
          
          <category> SAST </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GamePlay Programming Exprience, Unity, UE5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GamePlayProgrammingExprience_系列课_第一讲_游戏循环，时间和对象</title>
      <link href="/posts/6d5dfc5f/"/>
      <url>/posts/6d5dfc5f/</url>
      
        <content type="html"><![CDATA[<h2 id="课前的话">课前的话</h2><span id="more"></span><p>今天我们要开的这节课，我把它取名叫做 GamePlay Programming Exprience. 今天是第一节. 这是校科协游戏组的大课, 在这套课上, 我不打算专注讲 Unity, UE 或者 CoCos 等游戏引擎的使用, 也不打算精细的教学 C# 或者 C++ 的具体语法, 为什么呢? 原因就在上一句, 游戏引擎太多, 我们授课没有办法面面俱到, 程序语言已经有各个组负责了, 他们会对语法进行详细的教学. 在这套课上, 我想和大家成系统的聊聊游戏编程的算法和游戏设计的心得, 正如其名, 这套课是为了 GamePlay 程序员准备的, 我们不会花很大篇幅描述物理模拟, 图形渲染, 而是作为将他作为 GamePlay 程序员(或许还有技术策划,真是新颖的方向)的入门基础课, 游戏运行的基本逻辑, 良好的输入交互, 游戏功能的实现算法(AI...A*啦,FSM啦,感知,群居..),游戏数学, 2D和3D渲染基础, 物理模拟计算, 摄像机控制, UI设计, 脚本语言(Lua, javaScript...),最后还会聊点网络编程.</p><p>看起来饼画得很大,乐, 看起来有点多, 我们计划讲两个学期,这是作为游戏组的大课, 我们在课上会尽量使用 Lua 风格的伪代码, 或许还会夹杂了C# 和 Java, 当然考虑到学校课程的设计, 同时也会给出一份 C/C++ 的代码以供参考. 本课程如果遇到示例, 将会使用 Unity 游戏引擎展示,若有不便之处,还请见谅.</p><p>在每节课结束之后,我们会布置一些小题目作为课后的作业,当然这是选做的.届时我会在QQ群里面发布作业,大家感兴趣去做一下就好. 在布置一周后我会在B站上公布解析视频.</p><p>如果大家对 Unity 和 C# 特别感兴趣, 或者觉得我大课上讲的太简单,可以来找我听小课,小课基本上会提前一天在群里通知时间和地点,大家可以关注华夜工作室和校科协游戏组群. 我还有一个小课授课前瞻群,群里会投票决定下节小课讲什么, 程序设计能力很强的同学可以向我提交作品入群.</p><p>当然,大课和小课都会把录播放出来,所以上面的要求也都不是强制的.</p><p>好,我们开始今天的课程吧</p><h2 id="游戏循环-loop">游戏循环 loop</h2><p>游戏循环是游戏的核心控制流程，它是游戏的主线程，它负责游戏的运行，它是游戏的心脏。</p><p>在这个循环里，程序不断地去处理玩家的输入，更新游戏世界，然后生成输出（生成到屏幕上的我们会叫作渲染，游戏手柄等的震动也算是生成输出）。</p><p>这是非常经典而传统的游戏循环，你可以在任何游戏中见到他。想想看你再玩马里奥的时候，当你当你按下方向键，马里奥就会向你想要的方向移动，当你踩到龟壳上面的时候，龟壳会飞出去，或许你的手柄也会震动一下。</p><p>每次迭代游戏循环称为一帧，大部分游戏的帧率在 30-60 帧之间，也就是说，游戏循环每秒会执行 30-60 次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while game is running:</span><br><span class="line">    process inputs</span><br><span class="line">    update game world</span><br><span class="line">    generate outputs</span><br><span class="line">loop</span><br></pre></td></tr></table></figure><p>当然，循环的每一步都没有他们本身看上去的那么简单，每一步都有许多细节不容忽视。</p><h3 id="process-inputs">process inputs</h3><p>就像 process inputs，他意味着在循环的开始，你需要检查各种各样的设备的输入，键鼠，手柄，麦克风甚至还有触摸屏，陀螺仪，摄像机，GPS。有些是由你游戏中某些功能或者特色决定的，而另一些则来自玩家方便或者高品质游玩的需求。</p><p>他们的输入的类型也是多样的。如果你接触过 Unity 的 InputSystem, 那么或许你会更好的理解这一点。我们键盘的WASD，又或者手柄的遥感，他们都是Vector2的输入，而键盘，手柄，鼠标乃至触摸屏的点击，都是 Trigger 或者 Boolean 类型的， 这取决与他们是 Down, Up, Click 又或者是长按，双击。再打个比方，陀螺仪的输入可能是 Vector3的。输入系统的设备和输入的类型都是纷繁多样的，任何外部的输入都要在这一阶段被转换成计算机可以理解的数据结构。</p><h3 id="update-game-world">update game world</h3><p>结束玩家的输入后，就来到或许是大家最关心的一部分了，更新游戏世界。是的，谁不想通过代码构筑一个属于自己的美妙世界呢，或许每个程序员写下第一行 Hello World 的时候，都会自豪于即将成为一个小小代码世界的上帝。然而，一个游戏世界的构筑显然不会像 Hello World 那么简单， 他需要构筑世界的<code>实例</code>和<code>法则</code>，这听来有点像炼金术师又或者魔法师，当然，也许游戏程序员在某种程度上就是在没有魔力的世界里施法的人。好了让我们回到构筑世界的具体方法上来，我们通常把构筑世界的实例称为<code>Game Object</code>, 他们是构成游戏世界的最基本的物质元素和法则的载体。这个我们后半节课会详细讲解。而<code>法则</code>也不难理解，那是世界运转的基本原理，或许他的本质是计算，而在宏观上的体现可以是物理模拟，游戏玩法，甚至是游戏的时间与空间。想象一下吧，在一款玩家可以肆意控制重力的世界，那里的法则就是<code>重力会不定期改变</code>，又或者是<code>雨世界</code>中精彩的生态系统，<code>Minecraft</code>里的方块世界和史蒂夫能锤爆钻石的手，游戏的<code>法则</code>是塑造你的游戏世界的基准线，而你将用代码去实现他。</p><p>上面讲了很多，但是简单概括一下就是一句</p><blockquote><p>更新所有已激活且需要更新的对象</p></blockquote><p>其中，<code>更新</code>就是<code>法则</code>, <code>对象</code>就是<code>实例</code></p><h3 id="generate-outputs">generate outputs</h3><p>在很多情境中，生成输出是最耗费计算量的一步。想想看最常见的输出是什么？... 2D和3D的渲染，最简单的3D渲染在计算三角形顶点和颜色的时候计算量都是一个天文数字。（这里讲的比较模糊，这节课有空就细讲，没空就下一节课讲）。当然，输出也不知图形渲染，音视频，手柄的力回馈，甚至是网络数据的发送，都是输出的一部分。</p><p>讲了这么多，或许我可以给出一个小游戏（Flappy Bird）的例子，让大家更好的理解游戏循环。请看伪代码</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> Bird is alive:</span><br><span class="line">    // process inputs</span><br><span class="line">    InputDeviceData j = grap raw data from <span class="built_in">input</span> device</span><br><span class="line"></span><br><span class="line">    // update game world</span><br><span class="line">    update bird.position based on j</span><br><span class="line">    <span class="built_in">foreach</span> pipe <span class="keyword">in</span> pipes</span><br><span class="line">        <span class="keyword">if</span> pipe is out of screen</span><br><span class="line">            move pipe to the right out of screen</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> bird collides with pipe</span><br><span class="line">                kill bird</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                update pipe.position</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    loop</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // generate outputs</span><br><span class="line">    draw graphics</span><br><span class="line">    play aduio</span><br><span class="line">loop</span><br></pre></td></tr></table></figure><h3 id="多线程下的游戏循环">多线程下的游戏循环</h3><p>不同于早期游戏开发紧巴巴的硬件条件，2005年左右，多核处理器(CPU)开始普及，多线程编程也开始流行起来。在多线程的环境下，游戏循环的结构会有所不同，我们会把游戏循环分为两个线程，一个是游戏逻辑线程，另一个是渲染线程。游戏逻辑线程负责处理玩家的输入，更新游戏世界，而渲染线程则负责把游戏世界渲染到屏幕上。这样做的好处是，游戏逻辑线程和渲染线程可以并行执行，这样就可以充分利用多核处理器的优势，提高游戏的性能。</p><p>请你设想，在早期的单核处理器上，程序需要先花费 20ms 在逻辑运算上用来更新游戏世界，而后还需要花费 30ms 在渲染上，这样一来，游戏的帧率就只有 20FPS了。20帧的游戏，相信对于绝大多数玩家来说都是不可接受的，所以当年的游戏程序员绞劲脑汁开发出了大量极为优秀的优化算法————这点我们暂且不展开说，来提升游戏的帧率。然而，如果我们再新建一条渲染线程用来处理图形计算，那么游戏逻辑和图形渲染就可以并行执行，最终的帧率是 33.3FPS,卓越的提升！</p><p>没错，现代的游戏引擎也是这么做的，无论是 Unity 还是 UE</p><p>下面简单展示一下 Unity 的多线程渲染的基本逻辑</p><p>CPU 计算出什么需要渲染 -&gt; 渲染命令从主线程传给渲染线程 -&gt; 渲染线程生成渲染指令并提交给图形驱动 -&gt; GPU 执行渲染指令 -&gt; 显示器显示</p><p>很有意思，对吧？</p><p>当然，这里似乎有些问题</p><p>同学们，我们设想一下，主线程消耗20ms，渲染线程消耗30ms，如果主线程不等待渲染线程，那么到每3帧主线程就会领先渲染线程整整1帧，而为了追赶上主线程，渲染线程就要每4帧丢弃一帧（只保留1，2，3帧）的渲染，这会导致什么呢？</p><p>相信很多同学已经能报出答案了，画面卡顿。</p><p>那么看起来我们只能让主线程等待渲染线程了吗？</p><p>难道没有其他更好的办法了吗？</p><p>有。我们有一个经典的解决办法：让渲染进程的执行比主线程慢一帧。<br />但是这种方法是有代价的，玩家的输入需要更久才能体现到画面上，这对 FPS，格斗，竞速等品类的即时竞技游戏来说是致命的。</p><p>当然，现在的多线程渲染方案也提出了不少新法门。比如 Unity 的<code>帧同步队列</code>技术。 我不太清楚同学们对数据结构有多少了解，所以我这里只做简单的解释。 前面我们多线程渲染的基本逻辑可以简化成这个样子：</p><p>主线程 -&gt; 渲染线程 -&gt; GPU -&gt; 显示器</p><p>主线程不断向GPU下达渲染指令，显然可以类比为生产者，而GPU不断读取着渲染指令，自然是链中的消费者。渲染指令会抵达一个循环队列(RingBuffer).</p><p>简单介绍一下循环队列的工作方式：<br />循环队列的实现，实际上是靠 Head 指针和 Tail 指针的原子操作来实现的。也就是说，生产者线程写入循环队列时，会原子地去后移 Tail 指针；消费者线程读取循环队列时，会原子地去后移 Head 指针。当 Tail 指针再次超过 Head 指针，则说明队列满了，则需要阻塞生产者线程。</p><ul><li>RingBuffer 在写满的时候会阻塞主线程，等待渲染线程。</li><li>RingBuffer 在读空的时候会阻塞渲染线程，等待主线程。</li></ul><p>多线程渲染的基础知识太多了，我这里只是简单的介绍一下，如果同学们对这方面感兴趣，可以自行搜索资料或者线下找我沟通。</p><h3 id="视窗消息泵-windows-message-pump">视窗消息泵 Windows message pump</h3><p>值得注意的是，在 Windows 平台中，本身逻辑的循环等，游戏还要处理来自 Windows 系统的指令。处理这段来自 Windows 指令的代码就被叫做 <code>message pump</code>。<code>message pump</code>从 Windows 消息队列中取出消息，然后分发给游戏程序的窗口。基本的逻辑是： &gt; 先处理来自 Windows 的消息，然后在处理引擎（如果你的游戏并不依托某个引擎也是这样）的任务</p><p>下面给出一段经典的消息泵的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Msg msg;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">PeekMessage</span>(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, PM_REMOVE))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.message == WM_QUIT)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">        <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do game stuff</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这带来了一个有趣的现象，当你移动（或者其他什么操作）你游戏的窗体的时候，游戏会卡住不动。比如 <code>Slay the Spire</code> 这款游戏是用 <code>Java</code> 语言，<code>libGDX</code> 框架开发的，不过在 <code>犹格索托斯的庭院</code> 上的实验没有起效，或许这说明了 Unity 并没有默认内置/启用这一段代码，需要开发者自行实现/开启。</p><p>对这点我还没有深入研究，希望大家搞明白后可以来和我分享。</p><h4 id="windows-api-解释">Windows API 解释</h4><ul><li><code>PeekMessage</code>: 从消息队列中取出消息，但是不会阻塞</li><li>TranslateMessage: 将消息转换为字符消息</li><li>DispatchMessage: 将消息分发给窗口过程</li><li>PM_REMOVE: 从消息队列中移除消息</li><li>WM_QUIT: 指示终止应用程序</li></ul><h3 id="回调驱动框架-callback-driven-framework">回调驱动框架 Callback-driven framework</h3><p>大多数游戏引擎的子系统或者第三方游戏中间套件都是以<code>library</code>的方式构成的。请注意，这里要和 Unity Project 文件夹中的 <code>Library</code> 文件夹区分开，前者是指一组可被程序员调用的函数和类，后者是指项目的缓存文件夹。</p><p>而另外一些游戏引擎或是中间套件，则是基于 <code>framework</code> 的。或许你可以把框架视为一套半完成的应用程序，你需要也仅能在框架的留白下自定义你的代码或者覆写代码预设的某些行为。但在控制流中，你的程序并不能取得主导地位，大部分流的控制权限被框架牢牢的攥在手中，你只能取得少量的控制。当然，对开源引擎如“Godot”，或者代码可访问的引擎如“Unreal Engine”来说，你当然可以通过自己修改引擎的框架来达成自己自定义程序流程的目的，不过一来这种方法相对危险且对程序员的水平要求很高，并且对“Unity”一类的引擎来说是做不到的。</p><p>简单的来说，<code>library</code> 是你调用他，而 <code>framework</code> 是他调用你。</p><p>具体的说，<code>library</code> 仅仅是提供了一些库函数供你调用，其灵活性强，侵入性低，不主导控制流，往往针对某个特殊的功能提供解决状态；而 <code>framework</code> 灵活性较差，侵入性强，主导控制流，能够为游戏开发提供一整套的解决方案。</p><p>在基于 <code>framework</code> 的游戏引擎中，主游戏循环已经为我们准备好了，他们的调度有一套严谨的顺序，只不过在我们编写回调方法 <code>callback function</code> 去覆写他们之前，他们什么也做不了。</p><p>下面给出简单的回调驱动的伪代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while (true)</span><br><span class="line">    foreach activeObject in activeObjects</span><br><span class="line">        activeObject.start()</span><br><span class="line">        activeObject.update()</span><br><span class="line">        activeObject.end()</span><br><span class="line">    loop</span><br><span class="line">loop</span><br></pre></td></tr></table></figure><p>虽然只是一段可以说是简陋的示例，但大家有没有觉得很眼熟？没错，这就是 Unity 的 <code>MonoBehaviour</code> 的生命周期。Unity 有着相当丰富的声明周期函数，他们的本质是事件函数(<code>event functions</code>), 或者说回调(<code>callback</code>)。这是一个非常经典的回调驱动的框架。</p><h2 id="时间和游戏">时间和游戏</h2><p>现在大多数游戏都会有时间进程(progression of time)的概念。无论是 minecraft 中的日夜交替，还是 moba 游戏中对局时长，甚至是回合制游戏中的回合数，都依赖着时间进展的管理。这是从 gameplay 的角度来说的。在游戏实现的技术层面，或者无论是游戏循环还是渲染循环，也都离不开游戏时间的处理。</p><h3 id="真实时间">真实时间</h3><p>真实事件顾名思义，就是真实世界流逝的时间，然而他的计算并不容易。显然我们不能直接调用C语言的标准库函数<code>time()</code>来获取真实时间，这个函数返回的是从1970年1月1日0时0分0秒到现在的秒数，这个数值是一个相当大的整数，而我们需要的是一个足够小的浮点数。毕竟，考虑到游戏中每帧仅耗时数十毫秒，这样的测量分辨率着实太粗糙了。</p><p>所以，我们该如何解决这个问题呢？（下面的 CPU 版本都以 Pentium 为例）</p><p>答案是使用 CPU 的高分辨率计时器来测量真实时间。这种计时器通常会实现为硬件寄存器，其它以64位无符号整型数的格式，记录了自CPU上电以来所经过的时钟周期数。Intel Pentium 以来所有 x86 处理器上都存在一个叫做 "Time Stamp Counter" 的 64 位寄存器。没错，他们就是上文所说的计时器和硬件寄存器。</p><p>在 3GHz 的 Pentium 上，其 Time Stamp Counter 每周期递增一次，也就是说每秒 30 亿次。分辨率是其每秒递增次数的倒数，即 <span class="math inline">\(1/3GHz=3.33*10^{-10}s=0.333ns\)</span>。</p><p>在 Pentium 及其以上的 CPU 中，提供了一条机器指令RDTSC（Read Time Stamp Counter）来读取这个时间戳的数字，并将其保存在EDX:EAX寄存器对中。不过C++语言本身是不直接支持汇编指令的，所以我们需要使用内联汇编来调用这条指令。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">get_tsc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> a, d;</span><br><span class="line">    <span class="function">__asm__ <span class="title">volatile</span><span class="params">(<span class="string">&quot;rdtsc&quot;</span> : <span class="string">&quot;=a&quot;</span>(a), <span class="string">&quot;=d&quot;</span>(d))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> (d &lt;&lt; <span class="number">32</span>) | a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我们也可以用_emit伪指令直接嵌入该指令的机器码形式0X0F、0X31</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">unsigned</span> __int64 <span class="title">GetCycleCount</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">__asm _emit <span class="number">0x0F</span> </span><br><span class="line">__asm _emit <span class="number">0x31</span> </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>如果你使用 MSVC, 你也可以这么写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrin.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">get_tsc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __rdtsc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多核cpu或者休眠操作系统或乱序执行等带来的不精确的时间测量">多核CPU或者“休眠”操作系统或乱序执行等带来的不精确的时间测量</h4><p>CPU 再也不是从前“单打独斗”的时代了，现在的 CPU 一般都是多核的，而且还有超线程技术，这就意味着，我们不能再简单的使用 Time Stamp Counter 来测量时间了。这超级好理解，假如你的CPU时四核的，他们开始工作的事件都不一样，你该听谁的？</p><p>不光如此，现在的操作系统都有节能模式，休眠模式，这些都会导致 CPU 的时钟频率发生变化，时钟频率变化，Time Stamp Counter 的递增速度也会变化，我们测量的结果自然也不准了。</p><p>再比如，现代的 CPU 为了提高性能，会对指令进行乱序执行，这也就意味着，我们测量的时间可能是乱序执行的时间，而不是我们想要的真实时间。</p><p>当然，后来的 CPU 都提供了一个新的指令，叫做 <code>RDTSCP</code>，这个指令会在读取时间戳的同时，读取一个标志位，这个标志位会在所有指令执行完毕后才会被置位，这样我们就可以保证测量的时间是正确的了。不过他的开销显然更大，耗时差不多是<code>RDTSC</code> 的两倍。</p><p>新版本的 CPU 也对上述的三个问题打了不同程度的补丁，这里也不详细展开了。</p><p>当然，在 Windows 平台上，也可以使用更加傻瓜式的方法来测量时间，比如调用 Windows API QueryPerformanceCounter 和 QueryPerformanceFrequency。不过为了跨平台和可拓展性，游戏引擎中是否要使用 QueryPerformanceCounter 和 QueryPerformanceFrequency 还有待商榷。</p><h3 id="游戏时间">游戏时间</h3><p>在大多数情况下，游戏时间和真实事件时一致的，但这并不绝对，因为无论是从技术角度还是设计层面上考虑，游戏时间都是一个相对独立的概念。</p><p>如果我们提出一个时间流速的概念，也许会更便于大家理解。或者我们把它叫做时间缩放，这无所谓，只是个名字。</p><h4 id="时间缩放">时间缩放</h4><p>好了，让我们来分类讨论。</p><p>当时间缩放为 1 的时候，游戏时间和真实时间是一致的，这是最常见的情况。在游戏 <code>60 Seconds</code> 中，游戏说好给你60s准备应对危机，他就的确只给了你60s，1s不多1s不少。</p><p>当时间缩放为 0 的时候，游戏时间就停止了，几乎所有游戏都会设置一个暂停功能。</p><p>当时间缩放大于 0 而小于 1 的时候，帅气的 <code>子弹时间</code>就出现了。除了玩家，几乎所有对象的时间都被减速了，又或者虽然玩家的时间同样被锁死了流速，但是他却凭借高超的技艺在危机前化险为夷或者大杀四方。在塞尔达传说系列游戏中，这种效果也被称为<code>林克时间</code>。</p><p>时间缩放大于 1 的情况也并不罕见，不仅在回合制游戏中有加速战斗的功能，各类即时游戏也同样有出自不同角度考虑设计的加速功能。比如在 <code>Minecraft</code> 中，玩家可以通过睡觉来跳过夜晚，<code>维多利亚3</code> 中的游戏流速也有多档位的设计。</p><p>最有趣的是时间缩放也可以为负数，理所当然的，这种情况通常表现为游戏世界的时间倒流。大名鼎鼎的 <code>时空幻境 （Braid）</code> 和 <code>波斯王子：时之沙</code> 在这方面的设计可谓神乎其技。</p><h3 id="增量时间与固定时间">增量时间与固定时间</h3><p>前面我们说过，游戏的帧率是指以多快的时间向玩家展示一连串帧。帧率的单位是赫兹 Hz, 即每秒的执行次数，当然也可以用每秒帧数 FPS 来表示游戏的帧率。在传统上，电影的帧率是 24FPS，而游戏的帧率则是 30FPS 或者 60FPS。这通常和电子游戏流行开来时当地硬件设备（如彩色电视等）的刷新频率息息相关。</p><p>两帧之间的时间被称为 <code>帧时间 frame time</code>，当然，还要一个更加通用的的称呼 <code>增量时间 deltatime</code>, 在数学上写作 <span class="math inline">\(Δt\)</span>。 早期的游戏不曾注意到增量时间的重要性，其经常依赖处理器的速度。毕竟我们每秒执行游戏循环的次数时固定的，即游戏的帧率。可是请大家试想，曾经在 8MHz 的 CPU 上运行的游戏迁移到由 16MHz 的 CPU 负责计算的游戏机上会发生什么事呢？</p><p>没错！每秒游戏循环的次数翻了倍，从而角色和敌人的移动速度也翻了倍，大家可以想象开了二倍速的马里奥会有多抽象。这还只是帧率翻了倍，要是把该游戏迁移到频率比过去的处理器高上百倍的机器上运行呢？ 咦？这么严重的问题当初的程序员没有意识到吗？欸，我们在课堂上想一想都能考虑到的问题，实际开发游戏的工程师们会考虑不到吗？</p><p>如果你们有听过我第一节的导论课，那答案应该就能脱口而出了：当初的游戏是和游戏机绑定的，一台游戏机自带多少游戏就只能玩多少游戏，所以当时开发游戏的工作人员根本不会考虑到这一点，毕竟他们开发的游戏就根本不存在换一台机器运行的可能性，同时，在当年硬件性能捉襟见肘的年代，多节省点计算也是求之不得的。</p><p>当然，随着后来游戏产业的发展，大家也意识到了这个问题的严重性。B站上某UP主在使用模拟器测评上古老游戏的适合也曾经遇到过这个问题，游戏速度被加倍了好几十倍。不过也不是说现在的游戏就没有这个问题了，大家打开 TapTap 搜索 <code>几何决斗</code>，看看他的评论区，就能理解时间增量的正确应用是多么重要。他的问题看起来像是垂直同步 <code>v-sync</code> 和不正确的时间增量的使用共同导致的结果。当然，几何决斗只是一款连社区维护都谈不上的开源项目，但是大型游戏公司维护的 AAA 级或者说大型项目就一定能避免这个问题吗？<code>荒野大镖客</code> 和 <code>原神</code> 也都被反馈过存在高帧率游玩时会导致体力值消耗加快或者人物动作加快的 Bug。</p><h4 id="基于增量时间优化的游戏循环">基于增量时间优化的游戏循环</h4><p>现在几乎所有的游戏引擎都提供了 Time 类的增量时间的 API。Gameplay 程序员可以轻松的调用他们，并且在合适的地方调用他们。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enemy.position.x += <span class="number">150</span> * deltaTime</span><br></pre></td></tr></table></figure><p>现在，无论帧率如何这段代码都能正确的工作了。在 30FPS 时，敌人会每帧移动 5 个像素；而在 60FPS 时，敌人会每帧移动 2.5 个像素，每秒都是 150 个像素，只不过在高帧率的设备上，角色的移动会更加的平滑。</p><p>很好，这样的方法已经极大程度的让游戏和 CPU 速度脱勾了，但是，我们要怎么实现呢？换句话说，我们怎么取得 <span class="math inline">\(Δt\)</span> 呢？这听起来似乎很简单，在一帧开始的时候取一次 <code>RDTSC</code>, 在结束的时候再取一次，然后取两者之差，再减去在 TSC 上取值所花的时间就能精准度量上一帧的 <code>Δt</code> 了。拿到上一帧的时间增量之后，自然就能使用其来预测当前帧的时间增量了。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">time</span> = GetTime()</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    var lastTime = <span class="built_in">time</span></span><br><span class="line">    <span class="built_in">time</span> = GetTime()</span><br><span class="line">    var deltaTime = <span class="built_in">time</span> – lastTime</span><br><span class="line">    ProcessInput()</span><br><span class="line">    Update(deltaTime)</span><br><span class="line">    GenerateOutput(deltaTime)</span><br><span class="line">loop</span><br></pre></td></tr></table></figure><p>很多游戏引擎都是采用上面的办法，但是该方法存在一个不可忽视的缺陷：我们用上一帧的时间增量预测的下一帧时间并不准确。某些帧可能会由于某些原因（程序的集中处理或者玩家的异常操作）而消耗过长/少的时间，我们称这个现象为 <code>帧率尖峰 frame-rate spike</code>. 比如在物理模拟中，某帧消耗了过长的时间，那么在下一帧我们就要 <code>步进</code> 两次来遮掩上一帧，这也会导致下一帧变得同样很慢，由此往复只会导致低帧问题越来越严重。</p><p>不过，由于游戏循环中帧与帧之间存在的时空相关性，如果我们将多个帧的时间增量的平均值作为下一帧时间增量的指导，那么也能大大缓解帧率尖峰带来的问题。</p><h4 id="固定时间">固定时间</h4><p>所以，在一些帧率敏感的模块中，我们往往更倾向于向目标帧率靠近，比如我们要达到 33 帧的效果，那么如果本帧在预测的事件前就完成了任务，就让先线程去做别的些什么什么，反之只好等待下一个目标时间。该方法被称为<code>帧率调控 frame-rate governing</code>。</p><p>当然，只有游戏的平均帧率靠近该目标帧率的时候该方法才能尽可能的多发挥出效能。</p><p>然而，维持帧率的稳定对游戏各个子系统的意义都是非凡的。在引擎物理模拟的数学积分，以固定的时间更新效果最佳，而且物理效果也会变得更稳定流畅。包括屏幕刷新率和游戏帧率的不匹配，也会导致画面撕裂 <code>tearing</code>. 甚至是游戏的录播回访，也和游戏稳住是否稳定息息相关。周所周知，游戏的回访并非真的是屏幕的录制，只不过他们存储了游戏时间内的事件和时间戳，在打开回访的时候依次输出而已。有个很有意思的例子就是 <code>王者荣耀</code> 的回放，其实就是开了一局新的本地游戏。</p><h3 id="全局时间和局部时间">全局时间和局部时间</h3><p>典型的如动画的时间是游离于整体时间轴之上的，我们可以在编辑面板单独调控动画的时间流速甚至他们的开始和结束。</p><h2 id="游戏对象">游戏对象</h2><h3 id="游戏对象的类型">游戏对象的类型</h3><ul><li>需要渲染不需要处理逻辑 背景，不可交互的物品等</li><li>既需要渲染也需要处理逻辑 玩家，敌人，子弹等</li><li>不需要渲染但需要处理逻辑 摄像机，空气墙</li></ul><h3 id="游戏对象一定是面向对象吗">游戏“对象”一定是面向对象吗？</h3><p>早期的游戏引擎和 Gameplay 会使用OOP，但是在复杂的游戏世界中并没有非常清晰的父子继承关系。eg. 水陆两栖单位。</p><p>现在更多地使用 Component 的方式，将游戏对象的行为分解为多个组件，每个组件只负责一种行为，并且 Component-Base 的模式也非常利于非程序员理解，因为他就像乐高积木一样的 PnP。</p><h3 id="游戏对象的生命周期">游戏对象的生命周期</h3><p>在某些早期的游戏引擎中，和上面我们展示的<code>foreach activeObject in activeObjects</code>一样，是遍历所有的 GO，但是在现代的游戏引擎中，Component 则被更多的采用了。理由是将更多相同的模块放在一起可以最大程度的提高运行效率，也方便采用 Pipeline 的方式来运作。</p><h2 id="参考文章">参考文章</h2><p>1.<a href="https://developer.unity.cn/projects/5ff9c6b0edbc2a60edd4807c">Unity 2020.2 优化了 Time.deltaTime，以实现更流畅的游戏体验</a><br />2.<a href="https://zhuanlan.zhihu.com/p/591218281">Unity多线程渲染概述</a><br />3.<a href="https://www.cnblogs.com/SunWentao/archive/2008/10/20/1315313.html">使用CPU时间戳进行高精度计时</a><br />4.<a href="http://taggedwiki.zubiaga.org/new_content/6fda7324cd6ec352ca95609d6ff5615a">Time Stamp Counter</a><br />5.<a href="http://www.wangkaixuan.tech/?p=901">细说RDTSC的坑</a></p>]]></content>
      
      
      <categories>
          
          <category> GamePlay Programming Exprience </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GamePlay Programming Exprience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法_前缀、中缀、后缀表达式</title>
      <link href="/posts/29455a3d/"/>
      <url>/posts/29455a3d/</url>
      
        <content type="html"><![CDATA[<h2 id="中缀表达式">中缀表达式</h2><p>中缀表达式就是我们通常所写的表达式，如：<span class="math inline">\(1 + 2 * 3\)</span>，<span class="math inline">\(1 + (2 + 3) * 4 - 5\)</span>，<span class="math inline">\(1 + 2 * (3 + 4 * (5 + 6))\)</span> 等等。</p><h2 id="后缀表达式及其求值方法">后缀表达式及其求值方法</h2><p>后缀表达式又称为逆波兰表达式，它的特点是运算符在操作数的后面，如：<span class="math inline">\(1 2 3 * +\)</span>，<span class="math inline">\(1 2 3 + 4 * + 5 -\)</span>，<span class="math inline">\(1 2 3 4 5 6 + * + * +\)</span> 等等。</p><h3 id="后缀表达式的求值方法">后缀表达式的求值方法</h3><p>后缀表达式的求值方法是：从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。</p><span id="more"></span><p>例如：<span class="math inline">\(1 2 3 * +\)</span> 的求值过程如下：</p><table><thead><tr class="header"><th style="text-align: center;">读入字符</th><th style="text-align: center;">当前栈</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">读入 1，进栈</td></tr><tr class="even"><td style="text-align: center;">2</td><td style="text-align: center;">1 2</td><td style="text-align: center;">读入 2，进栈</td></tr><tr class="odd"><td style="text-align: center;">3</td><td style="text-align: center;">1 2 3</td><td style="text-align: center;">读入 3，进栈</td></tr><tr class="even"><td style="text-align: center;">*</td><td style="text-align: center;">1 6</td><td style="text-align: center;">读入 <em>，出栈 3 和 2，计算 2 </em> 3 = 6，将 6 进栈</td></tr><tr class="odd"><td style="text-align: center;">+</td><td style="text-align: center;">7</td><td style="text-align: center;">读入 +，出栈 6 和 1，计算 1 + 6 = 7，将 7 进栈</td></tr></tbody></table><h3 id="c-实现后缀表达式的求值">C++ 实现后缀表达式的求值</h3><p>用C++实现后缀表达式的求值。要求有简单的控制台UI，并且要对用户的危险行为进行检查和警告。控制台输出的语句要求是中英文对照，并且在用户进行错误操作的时候告知他进行了什么错误操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOperator</span><span class="params">(<span class="type">char</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">performOperation</span><span class="params">(<span class="type">char</span> op, <span class="type">double</span> operand1, <span class="type">double</span> operand2)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">evaluatePostfixExpression</span><span class="params">(<span class="type">const</span> string&amp; postfix, <span class="type">double</span>&amp; result)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;欢迎使用后缀表达式计算器！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入一个后缀表达式，使用空格分隔操作数和操作符，输入&#x27;q&#x27;退出：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        string input;</span><br><span class="line">        <span class="built_in">getline</span>(cin, input);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (input == <span class="string">&quot;q&quot;</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;感谢使用后缀表达式计算器，再见！&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查输入中的非法字符</span></span><br><span class="line">        <span class="type">bool</span> validInput = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : input) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isspace</span>(c) &amp;&amp; !<span class="built_in">isdigit</span>(c) &amp;&amp; !<span class="built_in">isOperator</span>(c)) &#123;</span><br><span class="line">                validInput = <span class="literal">false</span>;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;错误：输入包含非法字符 &#x27;&quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (validInput) &#123;</span><br><span class="line">            <span class="type">double</span> result;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">evaluatePostfixExpression</span>(input, result)) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;结果： &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;错误：无效的后缀表达式&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入另一个后缀表达式，或输入&#x27;q&#x27;退出：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOperator</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;*&#x27;</span> || c == <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">performOperation</span><span class="params">(<span class="type">char</span> op, <span class="type">double</span> operand1, <span class="type">double</span> operand2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> operand1 + operand2;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> operand1 - operand2;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> operand1 * operand2;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> (operand2 != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> operand1 / operand2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;错误：除数不能为零&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;错误：未知的操作符 &#x27;&quot;</span> &lt;&lt; op &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">evaluatePostfixExpression</span><span class="params">(<span class="type">const</span> string&amp; postfix, <span class="type">double</span>&amp; result)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">double</span>&gt; operandStack;</span><br><span class="line"></span><br><span class="line">    <span class="function">istringstream <span class="title">iss</span><span class="params">(postfix)</span></span>;</span><br><span class="line">    string token;</span><br><span class="line">    <span class="keyword">while</span> (iss &gt;&gt; token) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(token[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="type">double</span> operand = <span class="built_in">stod</span>(token);</span><br><span class="line">            operandStack.<span class="built_in">push</span>(operand);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isOperator</span>(token[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (operandStack.<span class="built_in">size</span>() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;错误：操作数不足&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">double</span> operand2 = operandStack.<span class="built_in">top</span>();</span><br><span class="line">            operandStack.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">double</span> operand1 = operandStack.<span class="built_in">top</span>();</span><br><span class="line">            operandStack.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">double</span> result = <span class="built_in">performOperation</span>(token[<span class="number">0</span>], operand1, operand2);</span><br><span class="line">            operandStack.<span class="built_in">push</span>(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;错误：无效的标记 &#x27;&quot;</span> &lt;&lt; token &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (operandStack.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">        result = operandStack.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;错误：操作数不足或操作符过多&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="c-实现后缀表达式的求值-1">C 实现后缀表达式的求值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_STACK_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable : 4996)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈结构和操作</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> data[MAX_STACK_SIZE];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initialize</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Stack* <span class="built_in">stack</span>, <span class="type">double</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;top &lt; MAX_STACK_SIZE - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;data[++<span class="built_in">stack</span>-&gt;top] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;错误：栈已满\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">pop</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;错误：栈为空\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isOperator</span><span class="params">(<span class="type">char</span> c)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">performOperation</span><span class="params">(<span class="type">char</span> op, <span class="type">double</span> operand1, <span class="type">double</span> operand2)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">evaluatePostfixExpression</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* postfix, <span class="type">double</span>* result)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;欢迎使用后缀表达式计算器！\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个后缀表达式，使用空格分隔操作数和操作符，输入&#x27;q&#x27;退出：\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> input[<span class="number">100</span>];</span><br><span class="line">        fgets(input, <span class="keyword">sizeof</span>(input), <span class="built_in">stdin</span>);</span><br><span class="line">        input[<span class="built_in">strcspn</span>(input, <span class="string">&quot;\n&quot;</span>)] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 去掉换行符</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input, <span class="string">&quot;q&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;感谢使用后缀表达式计算器，再见！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查输入中的非法字符</span></span><br><span class="line">        <span class="type">int</span> validInput = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; input[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isspace</span>(input[i]) &amp;&amp; !<span class="built_in">isdigit</span>(input[i]) &amp;&amp; !isOperator(input[i])) &#123;</span><br><span class="line">                validInput = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;错误：输入包含非法字符 &#x27;%c&#x27;\n&quot;</span>, input[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (validInput) &#123;</span><br><span class="line">            <span class="type">double</span> result;</span><br><span class="line">            <span class="keyword">if</span> (evaluatePostfixExpression(input, &amp;result)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;结果： %g\n&quot;</span>, result);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;错误：无效的后缀表达式\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入另一个后缀表达式，或输入&#x27;q&#x27;退出：\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isOperator</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;*&#x27;</span> || c == <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">performOperation</span><span class="params">(<span class="type">char</span> op, <span class="type">double</span> operand1, <span class="type">double</span> operand2)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> operand1 + operand2;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> operand1 - operand2;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> operand1 * operand2;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> (operand2 != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> operand1 / operand2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;错误：除数不能为零\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;错误：未知的操作符 &#x27;%c&#x27;\n&quot;</span>, op);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">evaluatePostfixExpression</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* postfix, <span class="type">double</span>* result)</span> &#123;</span><br><span class="line">    Stack operandStack;</span><br><span class="line">    initialize(&amp;operandStack);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* token = strtok((<span class="type">char</span>*)postfix, <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (token != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(token[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="type">double</span> operand = atof(token);</span><br><span class="line">            push(&amp;operandStack, operand);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isOperator(token[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (operandStack.top &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;错误：操作数不足\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">double</span> operand2 = pop(&amp;operandStack);</span><br><span class="line">            <span class="type">double</span> operand1 = pop(&amp;operandStack);</span><br><span class="line">            <span class="type">double</span> result = performOperation(token[<span class="number">0</span>], operand1, operand2);</span><br><span class="line">            push(&amp;operandStack, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;错误：无效的标记 &#x27;%s&#x27;\n&quot;</span>, token);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        token = strtok(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (operandStack.top == <span class="number">0</span>) &#123;</span><br><span class="line">        *result = operandStack.data[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;错误：操作数不足或操作符过多\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后缀表达式的转换方法中缀转后缀">后缀表达式的转换方法(中缀转后缀)</h3><p>将中缀表达式转换为后缀表达式的方法是：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，若是符号，则判断其与栈顶符号的优先级，是右括号或优先级不高于栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。</p><p>例如：<span class="math inline">\(1 + (2 + 3) * 4 - 5\)</span> 的转换过程如下：</p><table><thead><tr class="header"><th style="text-align: center;">读入字符</th><th style="text-align: center;">当前栈</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">读入 1，输出</td></tr><tr class="even"><td style="text-align: center;">+</td><td style="text-align: center;">+</td><td style="text-align: center;">读入 +，进栈</td></tr><tr class="odd"><td style="text-align: center;">(</td><td style="text-align: center;">+ (</td><td style="text-align: center;">读入 (，进栈</td></tr><tr class="even"><td style="text-align: center;">2</td><td style="text-align: center;">+ ( 2</td><td style="text-align: center;">读入 2，输出</td></tr><tr class="odd"><td style="text-align: center;">+</td><td style="text-align: center;">+ ( +</td><td style="text-align: center;">读入 +，进栈</td></tr><tr class="even"><td style="text-align: center;">3</td><td style="text-align: center;">+ ( + 3</td><td style="text-align: center;">读入 3，输出</td></tr><tr class="odd"><td style="text-align: center;">)</td><td style="text-align: center;">+</td><td style="text-align: center;">读入 )，依次出栈 + 和 (，输出</td></tr><tr class="even"><td style="text-align: center;">*</td><td style="text-align: center;">*</td><td style="text-align: center;">读入 *，进栈</td></tr><tr class="odd"><td style="text-align: center;">4</td><td style="text-align: center;">* 4</td><td style="text-align: center;">读入 4，输出</td></tr><tr class="even"><td style="text-align: center;">-</td><td style="text-align: center;">-</td><td style="text-align: center;">读入 -，进栈</td></tr><tr class="odd"><td style="text-align: center;">5</td><td style="text-align: center;">- 5</td><td style="text-align: center;">读入 5，输出</td></tr><tr class="even"><td style="text-align: center;">空</td><td style="text-align: center;">-</td><td style="text-align: center;">依次出栈 - 和 *，输出</td></tr></tbody></table><p>转换后的后缀表达式为：<span class="math inline">\(1 2 3 + 4 * + 5 -\)</span>。</p><h3 id="c-实现中缀表达式转后缀表达式">C++ 实现中缀表达式转后缀表达式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getOperatorPrecedence</span><span class="params">(<span class="type">char</span> op)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOperator</span><span class="params">(<span class="type">char</span> c)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">infixToPostfix</span><span class="params">(<span class="type">const</span> string&amp; infix)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;欢迎使用中缀表达式转后缀表达式程序！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入一个中缀表达式，输入&#x27;q&#x27;退出：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        string infixExpression;</span><br><span class="line">        <span class="built_in">getline</span>(cin, infixExpression);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (infixExpression == <span class="string">&quot;q&quot;</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;感谢使用中缀表达式转后缀表达式程序，再见！&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string postfixExpression = <span class="built_in">infixToPostfix</span>(infixExpression);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;后缀表达式：&quot;</span> &lt;&lt; postfixExpression &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入另一个中缀表达式，或输入&#x27;q&#x27;退出：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getOperatorPrecedence</span><span class="params">(<span class="type">char</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOperator</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;*&#x27;</span> || c == <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">infixToPostfix</span><span class="params">(<span class="type">const</span> string&amp; infix)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; operatorStack;</span><br><span class="line">    string postfixExpression;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : infix) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(c)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c) || <span class="built_in">isalpha</span>(c)) &#123;</span><br><span class="line">            postfixExpression += c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isOperator</span>(c)) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!operatorStack.<span class="built_in">empty</span>() &amp;&amp;</span><br><span class="line">                <span class="built_in">getOperatorPrecedence</span>(operatorStack.<span class="built_in">top</span>()) &gt;= <span class="built_in">getOperatorPrecedence</span>(c)) &#123;</span><br><span class="line">                postfixExpression += operatorStack.<span class="built_in">top</span>();</span><br><span class="line">                operatorStack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            operatorStack.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            operatorStack.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!operatorStack.<span class="built_in">empty</span>() &amp;&amp; operatorStack.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                postfixExpression += operatorStack.<span class="built_in">top</span>();</span><br><span class="line">                operatorStack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!operatorStack.<span class="built_in">empty</span>() &amp;&amp; operatorStack.<span class="built_in">top</span>() == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                operatorStack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;错误：括号不匹配&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;错误：无效的字符 &#x27;&quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!operatorStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (operatorStack.<span class="built_in">top</span>() == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;错误：括号不匹配&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        postfixExpression += operatorStack.<span class="built_in">top</span>();</span><br><span class="line">        operatorStack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> postfixExpression;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="c-实现中缀表达式转后缀表达式-1">C 实现中缀表达式转后缀表达式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_STACK_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈结构和操作</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> data[MAX_STACK_SIZE];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initialize</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isFull</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == MAX_STACK_SIZE - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Stack* <span class="built_in">stack</span>, <span class="type">char</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isFull(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;data[++<span class="built_in">stack</span>-&gt;top] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;错误：栈已满\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">pop</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;错误：栈为空\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">peek</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getOperatorPrecedence</span><span class="params">(<span class="type">char</span> op)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">isOperator</span><span class="params">(<span class="type">char</span> c)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">infixToPostfix</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* infix, <span class="type">char</span>* postfix)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;欢迎使用中缀表达式转后缀表达式程序！\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个中缀表达式，输入&#x27;q&#x27;退出：\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> infixExpression[<span class="number">100</span>];</span><br><span class="line">        fgets(infixExpression, <span class="keyword">sizeof</span>(infixExpression), <span class="built_in">stdin</span>);</span><br><span class="line">        infixExpression[<span class="built_in">strcspn</span>(infixExpression, <span class="string">&quot;\n&quot;</span>)] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 去掉换行符</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(infixExpression, <span class="string">&quot;q&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;感谢使用中缀表达式转后缀表达式程序，再见！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> postfixExpression[<span class="number">100</span>];</span><br><span class="line">        infixToPostfix(infixExpression, postfixExpression);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;后缀表达式：%s\n&quot;</span>, postfixExpression);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入另一个中缀表达式，或输入&#x27;q&#x27;退出：\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getOperatorPrecedence</span><span class="params">(<span class="type">char</span> op)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isOperator</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;*&#x27;</span> || c == <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">infixToPostfix</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* infix, <span class="type">char</span>* postfix)</span> &#123;</span><br><span class="line">    Stack operatorStack;</span><br><span class="line">    initialize(&amp;operatorStack);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (infix[i] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(infix[i])) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isdigit</span>(infix[i]) || <span class="built_in">isalpha</span>(infix[i])) &#123;</span><br><span class="line">            postfix[j++] = infix[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isOperator(infix[i])) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!isEmpty(&amp;operatorStack) &amp;&amp; getOperatorPrecedence(peek(&amp;operatorStack)) &gt;= getOperatorPrecedence(infix[i])) &#123;</span><br><span class="line">                postfix[j++] = pop(&amp;operatorStack);</span><br><span class="line">            &#125;</span><br><span class="line">            push(&amp;operatorStack, infix[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (infix[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            push(&amp;operatorStack, infix[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (infix[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!isEmpty(&amp;operatorStack) &amp;&amp; peek(&amp;operatorStack) != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                postfix[j++] = pop(&amp;operatorStack);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isEmpty(&amp;operatorStack) &amp;&amp; peek(&amp;operatorStack) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                pop(&amp;operatorStack); <span class="comment">// 弹出 &#x27;(&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;错误：括号不匹配\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;错误：无效的字符 &#x27;%c&#x27;\n&quot;</span>, infix[i]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(&amp;operatorStack)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (peek(&amp;operatorStack) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;错误：括号不匹配\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        postfix[j++] = pop(&amp;operatorStack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postfix[j] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 添加字符串终止符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前缀表达式及其求值方法">前缀表达式及其求值方法</h2><p>前缀表达式又称为波兰表达式，它的特点是运算符在操作数的前面，如：<span class="math inline">\(+ 1 * 2 3\)</span>，<span class="math inline">\(- + 1 * + 2 3 4 5\)</span>，<span class="math inline">\(+ 1 * 2 + 3 * 4 + 5 6\)</span> 等等。</p><h3 id="前缀表达式的求值方法">前缀表达式的求值方法</h3><p>前缀表达式的求值方法是：从右到左遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。</p><p>例如：<span class="math inline">\(+ 1 * 2 3\)</span> 的求值过程如下：</p><table><thead><tr class="header"><th style="text-align: center;">读入字符</th><th style="text-align: center;">当前栈</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">3</td><td style="text-align: center;">3</td><td style="text-align: center;">读入 3，进栈</td></tr><tr class="even"><td style="text-align: center;">2</td><td style="text-align: center;">3 2</td><td style="text-align: center;">读入 2，进栈</td></tr><tr class="odd"><td style="text-align: center;">*</td><td style="text-align: center;">6</td><td style="text-align: center;">读入 <em>，出栈 2 和 3，计算 2 </em> 3 = 6，将 6 进栈</td></tr><tr class="even"><td style="text-align: center;">1</td><td style="text-align: center;">6 1</td><td style="text-align: center;">读入 1，进栈</td></tr><tr class="odd"><td style="text-align: center;">+</td><td style="text-align: center;">7</td><td style="text-align: center;">读入 +，出栈 1 和 6，计算 1 + 6 = 7，将 7 进栈</td></tr></tbody></table><h3 id="c-实现前缀表达式的求值">C++ 实现前缀表达式的求值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOperator</span><span class="params">(<span class="type">const</span> string&amp; token)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isNumeric</span><span class="params">(<span class="type">const</span> string&amp; token)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">evaluatePrefixExpression</span><span class="params">(<span class="type">const</span> vector&lt;string&gt;&amp; tokens)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;欢迎使用前缀表达式求值程序！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入前缀表达式，操作符和操作数之间用空格分隔，支持+、-、*、/：&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;输入 q 退出程序&quot;</span> &lt;&lt; endl;</span><br><span class="line">        string input;</span><br><span class="line">        <span class="built_in">getline</span>(cin, input);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (input == <span class="string">&quot;q&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 用户输入了&quot;q&quot;，退出程序</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">istringstream <span class="title">iss</span><span class="params">(input)</span></span>;</span><br><span class="line">        vector&lt;string&gt; tokens;</span><br><span class="line"></span><br><span class="line">        string token;</span><br><span class="line">        <span class="keyword">while</span> (iss &gt;&gt; token) &#123;</span><br><span class="line">            tokens.<span class="built_in">push_back</span>(token);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tokens.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;错误：输入为空，请重新输入表达式。&quot;</span> &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;输入 q 退出程序&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 继续下一次循环</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> result = <span class="built_in">evaluatePrefixExpression</span>(tokens);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isnan</span>(result)) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;表达式结果为：&quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;错误：无法计算表达式结果，请检查表达式是否正确。&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;感谢使用前缀表达式求值程序！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOperator</span><span class="params">(<span class="type">const</span> string&amp; token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (token == <span class="string">&quot;+&quot;</span> || token == <span class="string">&quot;-&quot;</span> || token == <span class="string">&quot;*&quot;</span> || token == <span class="string">&quot;/&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isNumeric</span><span class="params">(<span class="type">const</span> string&amp; token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : token) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(c) &amp;&amp; c != <span class="string">&#x27;.&#x27;</span> &amp;&amp; c != <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">evaluatePrefixExpression</span><span class="params">(<span class="type">const</span> vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">double</span>&gt; operandStack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = tokens.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">const</span> string&amp; token = tokens[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isNumeric</span>(token)) &#123;</span><br><span class="line">            operandStack.<span class="built_in">push</span>(<span class="built_in">stod</span>(token));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isOperator</span>(token)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (operandStack.<span class="built_in">size</span>() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;错误：操作数不足，无法进行操作。&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">return</span> NAN;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">double</span> operand1 = operandStack.<span class="built_in">top</span>();</span><br><span class="line">            operandStack.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">double</span> operand2 = operandStack.<span class="built_in">top</span>();</span><br><span class="line">            operandStack.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (token == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">                operandStack.<span class="built_in">push</span>(operand1 + operand2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">                operandStack.<span class="built_in">push</span>(operand1 - operand2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">                operandStack.<span class="built_in">push</span>(operand1 * operand2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (operand2 == <span class="number">0</span>) &#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;错误：除数为零，无法进行除法操作。&quot;</span> &lt;&lt; endl;</span><br><span class="line">                    <span class="keyword">return</span> NAN;</span><br><span class="line">                &#125;</span><br><span class="line">                operandStack.<span class="built_in">push</span>(operand1 / operand2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;错误：无效的表达式元素 \&quot;&quot;</span> &lt;&lt; token &lt;&lt; <span class="string">&quot;\&quot;，请检查表达式是否正确。&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> NAN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (operandStack.<span class="built_in">size</span>() != <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;错误：操作数和操作符数量不匹配，无法计算表达式结果。&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> NAN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> operandStack.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="c-实现前缀表达式的求值-1">C 实现前缀表达式的求值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EXPRESSION_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable : 4996)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isOperator</span><span class="params">(<span class="type">const</span> <span class="type">char</span> token)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isNumeric</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* token)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">evaluatePrefixExpression</span><span class="params">(<span class="type">const</span> <span class="type">char</span>** tokens, <span class="type">int</span> numTokens)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;欢迎使用前缀表达式求值程序！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入前缀表达式，操作符和操作数之间用空格分隔，支持+、-、*、/：\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入 q 退出程序。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> input[MAX_EXPRESSION_SIZE];</span><br><span class="line">        fgets(input, <span class="keyword">sizeof</span>(input), <span class="built_in">stdin</span>);</span><br><span class="line">        input[<span class="built_in">strcspn</span>(input, <span class="string">&quot;\n&quot;</span>)] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 移除末尾的换行符</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input, <span class="string">&quot;q&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 用户输入了&quot;q&quot;，退出程序</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* delimiters = <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="type">char</span>* token = strtok(input, delimiters);</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* tokens[MAX_EXPRESSION_SIZE];</span><br><span class="line">        <span class="type">int</span> numTokens = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (token != <span class="literal">NULL</span> &amp;&amp; numTokens &lt; MAX_EXPRESSION_SIZE) &#123;</span><br><span class="line">            tokens[numTokens] = token;</span><br><span class="line">            numTokens++;</span><br><span class="line">            token = strtok(<span class="literal">NULL</span>, delimiters);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (numTokens == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;错误：输入为空，请重新输入表达式。\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入 q 退出程序。\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 继续下一次循环</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> result = evaluatePrefixExpression(tokens, numTokens);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isnan(result)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;表达式结果为：%g\n&quot;</span>, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;错误：无法计算表达式结果，请检查表达式是否正确。\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;感谢使用前缀表达式求值程序！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isOperator</span><span class="params">(<span class="type">const</span> <span class="type">char</span> token)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (token == <span class="string">&#x27;+&#x27;</span> || token == <span class="string">&#x27;-&#x27;</span> || token == <span class="string">&#x27;*&#x27;</span> || token == <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isNumeric</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* token)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; token[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(token[i]) &amp;&amp; token[i] != <span class="string">&#x27;.&#x27;</span> &amp;&amp; token[i] != <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">evaluatePrefixExpression</span><span class="params">(<span class="type">const</span> <span class="type">char</span>** tokens, <span class="type">int</span> numTokens)</span> &#123;</span><br><span class="line">    <span class="type">double</span> operandStack[MAX_EXPRESSION_SIZE];</span><br><span class="line">    <span class="type">int</span> top = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = numTokens - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* token = tokens[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isNumeric(token)) &#123;</span><br><span class="line">            operandStack[++top] = atof(token);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isOperator(token[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (top &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;错误：操作数不足，无法进行操作。\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> NAN;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">double</span> operand1 = operandStack[top--];</span><br><span class="line">            <span class="type">double</span> operand2 = operandStack[top--];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (token[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                operandStack[++top] = operand1 + operand2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                operandStack[++top] = operand1 - operand2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                operandStack[++top] = operand1 * operand2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> (operand2 == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;错误：除数为零，无法进行除法操作。\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> NAN;</span><br><span class="line">                &#125;</span><br><span class="line">                operandStack[++top] = operand1 / operand2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;错误：无效的操作符 \&quot;%s\&quot;，请检查表达式是否正确。\n&quot;</span>, token);</span><br><span class="line">                <span class="keyword">return</span> NAN;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;错误：无效的表达式元素 \&quot;%s\&quot;，请检查表达式是否正确。\n&quot;</span>, token);</span><br><span class="line">            <span class="keyword">return</span> NAN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (top != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;错误：操作数和操作符数量不匹配，无法计算表达式结果。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> NAN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> operandStack[top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前缀表达式的转换方法中缀转前缀">前缀表达式的转换方法(中缀转前缀)</h3><p>将中缀表达式转换为前缀表达式的方法是：从右到左遍历中缀表达式的每个数字和符号，若是数字就输出，若是符号，则判断其与栈顶符号的优先级，是右括号或优先级不高于栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出前缀表达式为止。</p><p>例如：<span class="math inline">\(1 + (2 + 3) * 4 - 5\)</span> 的转换过程如下：</p><table><thead><tr class="header"><th style="text-align: center;">读入字符</th><th style="text-align: center;">当前栈</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">5</td><td style="text-align: center;">5</td><td style="text-align: center;">读入 5，进栈</td></tr><tr class="even"><td style="text-align: center;">-</td><td style="text-align: center;">-</td><td style="text-align: center;">读入 -，进栈</td></tr><tr class="odd"><td style="text-align: center;">4</td><td style="text-align: center;">- 4</td><td style="text-align: center;">读入 4，进栈</td></tr><tr class="even"><td style="text-align: center;">*</td><td style="text-align: center;">*</td><td style="text-align: center;">读入 *，进栈</td></tr><tr class="odd"><td style="text-align: center;">+</td><td style="text-align: center;">+</td><td style="text-align: center;">读入 +，进栈</td></tr><tr class="even"><td style="text-align: center;">3</td><td style="text-align: center;">+ 3</td><td style="text-align: center;">读入 3，进栈</td></tr><tr class="odd"><td style="text-align: center;">+</td><td style="text-align: center;">+</td><td style="text-align: center;">读入 +，进栈</td></tr><tr class="even"><td style="text-align: center;">2</td><td style="text-align: center;">+ 2</td><td style="text-align: center;">读入 2，进栈</td></tr><tr class="odd"><td style="text-align: center;">(</td><td style="text-align: center;">+ (</td><td style="text-align: center;">读入 (，进栈</td></tr><tr class="even"><td style="text-align: center;">1</td><td style="text-align: center;">+ ( 1</td><td style="text-align: center;">读入 1，输出</td></tr><tr class="odd"><td style="text-align: center;">空</td><td style="text-align: center;">+</td><td style="text-align: center;">依次出栈 + 和 (，输出</td></tr></tbody></table><p>转换后的前缀表达式为：<span class="math inline">\(- * + 1 2 3 4 5\)</span>。</p><h3 id="c-实现中缀表达式转前缀表达式">C++ 实现中缀表达式转前缀表达式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getOperatorPrecedence</span><span class="params">(<span class="type">char</span> op)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOperator</span><span class="params">(<span class="type">char</span> token)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOperand</span><span class="params">(<span class="type">char</span> token)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">infixToPrefix</span><span class="params">(<span class="type">const</span> string&amp; infixExpression)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;欢迎使用中缀表达式转前缀表达式程序！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入中缀表达式或输入 &#x27;q&#x27; 退出：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        string input;</span><br><span class="line">        <span class="built_in">getline</span>(cin, input);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (input == <span class="string">&quot;q&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 用户输入了&#x27;q&#x27;，退出程序</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string prefixExpression = <span class="built_in">infixToPrefix</span>(input);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!prefixExpression.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;前缀表达式为：&quot;</span> &lt;&lt; prefixExpression &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;错误：无法转换表达式，请检查表达式是否正确。&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;感谢使用中缀表达式转前缀表达式程序！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getOperatorPrecedence</span><span class="params">(<span class="type">char</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOperator</span><span class="params">(<span class="type">char</span> token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (token == <span class="string">&#x27;+&#x27;</span> || token == <span class="string">&#x27;-&#x27;</span> || token == <span class="string">&#x27;*&#x27;</span> || token == <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOperand</span><span class="params">(<span class="type">char</span> token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isalnum</span>(token);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">infixToPrefix</span><span class="params">(<span class="type">const</span> string&amp; infixExpression)</span> </span>&#123;</span><br><span class="line">    string prefixExpression;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; operatorStack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转中缀表达式，方便从右到左处理</span></span><br><span class="line">    string reversedInfix = infixExpression;</span><br><span class="line">    <span class="built_in">reverse</span>(reversedInfix.<span class="built_in">begin</span>(), reversedInfix.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> token : reversedInfix) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isOperand</span>(token)) &#123;</span><br><span class="line">            prefixExpression = token + prefixExpression;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isOperator</span>(token)) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!operatorStack.<span class="built_in">empty</span>() &amp;&amp; <span class="built_in">getOperatorPrecedence</span>(token) &lt; <span class="built_in">getOperatorPrecedence</span>(operatorStack.<span class="built_in">top</span>())) &#123;</span><br><span class="line">                prefixExpression = operatorStack.<span class="built_in">top</span>() + prefixExpression;</span><br><span class="line">                operatorStack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            operatorStack.<span class="built_in">push</span>(token);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            operatorStack.<span class="built_in">push</span>(token);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!operatorStack.<span class="built_in">empty</span>() &amp;&amp; operatorStack.<span class="built_in">top</span>() != <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                prefixExpression = operatorStack.<span class="built_in">top</span>() + prefixExpression;</span><br><span class="line">                operatorStack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!operatorStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                operatorStack.<span class="built_in">pop</span>(); <span class="comment">// 弹出匹配的右括号</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 括号不匹配</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!operatorStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (operatorStack.<span class="built_in">top</span>() == <span class="string">&#x27;(&#x27;</span> || operatorStack.<span class="built_in">top</span>() == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 括号不匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">        prefixExpression = operatorStack.<span class="built_in">top</span>() + prefixExpression;</span><br><span class="line">        operatorStack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prefixExpression;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="c-实现中缀表达式转前缀表达式-1">C 实现中缀表达式转前缀表达式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable : 4996)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> arr[MAX_SIZE];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(Stack* s)</span> &#123;</span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Stack s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isFull</span><span class="params">(Stack s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.top == MAX_SIZE - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Stack* s, <span class="type">char</span> ch)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(*s)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack overflow!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;arr[++(s-&gt;top)] = ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">pop</span><span class="params">(Stack* s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(*s)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack underflow!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;arr[(s-&gt;top)--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">peek</span><span class="params">(Stack s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.arr[s.top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isOperator</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ch == <span class="string">&#x27;+&#x27;</span> || ch == <span class="string">&#x27;-&#x27;</span> || ch == <span class="string">&#x27;*&#x27;</span> || ch == <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">precedence</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">infixToPrefix</span><span class="params">(<span class="type">char</span>* infix, <span class="type">char</span>* prefix)</span> &#123;</span><br><span class="line">    Stack operators;</span><br><span class="line">    initStack(&amp;operators);</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">strlen</span>(infix) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">char</span> ch = infix[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) || (ch &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;z&#x27;</span>) || (ch &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;Z&#x27;</span>)) &#123;</span><br><span class="line">            prefix[j++] = ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            push(&amp;operators, ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!isEmpty(operators) &amp;&amp; peek(operators) != <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                prefix[j++] = pop(&amp;operators);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isEmpty(operators) &amp;&amp; peek(operators) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                pop(&amp;operators);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isOperator(ch)) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!isEmpty(operators) &amp;&amp; precedence(ch) &lt;= precedence(peek(operators))) &#123;</span><br><span class="line">                prefix[j++] = pop(&amp;operators);</span><br><span class="line">            &#125;</span><br><span class="line">            push(&amp;operators, ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(operators)) &#123;</span><br><span class="line">        prefix[j++] = pop(&amp;operators);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prefix[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    _strrev(prefix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> infix[MAX_SIZE], prefix[MAX_SIZE];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入中缀表达式[不要留空格] (输入q退出): &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, infix);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(infix, <span class="string">&quot;q&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;退出计算器。\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        infixToPrefix(infix, prefix);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;前缀表达式: %s\n&quot;</span>, prefix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言,C++,数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DiffusionModel原理学习笔记</title>
      <link href="/posts/aa051d3a/"/>
      <url>/posts/aa051d3a/</url>
      
        <content type="html"><![CDATA[<p>去噪自动编码器</p><p>Diffusion model 是一种深度生成模型（无监督生成模型），它属于：<br />机器学习 -&gt; 无监督学习 -&gt; 概率模型 -&gt; 生成模型 <span id="more"></span></p><figure><img src="DM归属.png" alt="分类图" /><figcaption aria-hidden="true">分类图</figcaption></figure><p>概率模型是为了求得数据的后验概率<span class="math inline">\(P(Y|X)\)</span>或者联合验概率<span class="math inline">\(P(X,Y)\)</span><br />对于监督学习而言，判别模型主要是求后验概率，也就是通过输入的特征X去求标签信息Y。生成模型主要是未了求得联合概率，对于X，求出X与不同标签之间的联合概率，取最大的那个标签作为预测结果。</p><h3 id="隐空间和隐变量-latent-spacehidden-variables">隐空间和隐变量 (latent space/hidden variables)</h3><figure><img src="隐变量.png" alt="间接" /><figcaption aria-hidden="true">间接</figcaption></figure><p>a 直接到 b 比较困难，所以可以通过间接变量 c 来实现。</p><h3 id="基本算法">基本算法</h3><figure><img src="autoencoder.png" alt="autoencoder" /><figcaption aria-hidden="true">autoencoder</figcaption></figure><figure><img src="diffusion.png" alt="diffusion" /><figcaption aria-hidden="true">diffusion</figcaption></figure><p><span class="math inline">\(X_0\)</span> 是原始的输入图像，<span class="math inline">\(X_T\)</span> 是 total noise</p><p>在从右往左的过程中的每一步都会给样本增加一个小的满足高斯分布的噪声，整个过程为一个一阶马尔可夫过程，这是一个正向扩散过程，如果把它反过来，也就是从左往右看上图，那么就是一个反向扩散过程。</p><p>正向分布的时候添加的噪声都是符合高斯分布的，那么这些噪声合并后仍然是处于高斯分布的。但是当我们逆推这一过程的时候，除非我们拥有整体数据集合，不然我们是没有办法直接求解的，通常来说我们会训练一个模型 <span class="math inline">\(p_θ\)</span>来预测反向扩散过程的条件概率 <span class="math inline">\(q(x_{t-1}|x_t)\)</span>. 通过这个模型，我们输入 <span class="math inline">\(X_t\)</span> 和 <span class="math inline">\(t\)</span> 可以预测出 <span class="math inline">\(X_{t-1}\)</span> 的条件概率分布(如果正向扩散每步增加的噪声够小,它可以被视为高斯分布)的均值 <span class="math inline">\(μ_θ(x_t,t)\)</span>和方差 <span class="math inline">\(\sum_θ(x_t,t)\)</span>，基于预测值,我们可以从 <span class="math inline">\(x_{t-1}\)</span>的高斯分布 <span class="math inline">\(p_θ(x_{t-1}|x_t)\)</span>中采样出 <span class="math inline">\(X_{t-1}\)</span> 的值，从而得到 <span class="math inline">\(x_{t-1}\)</span> 的一个可能的取值,后面以此类推,我们就可以逐步去噪生成一张图片.</p><p>这个模型在 DDPM 中是 U-net 网络 PixelCNN++.</p><p>简单来说,这里的反向传播,或者说是 decoder,又或者说是生成器,其实就是在简单的拟合正向部分的逆过程的每一小步.</p><p>当然,训练我们的噪声预测器需要大量的数据集,不过这仍然不值得担心,因为正向传播的每一步我们都是在给图像逐步加噪,我们可以轻松地获取从0到T每个过程的所有样本. <img src="UNet.png" alt="UNet" /> 上面这张图非常清晰的展现了 U-net 的训练.</p>]]></content>
      
      
      
        <tags>
            
            <tag> DiffusionModel, ML, AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有限状态机的Unity_C#实现</title>
      <link href="/posts/1f1f5f6a/"/>
      <url>/posts/1f1f5f6a/</url>
      
        <content type="html"><![CDATA[<p>今天读了 <code>Game Programming Patterns</code> 的 <code>State</code> 章节.深感改模式对我目前代码优化的帮助巨大.于是决定写个demo来实现一下</p><span id="more"></span><p>文章中是用<code>C++</code>作为描述语言的,而对于使用 Unity 引擎, C# 语言的我来说,需要做一些适应性的修改.</p><p>这个<code>demo</code>主要涉及的是玩家控制</p><h2 id="fsm有限状态机">FSM(有限状态机)</h2><h3 id="为什么要使用有限状态机">为什么要使用有限状态机</h3><p>在回答这个问题之前,不妨想一想你自己之前是如何实现玩家控制的,就以跳跃为例</p><p>或许你会这样写</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Jump</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//跳跃</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然这个函数有个大问题,只要按下空格键,你就会一直往上跳,最后你的角色就飞了起来,这当然不是你想要的.最简单的修补办法是给他添加上一个<code>isJumping</code>或者<code>isOnGround</code>的布尔判断</p><p>再然后,你又想给你的角色添加一个冲刺的功能,如果你什么也不做,神奇的玩家或许会对冲刺中按下跳跃键后发生的事情感到啼笑皆非,这时候你又需要添加一个<code>isDashing</code>的布尔判断.然而实际开发中的需求可不会像上面的例子一样简单,你也不想你的代码里全是各种<code>if else</code>吧.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Game Programming Patterns_Prototype原型模式</title>
      <link href="/posts/cb3ccb51/"/>
      <url>/posts/cb3ccb51/</url>
      
        <content type="html"><![CDATA[<p>如果给你一个需求<br />&gt;你需要设计出一群不同种类的可怖的怪物,让他们在英雄前进的道路上阻挡他们</p><p>你会则表明怎么做呢? 或许当你刚接触游戏开发的时候,你会这样做</p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Monster</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 代码……</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ghost</span> : <span class="keyword">public</span> Monster &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demon</span> : <span class="keyword">public</span> Monster &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sorcerer</span> : <span class="keyword">public</span> Monster &#123;&#125;;</span><br></pre></td></tr></table></figure><p>每一种怪物都有自己的类.为了让这些家伙降临到这个世界,或许你还会给他们精心设计独属于他们自己的生产者类(spawner).事实上,这是一种相当暴力的解决方案,每个怪物都有自己的生产者类,这构成了一种平行的类的结构.</p><figure><img src="image.png" alt="Alt text" /><figcaption aria-hidden="true">Alt text</figcaption></figure><blockquote><p>图上这个带尾巴的小三角形是继承的意思</p></blockquote><p>下面是该方案一种实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spawner</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Spawner</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Monster* <span class="title">spawnMonster</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GhostSpawner</span> : <span class="keyword">public</span> Spawner</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Monster* <span class="title">spawnMonster</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Ghost</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemonSpawner</span> : <span class="keyword">public</span> Spawner</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Monster* <span class="title">spawnMonster</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Demon</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  You get the idea...</span></span><br></pre></td></tr></table></figure><p>如果你和你的学长/前辈一起共事,那么作为经验丰富的代码世界的造物主,他肯定会想方设法阻止你 <code>"这种代码很难维护.""如果有策划设计了一千种怪物,那么你要专门为这个项目撰写一本字典吗?"</code>显然,以这种方法创世,第七天肯定没法放假.</p><h2 id="一个更好的方法">一个更好的方法</h2><p>前人给出了一个比上面的实现更具性价比的解决方案 <code>设计模式</code>.</p><blockquote><p>关键思路是<code>一个对象可以产出与它自己相近的对象</code>。 如果你有一个恶灵，你可以制造更多恶灵。 如果你有一个恶魔，你可以制造其他恶魔。 任何怪物都可以被视为<code>原型</code>怪物，产出其他版本的自己。</p></blockquote><p>为了实现这个功能,我们可以给基类<code>Monster</code>添加一个抽象方法<code>clone</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Monster</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Monster</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Monster* <span class="title">clone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Other stuff...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后,我们可以让每个怪物都实现这个方法,并且返回一个与它自己的类和状态都完全一样的新对象.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ghost</span> : <span class="keyword">public</span> Monster &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Ghost</span>(<span class="type">int</span> health, <span class="type">int</span> speed)</span><br><span class="line">  : <span class="built_in">health_</span>(health),</span><br><span class="line">    <span class="built_in">speed_</span>(speed)</span><br><span class="line">  &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Monster* <span class="title">clone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Ghost</span>(health_, speed_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> health_;</span><br><span class="line">  <span class="type">int</span> speed_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在,我们不再需要再给每个怪物都添加上他们自己的生产者类了,我们大可以写一个<code>Spawner</code>类,它可以接受一个<code>Monster</code>对象,并且使用<code>clone</code>方法来产生新的怪物.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Spawner</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Spawner</span>(Monster* prototype)</span><br><span class="line">  : <span class="built_in">prototype_</span>(prototype)</span><br><span class="line">  &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Monster* <span class="title">spawnMonster</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prototype_-&gt;<span class="built_in">clone</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Monster* prototype_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>重要的是</strong>,或者说他和抽离内部实现的接口思想有很大不同的一点是,他内部是存有<code>template</code>的,模板是怎样的,克隆出来的怪物就是怎样的.</p><figure><img src="image-1.png" alt="Alt text" /><figcaption aria-hidden="true">Alt text</figcaption></figure><p>书上举了一个很直观的例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Monster* ghostPrototype = <span class="keyword">new</span> <span class="built_in">Ghost</span>(<span class="number">15</span>, <span class="number">3</span>);</span><br><span class="line">Spawner* ghostSpawner = <span class="keyword">new</span> <span class="built_in">Spawner</span>(ghostPrototype);</span><br></pre></td></tr></table></figure><p>这段代码创建了一个恶灵的原型实例,然后创建了这个实例的生产者. 巧妙的是,我们只需要更改这个模板鬼魂的状态,就可以创建出各种各样的鬼魂.</p><p>看起来一切都搞定了</p><p>吗?</p><p>不说每个<code>clone</code>方法仍然需要我们自己去实现,这些工作量不比给每个怪物都写一个生产者类少多少,也不说实际程序开发中会遇到的不同的语义漏洞</p><blockquote><p>做深层拷贝还是浅层拷贝呢？换言之，如果恶魔拿着叉子，克隆恶魔也要克隆叉子吗？</p></blockquote><p>就说这种方法的前提就很难达成,在现代的游戏引擎上工作,还有谁会给每个怪物都设计一个自己的类?</p><h2 id="生产函数">生产函数</h2><p>哪怕我们必须要为每个怪物都添加上一个独立的类,那么给给每个怪物都添加上一个分离的生产者类也并非上上之选,我们可以使用一个更加简单的方法,那就是使用一个生产函数.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Monster* <span class="title">spawnGhost</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Ghost</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面给出新方法的实现,可以看看这和上面的方法有什么区别?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Monster* (*SpawnCallback)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spawner</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Spawner</span>(SpawnCallback spawn)</span><br><span class="line">  : <span class="built_in">spawn_</span>(spawn)</span><br><span class="line">  &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Monster* <span class="title">spawnMonster</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">spawn_</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  SpawnCallback spawn_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>很显然,函数指针嘛,生产者类不需要再存储一个怪物对象了,它只需要储存一个函数指针就可以做到和之前一样的事情了.后面是构筑生产者的代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spawner* ghostSpawner = <span class="keyword">new</span> <span class="built_in">Spawner</span>(spawnGhost);</span><br></pre></td></tr></table></figure><h2 id="模板">模板</h2><p>模板没什么好说的,这是一个C++程序员必须掌握的一个编程方法.在另一些语言中其思想被推广为泛型<strong>T</strong></p><p>模板和许多高级语言中的继承或者接口不一样,这些机制大多是运行时才确定的(比如成员函数只有在运行时才知道调用哪个),所以被叫做<strong>运行时多态</strong>,而模板则是一种<strong>编译时多态</strong>,编译器在编译的时候就知道调用哪个函数了.代价是目标代码会多一点.</p><p>那么事情就很清楚了,如果我们把生产者类当作模板中的<code>T</code>(类型参数),我们就能实现这样一段代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Spawner</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Spawner</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Monster* <span class="title">spawnMonster</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpawnerFor</span> : <span class="keyword">public</span> Spawner</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Monster* <span class="title">spawnMonster</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">T</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以这样使用它</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spawner* ghostSpawner = <span class="keyword">new</span> <span class="built_in">SpawnerFor</span>&lt;Ghost&gt;();</span><br></pre></td></tr></table></figure><h2 id="第一公民类型">第一公民类型</h2><p>在C++中，类型不是第一公民,所以我们需要进行一些小改动,不过在此之前,我们需要讨论一下什么是第一公民/第二公民</p><p>第一公民类型是指可以被当作参数传递,可以被当作返回值返回,可以被当作容器的元素的类型的类型.比如说,在C++中,函数不是第一公民类型,所以我们不能把函数当作参数传递给另一个函数,也不能把函数当作返回值返回,也不能把函数当作容器的元素的类型.</p><p>我们熟悉的 char, int, float等都是第一公民类型,不能满足的上述条件的,就是第二公民了.</p>]]></content>
      
      
      <categories>
          
          <category> Game Programming Patterns </category>
          
          <category> Design Patterns Revisited </category>
          
          <category> Prototype(原型模式) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏设计模式 </tag>
            
            <tag> 原型模式 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单的无限地图实现</title>
      <link href="/posts/c8583f8a/"/>
      <url>/posts/c8583f8a/</url>
      
        <content type="html"><![CDATA[<p>突然想写一个类吸血鬼幸存者的 <code>demo</code>, 想了一下无限地图挺重要的,于是就设计了一个简单的无限地图实现,感觉性能一般般,过两天找一下类似的代码比对一下性能,这个功能实现还是很简单的,今天记录一下.</p><span id="more"></span><h2 id="数学原理">数学原理</h2><p>呢讲到无限地图算法,首先就要考虑他的数学原理.我实现的这个方法也是目前应用比较广,实现起来也是最简单的那种了.</p><figure><img src="image.png" alt="Alt text" /><figcaption aria-hidden="true">Alt text</figcaption></figure><p>在这张图上,我们给出了原点<span class="math inline">\(O\)</span>,橙色框所框中的是以玩家出生点为原点渲染出来的第一块地图,我们可以记为<span class="math inline">\(M(0,0)\)</span>,图中还给出了框的长和宽<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>,这里的红框和绿框的大小是相同的,他的的焦点,也是相交的几条边的中点.</p><p>玩家的视野范围,即摄像机所捕获的范围是不大于橙色框的 我们通过矩形的四个点就可以确定所需要渲染出的地图区块,比如说当玩家在所示绿框中活动的时候,我们就需要渲染出<span class="math inline">\(M(0,0),M(1,0),M(1,1),M(0,1)\)</span>这四块地图</p><p>整张地图所需要记录的只是以<span class="math inline">\(X\)</span>为X轴上的单位长度和以<span class="math inline">\(Y\)</span>为Y轴上的单位长度组成的点阵图,当玩家处于任意四个点组成的举行范围内时,我们只需要把以这四个点为中点,以<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>为长和宽的标准地图就可以了.</p><h2 id="代码实现">代码实现</h2><p>首先我们定义一个结构体来储存我们的地图信息</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 地图数据</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> MapData</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> MapUnit map;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个结构体中有三个成员,<code>map</code>是一个<code>MapUnit</code>类型的变量,<code>X</code>和<code>Y</code>分别是以<code>X</code>和<code>Y</code>为单位长度的坐标.</p><p>下面放一下<code>MapUnit</code>的定义</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MapUnit</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> MapData _myData;</span><br><span class="line">    <span class="keyword">private</span> MapUnit _mapUnit;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MapManager.Instance.mapList.Add(_myData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (MapManager.Instance.checkPlayerPosition(transform))</span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MapData <span class="title">GetMyData</span>(<span class="params"><span class="built_in">int</span> _X, <span class="built_in">int</span> _Y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _myData = <span class="keyword">new</span> MapData()</span><br><span class="line">        &#123;</span><br><span class="line">            map = _mapUnit,</span><br><span class="line">            X = _X,</span><br><span class="line">            Y = _Y</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> _myData;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MapManager.Instance.mapList.Remove(_myData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也很简单,这个类有两个成员字段,分别存贮自己的地图数据和自己的脚本,他还有一个方法,用来获取自己的地图数据. 在<code>Start</code>方法中,我们把自己的地图数据添加到<code>MapManager</code>的<code>mapList</code>中,在<code>Update</code>方法中,地图会自行检测自己是否在玩家的视野范围内,如果是,就销毁自己,在<code>OnDestroy</code>方法中,他会把自己的地图数据从<code>MapManager</code>的<code>mapList</code>中移除.</p><p>最后来看一下地图管理类的实现</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> Unity.Mathematics;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MapManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MapManager Instance;</span><br><span class="line">    <span class="keyword">private</span> GameObject _player;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> _playerLive;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _mapX;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _mapY;</span><br><span class="line">    <span class="keyword">public</span> GameObject mapPrefabs;</span><br><span class="line">    <span class="keyword">public</span> Transform grid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;MapData&gt; mapList = <span class="keyword">new</span> List&lt;MapData&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Instance = <span class="keyword">this</span>;</span><br><span class="line">        _mapX = <span class="number">18</span>;</span><br><span class="line">        _mapY = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_playerLive)</span><br><span class="line">        &#123;</span><br><span class="line">            ConrtolAutoMap();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 获取玩家对象</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;player&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetPlayer</span>(<span class="params">GameObject player</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _player = player;</span><br><span class="line">        _playerLive = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 自动检查玩家身边的地图,并自动加载未加载地图</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConrtolAutoMap</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> x = _player.transform.position.x;</span><br><span class="line">        <span class="keyword">var</span> y = _player.transform.position.y;</span><br><span class="line">        <span class="built_in">int</span> X = (<span class="built_in">int</span>)x / _mapX;</span><br><span class="line">        <span class="built_in">int</span> Y = (<span class="built_in">int</span>)y / _mapY;</span><br><span class="line">        <span class="built_in">int</span> XX = x &gt; <span class="number">0</span> ? X + <span class="number">1</span> : X - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> YY = y &gt; <span class="number">0</span> ? Y + <span class="number">1</span> : Y - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!CheckMapLive(X, Y))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> newMap = Instantiate(mapPrefabs, <span class="keyword">new</span> Vector3(X * _mapX, Y * _mapY), quaternion.identity,grid);</span><br><span class="line">            newMap.GetComponent&lt;MapUnit&gt;().GetMyData(X, Y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!CheckMapLive(XX, Y))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> newMap = Instantiate(mapPrefabs, <span class="keyword">new</span> Vector3((XX) * _mapX, Y * _mapY), quaternion.identity,grid);</span><br><span class="line">            newMap.GetComponent&lt;MapUnit&gt;().GetMyData(XX, Y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!CheckMapLive(X, YY))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> newMap = Instantiate(mapPrefabs, <span class="keyword">new</span> Vector3(X * _mapX, (YY) * _mapY), quaternion.identity,grid);</span><br><span class="line">            newMap.GetComponent&lt;MapUnit&gt;().GetMyData(X, YY);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!CheckMapLive(XX, YY))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> newMap = Instantiate(mapPrefabs, <span class="keyword">new</span> Vector3((XX) * _mapX, (YY) * _mapY), quaternion.identity,grid);</span><br><span class="line">            newMap.GetComponent&lt;MapUnit&gt;().GetMyData(XX, YY);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 检查目标地点是否存在地图单元</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;x_target&quot;&gt;</span>坐标x<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;y_target&quot;&gt;</span>坐标y<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>存在返回true<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">CheckMapLive</span>(<span class="params"><span class="built_in">int</span> x_target, <span class="built_in">int</span> y_target</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> target =</span><br><span class="line">            <span class="keyword">from</span> m <span class="keyword">in</span> mapList</span><br><span class="line">            <span class="keyword">where</span> m.X == x_target &amp;&amp; m.Y == y_target</span><br><span class="line">            <span class="keyword">select</span> m.map;</span><br><span class="line">        <span class="keyword">return</span> target.Any();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 检查地图块是否已经超出了玩家的区块范围</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;t&quot;&gt;</span>地图的Transform<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>如果地图快已经超出了玩家的区块范围,则返回true<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">checkPlayerPosition</span>(<span class="params">Transform t</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> math.abs(t.position.x - _player.transform.position.x) &gt; _mapX ||</span><br><span class="line">               math.abs(t.position.y - _player.transform.position.y) &gt; _mapY</span><br><span class="line">            ? <span class="literal">true</span></span><br><span class="line">            : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        mapList.Clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然,写的有点蠢,不过好歹能用,生成不同地图的方法也很简单,多做几个预制体,生成的时候写一个随机方法就可以了.</p><p>过两天把这个优化一下.</p><hr />]]></content>
      
      
      <categories>
          
          <category> 记录向 </category>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> C# </tag>
            
            <tag> 无限地图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单的事件中心</title>
      <link href="/posts/63fcc5fa/"/>
      <url>/posts/63fcc5fa/</url>
      
        <content type="html"><![CDATA[<p>下面给出一个简单的事件中心的实现</p><span id="more"></span><p>首先是事件类型</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 事件类型</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> EventType</span><br><span class="line">&#123;</span><br><span class="line">    Speed,Frozen,Pause,UnPause,Dash,GameOver</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后是事件中心</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 事件中心，负责注册、发布事件</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventCenter</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EventCenter _instance = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EventCenter Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                _instance = <span class="keyword">new</span> EventCenter();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> _instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Dictionary&lt;EventType, List&lt;Action&gt;&gt; eventDict = <span class="keyword">new</span> Dictionary&lt;EventType, List&lt;Action&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EventCenter</span>()</span> &#123; &#125;<span class="comment">//私有构造函数，防止外部实例化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 订阅事件</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventType&quot;&gt;</span>事件类型<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventHandler&quot;&gt;</span>事件处理方法<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SubscribeEvent</span>(<span class="params">EventType eventType, Action eventHandler</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventDict.ContainsKey(eventType))</span><br><span class="line">        &#123;</span><br><span class="line">            eventDict[eventType].Add(eventHandler);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;Action&gt; list = <span class="keyword">new</span> List&lt;Action&gt;();</span><br><span class="line">            list.Add(eventHandler);</span><br><span class="line">            eventDict.Add(eventType, list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 取消订阅事件</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventType&quot;&gt;</span>事件类型<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventHandler&quot;&gt;</span>事件处理方法<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveSubscribedEvent</span>(<span class="params">EventType eventType, Action eventHandler</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(eventDict.ContainsKey(eventType))</span><br><span class="line">        &#123;</span><br><span class="line">            eventDict[eventType].Remove(eventHandler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 发布事件</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventType&quot;&gt;</span>事件类型<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PublishEvent</span>(<span class="params">EventType eventType</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventDict.ContainsKey(eventType))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (Action handler <span class="keyword">in</span> eventDict[eventType])</span><br><span class="line">            &#123;</span><br><span class="line">                handler?.Invoke();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr />]]></content>
      
      
      <categories>
          
          <category> 代码库 </category>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事件,Unity,C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity中空判断与Destroy实现</title>
      <link href="/posts/da6ffe54/"/>
      <url>/posts/da6ffe54/</url>
      
        <content type="html"><![CDATA[<p>以往我在做空判断的时候，都是这样写的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (gameobject != <span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p>或者是</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (gameobject == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>最近换了Rider， 他给我来了句提示<code>与 'null' 的比较开销较大</code>,奇奇怪怪，我换成了 <code>if(gameobject)</code> 就没有这些提示了，那么这两种写法到底有什么区别呢？ <span id="more"></span></p><p>要讨论这两个问题，还真不是很简单，我们首先要了解<code>Object</code>,这里的<code>Object</code>是<code>System.Object</code>，也是<code>UnityEngine.Object</code>。</p><p><code>System.Object</code>大家都很好理解，我们来看看<code>UnityEngine.Object</code>吧。</p><p><code>UnityEngine.Object</code>继承自<code>system.Object</code>，是<code>Unity</code>所涉及所有物体的基类。</p><p>但是他们也有区别，不得不谈的就是<code>销毁</code>和<code>空判断</code>。</p><blockquote><p>这是最常见的问题，在UnityEngine中我们销毁一个对象时，使用“==”操作符与null比较结果为true，但是可以发现，我们还是可以引用这个变量，这主要是由于UnityEngine的==操作符在销毁后即将Object置位null，但是对象本身需要被GC后才能达到真正意义上的销毁，也就是System.Object中的null；</p></blockquote><blockquote><p>这里涉及到了托管的问题，如果不了解也不要紧，我可以告诉你从 UnityEngine.Object 继承的对象，包括托管和非托管两部分，当调用 Destroy 时，销毁的只是非托管部分，托管部分只能通过 C# 的垃圾回收器进行回收。</p></blockquote><p>什么意思呢，我们直接来看<code>Destroy</code>会更清晰一点</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span>   <span class="doctag">&lt;para&gt;</span>Removes a GameObject, component or asset.<span class="doctag">&lt;/para&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;obj&quot;&gt;</span>The object to destroy.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;t&quot;&gt;</span>The optional amount of time to delay before destroying the object.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">[<span class="meta">NativeMethod(Name = <span class="string">&quot;Scripting::DestroyObjectFromScripting&quot;</span>, IsFreeFunction = true, ThrowsException = true)</span>]</span><br><span class="line">[<span class="meta">MethodImpl(MethodImplOptions.InternalCall)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Destroy</span>(<span class="params">Object obj, [DefaultValue(<span class="string">&quot;0.0F&quot;</span></span>)] <span class="built_in">float</span> t)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span>   <span class="doctag">&lt;para&gt;</span>Removes a GameObject, component or asset.<span class="doctag">&lt;/para&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;obj&quot;&gt;</span>The object to destroy.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;t&quot;&gt;</span>The optional amount of time to delay before destroying the object.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">[<span class="meta">ExcludeFromDocs</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Destroy</span>(<span class="params">Object obj</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">float</span> t = <span class="number">0.0f</span>;</span><br><span class="line">  Object.Destroy(obj, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Unity 自己的文档讲的很清楚了， 我们来看“了解托管堆”这一节</p><blockquote><p>垃圾回收器定期运行（__注意：__具体运行时间视平台而定）。这时将扫描堆上的所有对象，将任何不再引用的对象标记为删除。然后会删除未引用的对象，从而释放内存。</p></blockquote><p>Unity 用了一种很讨巧的方法，他们把 <code>destroy</code> 掉的内存标记为 <code>'null'</code>，事实上，这些内存并没有被回收，而是在等待 C# 的 <code>GC</code> 把他们回收掉。</p><p>我们再来看看<code>Unity</code>对于<code>==</code>的重载</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="keyword">operator</span> ==(Object x, Object y) =&gt; Object.CompareBaseObjects(x, y);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="keyword">operator</span> !=(Object x, Object y) =&gt; !Object.CompareBaseObjects(x, y);</span><br></pre></td></tr></table></figure><p>还有其对布尔类型的重载</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">bool</span>(<span class="params">Object exists</span>)</span> =&gt; !Object.CompareBaseObjects(exists, (Object) <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>可以发现<code>CompareBaseObjects</code>方法的实现也是绕不开的，我们来看看</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">CompareBaseObjects</span>(<span class="params">Object lhs, Object rhs</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">bool</span> flag1 = (<span class="built_in">object</span>) lhs == <span class="literal">null</span>;</span><br><span class="line">      <span class="built_in">bool</span> flag2 = (<span class="built_in">object</span>) rhs == <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (flag2 &amp; flag1)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (flag2)</span><br><span class="line">        <span class="keyword">return</span> !Object.IsNativeObjectAlive(lhs);</span><br><span class="line">      <span class="keyword">return</span> flag1 ? !Object.IsNativeObjectAlive(rhs) : lhs.m_InstanceID == rhs.m_InstanceID;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看到这里，其实我们已经对之前的问题有了回答了</p><p><code>UnityEngine.Object</code>中的布尔类型重载和<code>==</code>运算符重载，他们都是通过<code>CompareBaseObjects</code>来实现的 他们俩本质上都是采用了 <code>Unity</code> 层面上的检查。</p><p>对于这点，我们也可以证明</p><p>请看方法<code>IsNativeObjectAlive</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsNativeObjectAlive</span>(<span class="params">Object o</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> (o.GetCachedPtr() != IntPtr.Zero)</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     <span class="keyword">return</span> !(o <span class="keyword">is</span> MonoBehaviour) &amp;&amp; !(o <span class="keyword">is</span> ScriptableObject) &amp;&amp; Object.DoesObjectWithInstanceIDExist(o.GetInstanceID());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>Unity</code> 先调用<code>o.GetCachedPtr()</code> 方法检查目标对象的本机指针是否还存在, 要知道 <code>IntPtr</code> 并非 <code>Unity</code> 自己鼓捣出来的玩意， 他是<code>.NET Framework</code>和 <code>.NET Core</code>中的一个特殊的结构体，用于表示目标对象的本地指针. 如果本地指针不存在，那么就会调用<code>Object.DoesObjectWithInstanceIDExist</code>方法，这个方法会检查目标对象的实例ID是否存在,如果存在具有给定实例ID的对象，则返回 true.</p><p>通过这种方法实现的空判断,实质上开销是特别大的,有些人会使用<code>System.Object.ReferenceEquals</code>,比如这样</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(System.Object.ReferenceEquals(gameobject, <span class="literal">null</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// TODO something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做,在性能上确实是有很大提升的,但是读到这里的朋友估计已经猜到我要讲什么了. 在执行<code>destroy</code>方法后,目标对象实质上并没有被回收,他只是被打上了一个<code>'tag'</code>的标签,而变量仍然在指向着堆对象.为什么<code>==</code>可以呢,因为<code>Unity</code>已经把他重载了.</p><hr />]]></content>
      
      
      <categories>
          
          <category> 记录向 </category>
          
          <category> Unity </category>
          
          <category> GC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GC,Unity,内存,C#,空引用判断,Destroy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity文件读写方法之StreamingAssets</title>
      <link href="/posts/fc36bd86/"/>
      <url>/posts/fc36bd86/</url>
      
        <content type="html"><![CDATA[<h2 id="streamingassets-文件夹">StreamingAssets 文件夹</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>XML介绍和增删改查</title>
      <link href="/posts/eb414ab7/"/>
      <url>/posts/eb414ab7/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-xml">什么是 XML</h2><p>XML 指可扩展标记语言（eXtensible Markup Language）。</p><p>XML 被设计用来传输和存储数据 -&gt; 仅关注数据本身</p><p>XML 被设计为具有自我描述性。 <span id="more"></span> ## XML 的基本语法</p><h3 id="xml-简单的使用案例">XML 简单的使用案例</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget me this weekend!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="xml-的树结构">XML 的树结构</h3><p>我们这里给出实例和图片的对应关系</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;COOKING&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Everyday Italian<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>Giada De Laurentiis<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>30.00<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;CHILDREN&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Harry Potter<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>J K. Rowling<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>29.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;WEB&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Learning XML<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>Erik T. Ray<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">year</span>&gt;</span>2003<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>39.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></span><br></pre></td></tr></table></figure><figure><img src="XML介绍和增删改查\nodetree.gif" alt="XML 树结构" /><figcaption aria-hidden="true">XML 树结构</figcaption></figure><h3 id="xml-文档的声明可选的">XML 文档的声明(可选的)</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br></pre></td></tr></table></figure><p>声明不是 xml 文档本身的一部分</p><h3 id="xml-注意事项">XML 注意事项</h3><ul><li>XML 标签对大小写敏感</li><li>XML 必须正确地嵌套</li><li>XML 文档必须有根元素</li><li>XML 属性值必须加引号</li><li>使用预定义的实体引用来代替 "&lt;" 和 "&amp;" 等特殊字符</li></ul><table><tbody><tr class="odd"><td><code>&amp;lt;</code></td><td>&lt;</td><td>less than</td></tr><tr class="even"><td><code>&amp;gt;</code></td><td>&gt;</td><td>greater than</td></tr><tr class="odd"><td><code>&amp;amp;</code></td><td>&amp;</td><td>ampersand</td></tr><tr class="even"><td><code>&amp;apos;</code></td><td>'</td><td>apostrophe</td></tr><tr class="odd"><td><code>&amp;quot;</code></td><td>"</td><td>quotation mark</td></tr></tbody></table><ul><li>XML 中的注释从 <!-- 开始，--> 结束</li><li>XML 中的特殊字符必须被转义</li><li>XML 中的空格会被保留</li><li>XML 以 LF 存储换行</li><li>XML 元素名称可以包含字母、数字以及其他的字符</li><li>XML 元素名称不能以数字或者标点符号开始</li><li>XML 元素名称不能以字母 xml（或者 XML、Xml 等等）开始</li><li>XML 元素名称不能包含空格</li></ul><h3 id="xml-属性">XML 属性</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;CHILDREN&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>属性提供有关元素的额外信息</li><li>属性始终在元素的开始标签中规定</li><li>属性总是以名称/值的形式出现，比如：name="value"</li><li>属性值必须被引号包围，单引号和双引号都可以使用</li><li>属性值必须是合法的 XML 数据类型</li><li>属性不能包含多个值，不能折行</li></ul><h2 id="unity-中-xml-的增删改查">Unity 中 XML 的增删改查</h2><h3 id="新建文件">新建文件</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Xml;</span><br><span class="line">...</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">CreateXML</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> localPath = UnityEngine.Application.dataPath + <span class="string">&quot;/Resources/Data/&quot;</span> + <span class="string">&quot;DeckData.xml&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!File.Exists(localPath))</span><br><span class="line">        &#123;</span><br><span class="line">            XmlDocument xml = <span class="keyword">new</span> XmlDocument();</span><br><span class="line">            XmlDeclaration xmldecl = xml.CreateXmlDeclaration(<span class="string">&quot;1.0&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>, <span class="string">&quot;&quot;</span>);<span class="comment">//设置xml文件编码格式为UTF-8</span></span><br><span class="line">            XmlElement root = xml.CreateElement(<span class="string">&quot;Data&quot;</span>);<span class="comment">//创建根节点</span></span><br><span class="line">            xml.AppendChild(root);</span><br><span class="line">            xml.Save(localPath);<span class="comment">//保存xml到路径位置</span></span><br><span class="line">            Debug.Log(<span class="string">&quot;创建XML成功!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="写入文件">写入文件</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WriteDeckDataToXML</span>(<span class="params"><span class="built_in">string</span> deckName,Dictionary&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt; deckCards</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">var</span> localPath = UnityEngine.Application.dataPath + <span class="string">&quot;/Resources/Data/&quot;</span> + <span class="string">&quot;DeckData.xml&quot;</span>;</span><br><span class="line">       <span class="keyword">if</span> (File.Exists(localPath))</span><br><span class="line">       &#123;</span><br><span class="line">           XmlDocument xml = <span class="keyword">new</span> XmlDocument();</span><br><span class="line">           xml.Load(localPath);<span class="comment">//加载xml文件</span></span><br><span class="line">           XmlNode root = xml.SelectSingleNode(<span class="string">&quot;Data&quot;</span>);<span class="comment">//获取根节点</span></span><br><span class="line">           <span class="keyword">if</span>(root.HasChildNodes)<span class="comment">//如果根节点有子节点(即有卡组数据</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">foreach</span> (XmlNode node <span class="keyword">in</span> root.ChildNodes)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">if</span> (node.Attributes[<span class="string">&quot;name&quot;</span>].Value == deckName)</span><br><span class="line">                   &#123;</span><br><span class="line">                       root.RemoveChild(node);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           XmlElement deck = xml.CreateElement(<span class="string">&quot;Deck&quot;</span>);<span class="comment">//创建子节点</span></span><br><span class="line">           deck.SetAttribute(<span class="string">&quot;name&quot;</span>, deckName);<span class="comment">//设置属性</span></span><br><span class="line">           <span class="keyword">foreach</span> (<span class="keyword">var</span> card <span class="keyword">in</span> deckCards)</span><br><span class="line">           &#123;</span><br><span class="line">               XmlElement cardElement = xml.CreateElement(<span class="string">&quot;Card&quot;</span>);</span><br><span class="line">               cardElement.SetAttribute(<span class="string">&quot;id&quot;</span>, card.Key.ToString());</span><br><span class="line">               cardElement.SetAttribute(<span class="string">&quot;count&quot;</span>, card.Value.ToString());</span><br><span class="line">               deck.AppendChild(cardElement);</span><br><span class="line">           &#125;</span><br><span class="line">           root.AppendChild(deck);</span><br><span class="line">           xml.Save(localPath);<span class="comment">//保存xml到路径位置</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="读取文件">读取文件</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReadDeckDataFromXML</span>(<span class="params"><span class="built_in">string</span> deckName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> card <span class="keyword">in</span> deckCards)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;card.Key: &quot;</span> + card.Key + <span class="string">&quot;card.Value: &quot;</span> + card.Value);</span><br><span class="line">        &#125;</span><br><span class="line">        Debug.Log(<span class="string">&quot;开始读取&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> localPath = UnityEngine.Application.dataPath + <span class="string">&quot;/Resources/Data/&quot;</span> + <span class="string">&quot;DeckData.xml&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (File.Exists(localPath))</span><br><span class="line">        &#123;</span><br><span class="line">            XmlDocument xml = <span class="keyword">new</span> XmlDocument();</span><br><span class="line">            xml.Load(localPath);<span class="comment">//加载xml文件</span></span><br><span class="line">            XmlNode root = xml.SelectSingleNode(<span class="string">&quot;Data&quot;</span>);<span class="comment">//获取根节点</span></span><br><span class="line">            <span class="keyword">if</span> (root.HasChildNodes)<span class="comment">//如果根节点有子节点(即有卡组数据</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">foreach</span> (XmlNode node <span class="keyword">in</span> root.ChildNodes)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (node.Attributes[<span class="string">&quot;name&quot;</span>].Value == deckName)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">foreach</span> (XmlNode card <span class="keyword">in</span> node.ChildNodes)</span><br><span class="line">                        &#123;</span><br><span class="line">                            deckCards.Add(<span class="built_in">int</span>.Parse(card.Attributes[<span class="string">&quot;id&quot;</span>].Value), <span class="built_in">int</span>.Parse(card.Attributes[<span class="string">&quot;count&quot;</span>].Value));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> card <span class="keyword">in</span> deckCards)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;card.Key: &quot;</span> + card.Key + <span class="string">&quot;card.Value: &quot;</span> + card.Value);</span><br><span class="line">        &#125;</span><br><span class="line">        Debug.Log(<span class="string">&quot;结束读取&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程向 </category>
          
          <category> 游戏开发 </category>
          
          <category> Unity </category>
          
          <category> 集换式卡牌游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 卡牌游戏 </tag>
            
            <tag> Unity </tag>
            
            <tag> 教程，XML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初读Snapshot Compressive Imaging: Principle, Implementation, Theory, Algorithms and Applications</title>
      <link href="/posts/bcef6785/"/>
      <url>/posts/bcef6785/</url>
      
        <content type="html"><![CDATA[<p>快照压缩成像：原理、实现、理论、算法和应用</p><p>使用二维传感器捕获快照测量中的高维数据</p><h2 id="什么是-snapshot-compressive-imaging-快照压缩成像">什么是 Snapshot Compressive Imaging (快照压缩成像)？</h2><h3 id="二维检测和高维以3d为例检测是什么">二维检测和高维(以3D为例)检测是什么？</h3><figure><img src="p1.jpg" alt="图一" /><figcaption aria-hidden="true">图一</figcaption></figure><p>单目 3D 检测和 2D 检测具有相同的输入数据模态和不同的预测目标。2D 检测任务一般要求在给定一张输入图像后，检测出物体的类别和 2D 框；单目 3D 检测则设定在给定同样的一张二维图像下，检测出物体的类别和 3D 框，其中 3D 框通常拥有至少 7 个自由度：三维位置，三维框大小以及转向角</p><span id="more"></span><h3 id="驱动任务">驱动任务</h3><p>Snapshot compressive imaging (SCI) uses a two-dimensional (2D) detector to capture HD (≥ 3D) data in a snapshot measurement.<br />Via novel optical designs, the 2D detector samples the HD data in a compressive manner; following this, algorithms are employed to reconstruct the desired HD data-cube</p><p>快照压缩成像（SCI）使用二维（2D）探测器在快照测量中捕获高维（≥3D）数据。通过新颖的光学设计，2D探测器以压缩方式采样高维数据；随后，使用算法重建所需的高维数据立方体</p><h3 id="什么是-data-cube-数据立方体">什么是 Data-Cube (数据立方体)？</h3><p>数据立方体是一种多维数据模型, 并且只有三维。</p><figure><img src="Data-Cube.png" alt="数据立方体" /><figcaption aria-hidden="true">数据立方体</figcaption></figure><h4 id="什么是多维数据模型">什么是多维数据模型？</h4><p>多维模型的相关概念： - 多维数据模型：为了满足用户从多角度多层次进行数据查询和分析的需要而建立起来的基于事实和维的数据库模型，其基本的应用是为了实现OLAP（Online Analytical Processing） - 立方体：它是由维度构建出来的多维空间，包含了所要分析的基础数据，所有的聚合数据操作都在它上面进行 - 维度：观察数据的一种角度，比如在上图中address、item、time都可以被看作一个维度，直观上来看维度是一个立方体的轴，比如三个维度可以构成一个立方体的空间 - 维度成员：构成维度的基本单位，比如对于time维，包含Q1、Q2、Q3、Q4四个维度成员 - 层次：维度的层次结构，它存在两种：自然层次和用户自定义层次。比如对于时间维，可以分为年、月、日三个层次，也可以分为年、季度、月三个层次。一个维可以有多个层次，它是单位数据聚集的一种路径 - 级别：级别组成层次，比如年、月、日分别是时间维的三个级别 - 度量：一个数值函数，可以对数据立方体空间中的每个点求值；度量值自然就是度量的结果 - 事实表：存放度量值得表，同时存放了维表得外键，所有分析所用得数据最终都来自事实表 - 维表：对于维度的描述，每个维度对应一个或多个维表，一个维度对应一个表的是星型模式，对应多个表的是雪花模式 - OLAP：Online Analytical Processing，联机分析处理，是一种多维、分析式的查询处理技术，它是一种基于维度的数据分析方法，它的基本特征是：面向主题、集成性、时序性、非易失性、动态性、客户/服务器结构、开放式的数据库连接、多维数据分析、灵活的报表生成、图形化的用户界面</p><figure><img src="多维模型.png" alt="多维数据模型" /><figcaption aria-hidden="true">多维数据模型</figcaption></figure><h3 id="什么是-cs-compressive-sensing-压缩感知">什么是 CS (Compressive Sensing) 『压缩感知』?</h3><p>压缩感知本质上一个线性逆问题 (linear inverse problem)，目的是从少量的线性测量 (linear measurements) 中还原高维的信号。</p><h4 id="什么是线性反问题-linear-inverse-problem">什么是线性反问题 (linear inverse problem)？</h4><p>在数学上,一对问题称为是互逆的，如果一个问题的表述或处理需要另一个问题解的信息；若把其中的一个问题称为正问题，另一个就称为反问题。</p><p>在物理问题上,反问题是指从一些带噪声的观测中试图还原出真实信息的行为,很好理解,这和上面的一点其实是一样的.</p><p>而对反问题而言,Well-posed和ill-posed的情况都是存在的,<a href="https://de.wikipedia.org/wiki/Inverses_Problem#:~:text=Inverses%20Problem%20Ein%20mathematisches%20Problem%20wird%20ein%20inverses,oft%20sehr%20schwierig%20oder%20manchmal%20gar%20nicht%20l%C3%B6sbar.">(Man unterscheidet <code>gut gestellte</code> und <code>schlecht gestellte</code> inverse Probleme. )</a></p><p>故而,想要理解求解 inverse problem 之难, 我们最好对适定问题（Well-posed problem）有一定的了解.</p><p>什么是适定问题（Well-posed problem）呢?<br />满足<code>解存在</code>、<code>唯一</code>且<code>连续依赖于定解条件</code>三个条件的问题,我们称之为 Well-posed problem ,反之,只要有一个条件不满足,则称之为不适定问题（ill-posed problems）</p><p>在图像识别领域且不仅在此领域,inverse problem 通常是 ill-posed problem.</p><p>到这里,什么是线性反问题 (linear inverse problem) 就很好理解了,就是从一些带噪声的观测中试图还原出真实信息的行为,且这个问题是一个线性问题.</p><h3 id="什么是-sparse-mri-稀疏磁共振成像">什么是 sparse MRI (稀疏磁共振成像)？</h3><p>MRI (Magnetic Resonance Imaging) 磁共振成像是一种医学成像技术，它利用磁共振现象对人体进行成像，是一种无创的检查方法。MRI 通过对人体进行扫描，利用计算机对扫描结果进行处理，得到人体的图像。MRI 检查不仅可以对人体进行断层成像，还可以对人体进行三维成像，从而可以对人体进行全方位的观察。</p><h3 id="d">2.5D</h3><p>2.5D 通常指的是 2.5 维，即 2D + 1D，比如 2D 图像 + 1D 深度图<br />第六页写道 "Note that (x, y, z) denotes 3D tomography and we use (x, y)+z to represent a 2D image plus a depth map, which is also called 2.5D in certain articles in the literature."<br />(x,y)+z 当然是 2.5D</p><h2 id="sci-的数学模型">SCI 的数学模型</h2><p>前文中, 作者举了 video SCI &amp; spectral SCI 两个例子来介绍 SCI 的设计. 而在本节中, 作者为他们构建了一个统一的数学模型, 这个模型也方便嵌套在别的 3D SCI 中.<br />在模型中, 作者使用了 mask matrix, 我们需要再复习一下 mask 的概念.</p><h3 id="什么是-mask-掩膜">什么是 mask (掩膜)?</h3><p>mask（掩码、掩膜）是深度学习中的常见操作。简单而言，其相当于在原始张量上盖上一层掩膜，从而屏蔽或选择一些特定元素, 其中掩膜的元素值为 0 或 1，0 表示屏蔽，1 表示选择。</p><p>按照上述定义，非线性激活函数Relu（根据输出的正负区间进行简单粗暴的二分）、dropout机制（根据概率进行二分）都可以理解为泛化的mask操作。</p><p>正如其名 mask 在宏观上的表现就是<code>遮罩</code></p><figure><img src="mask.png" alt="使用mask提取ROI区域" /><figcaption aria-hidden="true">使用mask提取ROI区域</figcaption></figure><h3 id="什么是-cassi-coded-aperture-snapshot-spectral-imaging-编码孔径快照光谱成像">什么是 CASSI (Coded Aperture Snapshot Spectral Imaging) 『编码孔径快照光谱成像』</h3><p>CASSI (coded aperture snapshot spectral imaging)是一种具有代表性的高光谱图像捕获SCI系统。</p><h3 id="main-difference-between-sci-and-single-pixel-imaging">Main Difference between SCI and Single-Pixel Imaging</h3><p>二者主要的区别存在于 forward model 上.</p><p>单像素相机的 sensing matrix (Φ) 是 dense matrix, 而 SCI 的 sensing matrix 是 sparse matrix.</p><p>单像素相机中,感知矩阵Φ的每一行对应于在场景（一个2D静态图像）x 上施加的调制器的一个模式。这些模式可以被视为对场景的编码方式，类似于将图像分成不同的部分或区域，并对每个部分应用不同的测量方式。</p><p>而单像素探测器会捕获这些模式下的测量结果，每个测量对应于感知矩阵Φ的一行。换句话说，通过应用感知矩阵的每个模式，探测器会测量场景中的某种特性或信息，然后这些测量结果会被组合成一个向量，通常表示为向量y。这个向量y可以被用来进行图像重建，从而还原出原始的2D静态图像x。</p><p>在SCI的感知矩阵Φ中，它被构建为Nt个对角矩阵的串联。每个对角矩阵对应于一个时间帧（frame），所以Nt代表了时间帧的数量。对角矩阵的概念是，在主对角线上有非零元素，其他位置都是零。每个对角矩阵中的非零元素用来表示该帧中特定位置的测量权重。</p><p>测量的每个元素是通过对应位置 x(a 3D or HD cube) 上不同<code>时间帧</code> Nt 中的元素进行加权求和得到的。这个过程涉及到应用mask (掩膜)对不同时间帧的信息进行调制，然后加权求和得到最终的测量结果。这些测量结果最终表示为向量y。</p><p>再者, 单像素相机中的密集矩阵较大, 存储起来消耗的资源也更多(如果是随机的, 我们肯定要去保存他) 当然,我们可以用 structural matrix 的方法来优化, 比如 DCT 或者 Hadamard matrix, 也可以使用一些经过排序或者特定设计的矩阵.</p><p>相比之下，在快照压缩成像中，虽然感知矩阵Φ要比单像素成像中的感知矩阵大，但我们不需要存储整个<span class="math inline">\(Φ\)</span>矩阵，只需要存储 mask (Φ 中的 <span class="math inline">\(N^t\)</span> 个对角元素)。由于<span class="math inline">\(Φ\)</span>的特殊结构，观察到<span class="math inline">\(ΦΦ^T\)</span>是一个对角矩阵。这个性质在文献中被用来加速快照压缩成像的重建算法。这种对角性质可以利用，使得重建算法更高效。</p><h2 id="参考资料">参考资料</h2><ol type="1"><li><p><a href="https://zhuanlan.zhihu.com/p/400191167">"3Dfy" A General 2D Detector: 纯视觉 3D 检测再思考</a></p></li><li><p><a href="https://blog.csdn.net/forlogen/article/details/88634117">数据立方体（Data Cube）</a></p></li><li><p><a href="https://www.zhihu.com/question/28552876">如何理解压缩感知(compressive sensing)？</a></p></li><li><p><a href="https://www.rebellionresearch.com/what-is-sensing-matrix">What is sensing matrix?</a></p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity集换式卡牌游戏_Dictionry序列化成json</title>
      <link href="/posts/5e1ac7cf/"/>
      <url>/posts/5e1ac7cf/</url>
      
        <content type="html"><![CDATA[<p>在开始讲解这一章节前，我们需要了解，什么是 Json.</p><h2 id="json">Json</h2><p>他的全称是 JavaScript Object Notation 【JavaScript 对象表示法】<br /><span id="more"></span> JSON 是存储和交换文本信息的<code>语法</code>。类似 XML。json是基于<code>ECMAScript</code>语法，但这并不意味着 json 必须在 js 中使用，或者必须要产生什么联系， json 在 js 中的处理也并没有比其他语言占有更多优势。只是因为语法相似，而使得js开发者能更快的上手 json 而已。</p><p>JSON采用完全独立于任何程序语言的文本格式,但是也使用了类似于 C 语言家族的习惯（包括 C、C++、C#、Java、JavaScript、Perl、Python 等）。这些特性使 JSON 成为理想的数据交换语言。易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</p><h3 id="典型的-json-数据">典型的 Json 数据</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">对象：</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;火球术&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;cost&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Owner&quot;</span><span class="punctuation">:</span> <span class="string">&quot;法师&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">数组：</span><br><span class="line"><span class="punctuation">[</span><span class="string">&quot;hello&quot;</span><span class="punctuation">,</span><span class="number">3.1415</span><span class="punctuation">,</span><span class="string">&quot;json&quot;</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">数组嵌套对象：</span><br><span class="line"><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;admin&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">18</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;root&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">16</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">20</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><h3 id="json-语法规则">Json 语法规则</h3><ul><li>数据在 <code>键值对</code> 中</li><li>数据由逗号 , 分隔</li><li>使用斜杆  来转义字符</li><li>大括号 {} 保存对象</li><li>中括号 [] 保存数组，数组可以包含多个对象</li></ul><h4 id="json-的值">json 的值</h4><ul><li>数字（整数或浮点数）</li><li>字符串（在双引号中）</li><li>逻辑值（true 或 false）</li><li>数组（在中括号中）</li><li>对象（在大括号中）</li><li>null</li></ul><h2 id="jsonutility">JsonUtility</h2><p>JsonUtility 是 Unity 提供的一个工具类，用于序列化和反序列化 Json 数据。</p><h3 id="使用方法">使用方法</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="built_in">string</span> json = JsonUtility.ToJson(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line">myObject = JsonUtility.FromJson&lt;T&gt;(json);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 Json 文本中读取数据并将其反序列化到现有对象中。</span></span><br><span class="line">FromJsonOverwrite(<span class="built_in">string</span> text, <span class="built_in">object</span> objectToOverwrite)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ToJson(<span class="built_in">object</span> target, <span class="built_in">bool</span> prettyPrint)</span><br><span class="line">target：对象转换为 Json 数据文本</span><br><span class="line">prettyPrint：决定最终的 Json 数据文本是否是一个格式化后的数据文本。</span><br><span class="line">即是否使用 Json 文本的 Format 化。</span><br><span class="line"></span><br><span class="line">FromJson(<span class="built_in">string</span> text)</span><br><span class="line">将 Json 数据文本转存至类中 <span class="keyword">public</span> 或 附有 SerializeField 特性的字段上赋值。</span><br><span class="line">使用时无需管理值具体分配。其将基于字段命名自行匹配并赋值。</span><br><span class="line">此代码将创建一个新的 T 实例，并使用 JSON 数据设置该实例的值。如果 JSON 数据包含的某些值未映射到 T 中的字段，则序列化程序将忽略这些值。如果 JSON 数据缺少 T 中某些字段的值，则序列化程序会在返回的对象中保留这些字段的构造值。</span><br><span class="line"></span><br><span class="line">FromJsonOverwrite(<span class="built_in">string</span> text, <span class="built_in">object</span> objectToOverwrite)</span><br><span class="line">在现有对象上反序列化 JSON 数据，从而覆盖所有现有数据。</span><br><span class="line">使用时无需管理值具体分配。其将基于字段命名自行匹配并赋值。</span><br><span class="line">如果 JSON 数据不包含某个字段的值，则序列化程序不会更改该字段的值。</span><br><span class="line">JSON 序列化程序 API 支持 MonoBehaviour 和 ScriptableObject 子类以及普通结构和类。但是，将 JSON 反序列化为 MonoBehaviour 或 ScriptableObject 子类时，必须使用 FromJsonOverwrite 方法。如果尝试使用 FromJson，则 Unity 会抛出异常，因为不支持此行为。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="注意事项">注意事项</h3><ul><li>仅支持 MonoBehaviour / ScriptableObject 继承类的序列化</li><li>仅支持 [Serializable] 的普通类与结构体</li><li>仅序列化 public 或 [SerializeField] 标签的字段<br /></li><li>在内部，此方法使用 Unity 序列化器；因此传入的对象必须受序列化器支持：它必须是 MonoBehaviour、ScriptableObject 或应用了 Serializable 属性的普通类/结构。要包含的字段的类型必须受序列化器支持；不受支持的字段以及私有字段、静态字段和应用了 NonSerialized 属性的字段会被忽略。</li><li>支持 List、Array 数据类型，但不支持 Dictionary、Query、Stack 等集合</li><li>支持 Enum 枚举，但默认存储值为数值类型</li></ul><h2 id="字典的序列化和反序列化">字典的序列化和反序列化</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SerializeDictionary</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">DicToJson</span>&lt;<span class="title">TKey</span>, <span class="title">TValue</span>&gt;(<span class="params">Dictionary&lt;TKey, TValue&gt; dic</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> JsonUtility.ToJson(<span class="keyword">new</span> SerializeDictionary&lt;TKey, TValue&gt;(dic));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">Dictionary</span>&lt;<span class="title">TKey</span>, <span class="title">TValue</span>&gt; <span class="title">DicFromJson</span>&lt;<span class="title">TKey</span>, <span class="title">TValue</span>&gt;(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> JsonUtility.FromJson&lt;SerializeDictionary&lt;TKey, TValue&gt;&gt;(str).ToDictionary();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SerializeDictionary</span>&lt;<span class="title">TKey</span>, <span class="title">TValue</span>&gt; : <span class="title">ISerializationCallbackReceiver</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    List&lt;TKey&gt; keys;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    List&lt;TValue&gt; values;</span><br><span class="line"></span><br><span class="line">    Dictionary&lt;TKey, TValue&gt; target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dictionary&lt;TKey, TValue&gt; <span class="title">ToDictionary</span>()</span> &#123; <span class="keyword">return</span> target; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SerializeDictionary</span>(<span class="params">Dictionary&lt;TKey, TValue&gt; target</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnBeforeSerialize</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        keys = <span class="keyword">new</span> List&lt;TKey&gt;(target.Keys);</span><br><span class="line">        values = <span class="keyword">new</span> List&lt;TValue&gt;(target.Values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnAfterDeserialize</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> count = Math.Min(keys.Count, values.Count);</span><br><span class="line">        target = <span class="keyword">new</span> Dictionary&lt;TKey, TValue&gt;(count);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            target.Add(keys[i], values[i]);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><p>本文作于2023-08-21，首发于个人博客<a href="https://rdququ.top/" class="uri">https://rdququ.top/</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程向 </category>
          
          <category> 游戏开发 </category>
          
          <category> Unity </category>
          
          <category> 集换式卡牌游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 卡牌游戏 </tag>
            
            <tag> Unity </tag>
            
            <tag> 教程，Json </tag>
            
            <tag> 字典 </tag>
            
            <tag> 序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity集换式卡牌游戏_第4期_配表与读取你的卡牌</title>
      <link href="/posts/bf64112e/"/>
      <url>/posts/bf64112e/</url>
      
        <content type="html"><![CDATA[<p>在上一期中，我们制作了自己的第一张卡牌，并且通过<code>CardDisplay</code>类中的<code>DisplayCard()</code>方法展示了我们卡牌的属性。当时为了方便展示，我们直接在<code>CardDisplay</code>中的<code>Start()</code>里 new 了一张火球术出来 <span id="more"></span> <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cardModel = <span class="keyword">this</span>.GetModel&lt;CardModel&gt;();</span><br><span class="line">        card =<span class="keyword">new</span> SpellCard(<span class="number">1</span>, <span class="string">&quot;Fireball&quot;</span>, <span class="string">&quot;Deals 5 damage&quot;</span>, <span class="number">5</span>, <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;Fire&quot;</span> &#125;);<span class="comment">//就是这句啦</span></span><br><span class="line">        DisplayCard();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>然鹅，我们显然不能把我们所以的卡牌都以这样的方法 new 出来，我们需要一种更成熟，更方便的方法获取我们的卡牌————读配表。</p><h2 id="配表">配表</h2><p>在实际开发中策划会不断地提出不同的需求，但是他们不会直接对代码进行操作，而是通过和程序的沟通间接完成，而将它们对数值的具体需求，忠实的向程序反映的桥梁就是数据表，一个典型的数据表可能是这样的： ||主键|名称|描述| |---|---|---|---| |类型|INT|STRING|STRING| |字段名|ID|Name|Desc| ||1|勇士|勇敢的战士，遵循你的召唤而降生| |</p><p>当然，实际的表可能会比这复杂的多。程序需要做的，就是去读取这张表，并可能将他以另外某种形式储存起来。持久存储数据的方法有很多，CSV,Json,XML,二进制...今天我们主要介绍的，就是CSV文件的读取。<br />## csv的读取 csv其实就是 <code>Comma-Separated Values</code> -&gt; 逗号分隔的值<br />想要新建一个 csv 文件，就用 Excel 把 xls 另存为 csv 文件即可。 在视频中，我们新建了一个 CardData 文件，我们是这样读取他的 <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadCardsFromCsv</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       cardData = Resources.Load&lt;TextAsset&gt;(<span class="string">&quot;Data/cardData&quot;</span>);<span class="comment">//读取csv文件</span></span><br><span class="line">       <span class="built_in">string</span>[] dataRow = cardData.text.Split(<span class="string">&#x27;\n&#x27;</span>);<span class="comment">//按行分割</span></span><br><span class="line">       <span class="keyword">foreach</span>(<span class="keyword">var</span> row <span class="keyword">in</span> dataRow)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">string</span>[] rowArray = row.Split(<span class="string">&#x27;,&#x27;</span>);<span class="comment">//按列分割</span></span><br><span class="line">           <span class="keyword">if</span> (rowArray[<span class="number">0</span>] == <span class="string">&quot;类型&quot;</span>)<span class="comment">//跳过第一行</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (rowArray[<span class="number">0</span>] == <span class="string">&quot;MonsterCard&quot;</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               MonsterCard monsterCard = <span class="keyword">new</span> MonsterCard(<span class="built_in">int</span>.Parse(rowArray[<span class="number">1</span>]), rowArray[<span class="number">2</span>], rowArray[<span class="number">3</span>], <span class="built_in">int</span>.Parse(rowArray[<span class="number">4</span>]), rowArray[<span class="number">5</span>].Split(<span class="string">&#x27;;&#x27;</span>), <span class="built_in">int</span>.Parse(rowArray[<span class="number">9</span>]), <span class="built_in">int</span>.Parse(rowArray[<span class="number">10</span>]));</span><br><span class="line">               totalCards.Add(monsterCard);</span><br><span class="line">               Debug.Log(<span class="string">&quot;monsterCard.Name&quot;</span>+monsterCard.Name);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (rowArray[<span class="number">0</span>] == <span class="string">&quot;SpellCard&quot;</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               SpellCard spellCard = <span class="keyword">new</span> SpellCard(<span class="built_in">int</span>.Parse(rowArray[<span class="number">1</span>]), rowArray[<span class="number">2</span>], rowArray[<span class="number">3</span>], <span class="built_in">int</span>.Parse(rowArray[<span class="number">4</span>]), rowArray[<span class="number">5</span>].Split(<span class="string">&#x27;;&#x27;</span>));</span><br><span class="line">               totalCards.Add(spellCard);</span><br><span class="line">               Debug.Log(<span class="string">&quot;spellCard.Name&quot;</span> + spellCard.Name);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>我们先用<code>/n</code>把文件分割成一行一行的字符串数组，再通过<code>,</code>如法炮制，把每一行都分割成对应 csv 表格的字符串数组，方便我们读取。跳过不需要读取的行， 我们按照事先标记的卡牌的种类，依次 new 出具体的 card，并把他们储存到 <code>List&lt;Card&gt;</code> 中去。 就这样，我们的卡牌的读取就顺利完成了，其实并没有什么难度，也适合自由发挥。 在视频的最后，我留下了 SkillData 没有读取，这里把读取方法一并写出。<br />我们新建了 Skill 类 和 SkillModel 类</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Skill</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">int</span> ID;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">string</span> Description;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">int</span> SkillValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> QFramework;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SkillModel</span> :<span class="title">AbstractModel</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> TextAsset skillData;</span><br><span class="line">    List&lt;Skill&gt; totalSkills = <span class="keyword">new</span> List&lt;Skill&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnInit</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        LoadSkillsFromCsv();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadSkillsFromCsv</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        skillData = Resources.Load&lt;TextAsset&gt;(<span class="string">&quot;Data/SkillData&quot;</span>);<span class="comment">//读取csv文件</span></span><br><span class="line">        <span class="built_in">string</span>[] dataRow = skillData.text.Split(<span class="string">&#x27;\n&#x27;</span>);<span class="comment">//按行分割</span></span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> row <span class="keyword">in</span> dataRow)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span>[] rowArray = row.Split(<span class="string">&#x27;,&#x27;</span>);<span class="comment">//按列分割</span></span><br><span class="line">            <span class="keyword">if</span> (rowArray[<span class="number">0</span>] == <span class="string">&quot;技能ID&quot;</span>)<span class="comment">//跳过第一行</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Skill skill = <span class="keyword">new</span> Skill();</span><br><span class="line">                skill.ID = <span class="built_in">int</span>.Parse(rowArray[<span class="number">0</span>]);</span><br><span class="line">                skill.Name = rowArray[<span class="number">1</span>];</span><br><span class="line">                skill.Description = rowArray[<span class="number">2</span>];</span><br><span class="line">                skill.SkillValue = <span class="built_in">int</span>.Parse(rowArray[<span class="number">5</span>]);      </span><br><span class="line">                totalSkills.Add(skill);</span><br><span class="line">                Debug.Log(<span class="string">&quot;读取了技能&quot;</span>+skill.Name+<span class="string">&quot; 技能ID: &quot;</span>+skill.ID+<span class="string">&quot; 技能描述: &quot;</span>+skill.Description+<span class="string">&quot; 技能数值: &quot;</span>+skill.SkillValue);</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，和上次我们写的 Card 颇有不同，也是想借此告诉大家，程序的设计方法千千万，不必拘泥于某一种写法，因地制宜才是妙招。</p><hr /><p>本文作于2023-08-15，首发于个人博客<a href="https://rdququ.top/" class="uri">https://rdququ.top/</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程向 </category>
          
          <category> 游戏开发 </category>
          
          <category> Unity </category>
          
          <category> 集换式卡牌游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 卡牌游戏 </tag>
            
            <tag> Unity </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity集换式卡牌游戏_制作第一张卡牌</title>
      <link href="/posts/5c5e7aaf/"/>
      <url>/posts/5c5e7aaf/</url>
      
        <content type="html"><![CDATA[<h2 id="前期准备">前期准备</h2><p>我们制作卡牌游戏之前，先得拿到一套可用的素材，这里我们使用的是<a href="https://assetstore.unity.com/packages/2d/gui/2d-modular-cards-kit-demo-227623">卡牌游戏素材</a>。<br />在上方状态栏中，窗口下的资源商店中搜索<code>2D Modular Cards Kit Demo</code>，点击下载即可。下载完成后，仍然是在窗口下的包管理器中，选择我的资产，下载后导入即可。<br /><span id="more"></span> <img src="资源商店和包管理器.png" alt="资源商店和包管理器" /><br />导入好素材后，我们还需要处理一二。选择 Sprite Texture Folder 下的 Cards 在 Inspector 中，将 Texture Type 改为 Sprite(2D and UI)。Sprite Mode 改为 Multiple，点击 Sprite Editor，点击 Slice，选择 Type 为 Automatic 即可，点击 Slice，点击 Apply。 当然，这是简单且不完美的做法的做法。<br />更好的做法是，选择 Type 为 Grid By Cell Size，然后量体裁衣。但就这个素材，我已经量好了：<br />像素大小 X 94 Y 126<br />偏移 X 17 Y 6 填充 X 34 Y 0<br />大家直接用就行。 到这里，素材处理完了，我们还需要制作一下 TMP 可用的字体。<br />在 C:里有很多本机字体，我们可以直接使用。 再在网上找一个常用，就可以开始制作字体了。这里我们直说怎么最快的做出来，不加以详细阐释，大家感兴趣可以自行搜教程，或者我有空补写一个。<br />我的版本是 2021.3.12 这在最上面也能看得出来。<br /><img src="Unity版本.png" alt="Unity版本" /><br />窗口 -&gt; TextMeshPro -&gt; Font Asset Creator<br />Source Font File 选择我们刚刚下载的字体，Character Set 选择 Characters from File,下方的 Characters File 选择你的字库, Atlas Resolution 选择 2048*2048 , padding 在 2-6左右, 然后点击 Generate Font Atlas 即可。<br />可以参考这篇文章：https://blog.csdn.net/qq_37454669/article/details/121128100<br />制作好字体，拖进你的Text一类的组件里的 Font Asset里，就可以使用了。 ## 制作第一张卡牌-UI 终于做好前期准备了，来看UI吧。 这段看视频就好了，我就不写了（逃 ## 制作第一张卡牌-逻辑 这边是有些要细说的点的<br />首先，我们新建一个 Card 脚本，把里面的东西都删掉，新建一个 Card 类。这个类我们放 Card 共有的一些属性，比如ID，Name，Description，Cost等等。还有卡牌可以发动的技能，我们也写上去。 <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Card</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ID;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Description;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Cost;</span><br><span class="line">    <span class="built_in">string</span>[] SpellType;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Card</span>(<span class="params"><span class="built_in">int</span> id, <span class="built_in">string</span> name, <span class="built_in">string</span> description, <span class="built_in">int</span> cost, <span class="built_in">string</span>[] spellType</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ID = id;</span><br><span class="line">        Name = name;</span><br><span class="line">        Description = description;</span><br><span class="line">        Cost = cost;</span><br><span class="line">        SpellType = spellType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> SpellType 这个属性，我们用来存储卡牌的技能。做成String[]是因为，一个卡牌可以有多个技能，比如一个卡牌可以是<code>[攻击, 防御]</code>，也可以是<code>[攻击, 防御, 治疗]</code>。同样，String也方便我们读表。 同样，一张卡也有不同的类型，比如怪兽卡，魔法卡，陷阱卡等等。我们可以用一个枚举来表示这些类型，也可以用子类，我这里没有使用枚举类型，并不是说枚举就不好，相反，枚举类型在某些时候更加高效，但是我这里用子类，是因为我想让大家看到子类的使用，同样，这里使用子类逻辑也会更清晰。如果我们未来卡牌种类有很多，使用子类也能避免枚举类型照顾太多属性的问题。 <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MonsterCard</span> : <span class="title">Card</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Health;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Attack;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MonsterCard</span>(<span class="params"><span class="built_in">int</span> id, <span class="built_in">string</span> name, <span class="built_in">string</span> description, <span class="built_in">int</span> cost,<span class="built_in">string</span>[] spellType, <span class="built_in">int</span> health, <span class="built_in">int</span> attack</span>) : <span class="title">base</span>(<span class="params">id, name, description, cost, spellType</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Health = health;</span><br><span class="line">        Attack = attack;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SpellCard</span> : <span class="title">Card</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpellCard</span>(<span class="params"><span class="built_in">int</span> id, <span class="built_in">string</span> name, <span class="built_in">string</span> description, <span class="built_in">int</span> cost,<span class="built_in">string</span>[] spellType</span>) : <span class="title">base</span>(<span class="params">id, name, description, cost, spellType</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 我们前面制作了卡牌的UI，那么我们也需要一个脚本来控制卡牌的展示逻辑。同样的，有时候我们在这里会使用一个静态的 UIManager 单例。但我像把他留在后面，所以这里我们就不用单例了。 <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> TMPro;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CardDisplay</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> TextMeshProUGUI nameText;</span><br><span class="line">    <span class="keyword">public</span> TextMeshProUGUI descriptionText;</span><br><span class="line">    <span class="keyword">public</span> TextMeshProUGUI costText;</span><br><span class="line">    <span class="keyword">public</span> TextMeshProUGUI healthText;</span><br><span class="line">    <span class="keyword">public</span> TextMeshProUGUI attackText;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Card card;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        card =<span class="keyword">new</span> SpellCard(<span class="number">1</span>, <span class="string">&quot;Fireball&quot;</span>, <span class="string">&quot;Deals 5 damage&quot;</span>, <span class="number">5</span>, <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;Fire&quot;</span> &#125;);</span><br><span class="line">        DisplayCard();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DisplayCard</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        nameText.text = card.Name;</span><br><span class="line">        descriptionText.text = card.Description;</span><br><span class="line">        costText.text = card.Cost.ToString();</span><br><span class="line">        <span class="keyword">if</span> (card.GetType() == <span class="keyword">typeof</span>(MonsterCard))</span><br><span class="line">        &#123;</span><br><span class="line">            MonsterCard monsterCard = (MonsterCard)card;</span><br><span class="line">            healthText.text = monsterCard.Health.ToString();</span><br><span class="line">            attackText.text = monsterCard.Attack.ToString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            healthText.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">            attackText.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 使用TMP一定要 using TMPro;<br />我们先声明一些 TextMeshProUGUI 然后在 Unity 里把他们拖进 CardDisplay.<br />同样，我们也需要声明一个 Card 类型的变量，用来存储我们的卡牌。在Start里，我们初始化一个卡牌，否则不方便演示， card也会变成一个野指针。这是我们要极力避免的。<br />随机我们开始编写 DisplayCard() 方法。这里的逻辑很好理解————就是'有的显示，没的隐藏'， 当然， 我后面使用 else 显然是不合时宜的，我后面会修改的。<br /><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MonsterCard monsterCard = (MonsterCard)card;</span><br></pre></td></tr></table></figure> 也可以写作 <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MonsterCard monsterCard = card <span class="keyword">as</span> MonsterCard;</span><br></pre></td></tr></table></figure> 看起来会更优雅一点。 最好，不要忘记在Start()里面调用DisplayCard()方法，否则你的卡牌就不会显示了。</p><hr /><p>本文作于2023-08-12，首发于个人博客<a href="https://rdququ.top/" class="uri">https://rdququ.top/</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程向 </category>
          
          <category> 游戏开发 </category>
          
          <category> Unity </category>
          
          <category> 集换式卡牌游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 卡牌游戏 </tag>
            
            <tag> Unity </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JasonChatroom学习笔记</title>
      <link href="/posts/a4fbf16a/"/>
      <url>/posts/a4fbf16a/</url>
      
        <content type="html"><![CDATA[<p>今天跟着博主 科技7C100 做一个简单的 chatroom.<br />在 Unity 前端页面，设置了 Scroll View 来显示聊天内容，一个 InputField 来输入信息，还有两个按钮用于链接和发送。<br />在设计脚本之前，我们需要了解网络编程的基础知识 <span id="more"></span></p><table style="width:6%;"><colgroup><col style="width: 5%" /></colgroup><tbody><tr class="odd"><td>以下内容摘自 http://www.cnblogs.com/skynet/ ## 网络中进程之间如何通信 网络通信首要解决的问题是如何唯一标识一个进程，否则通信无从谈起！在本地可以通过进程 PID 来唯一标识一个进程，但是在网络中这是行不通的。其实 TCP/IP 协议族已经帮我们解决了这个问题，网络层的 “ip 地址” 可以唯一标识网络中的主机，而传输层的“协议+端口”可以唯一标识主机中的应用程序（进程）。这样利用三元组（ ip 地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。</td></tr><tr class="even"><td>使用 TCP/IP 协议的应用程序通常采用应用编程接口：UNIX BSD的套接字（socket）和 UNIX System V 的 TLI（已经被淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用程序都是采用 socket，而现在又是网络时代，网络中进程通信是无处不在，这就是我为什么说“一切皆 socket ”。</td></tr><tr class="odd"><td>## 什么是Socket socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写 write/read –&gt; 关闭 close”模式来操作。我的理解就是 Socket 就是该模式的一个实现，socket 即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写 IO、打开、关闭）</td></tr></tbody></table><h2 id="前端设计">前端设计</h2><p>在Connect()方法中，我们这样设计<br /><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Connect</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">       socket = <span class="keyword">new</span> Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);</span><br><span class="line">       <span class="comment">//使用指定的地址族、套接字类型和协议初始化 Socket 类的新实例。</span></span><br><span class="line">       <span class="comment">//AddressFamily指定 Socket 类的实例可以使用的寻址方案;InterNetwork 是 IPV4 的地址</span></span><br><span class="line">       <span class="comment">//SocketType指定 Socket 类的实例表示的套接字类型；Stream支持可靠、双向、基于连接的字节流，而不重复数据，也不保留边界。 此类型的 Socket 与单个对方主机通信，并且在通信开始之前需要建立远程主机连接。 Stream 使用传输控制协议 (ProtocolType.Tcp) 和 AddressFamily。InterNetwork 地址族。</span></span><br><span class="line">       <span class="comment">//ProtocolType是指定 Socket 类支持的协议。</span></span><br><span class="line"></span><br><span class="line">       socket.Connect(<span class="keyword">new</span> IPEndPoint(IPAddress.Parse(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">10010</span>));</span><br><span class="line">       <span class="comment">//socket.Connect()与远程主机建立连接。</span></span><br><span class="line">       <span class="comment">//Connect(IPAddress, Int32)与远程主机建立连接。 主机由 IP 地址和端口号指定。</span></span><br><span class="line">       <span class="comment">//IPEndPoint提供 Internet 协议 (IP) 地址。这里是远程主机的 IP 地址。</span></span><br><span class="line">       <span class="comment">//10010是 port 远程主机的端口号。</span></span><br><span class="line"></span><br><span class="line">       socket.BeginReceive(buffer, <span class="number">0</span>, buffer.Length,<span class="number">0</span>, _ =&gt;&#123;&#125;, socket);</span><br><span class="line">       <span class="comment">//BeginReceive(Byte[], Int32, Int32, SocketFlags, AsyncCallback, Object)开始从连接的 Socket 中异步接收数据。</span></span><br><span class="line">       <span class="comment">// buffer</span></span><br><span class="line">       <span class="comment">// Byte[]</span></span><br><span class="line">       <span class="comment">// Byte 类型的数组，它是存储接收到的数据的位置。</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// offset</span></span><br><span class="line">       <span class="comment">// Int32</span></span><br><span class="line">       <span class="comment">// buffer 参数中存储所接收数据的位置，该位置从零开始计数。</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// size</span></span><br><span class="line">       <span class="comment">// Int32</span></span><br><span class="line">       <span class="comment">// 要接收的字节数。</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// socketFlags</span></span><br><span class="line">       <span class="comment">// SocketFlags</span></span><br><span class="line">       <span class="comment">// SocketFlags 值的按位组合。</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// callback</span></span><br><span class="line">       <span class="comment">// AsyncCallback</span></span><br><span class="line">       <span class="comment">// 一个 AsyncCallback 委托，它引用操作完成时要调用的方法。</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// state</span></span><br><span class="line">       <span class="comment">// Object</span></span><br><span class="line">       <span class="comment">// 一个用户定义的对象，其中包含接收操作的相关信息。 当操作完成时，此对象会被传递给 EndReceive(IAsyncResult) 委托。</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure> Recevie()是（同步阻塞方式）, 注意使用同步方法时，需要使用线程来开始方法，不然服务器不发送任何信息的话，Unity界面会卡死<br />这里使用使用BeginReceive（异步）</p><p>我们继续看Send的内部实现<br /><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Send</span>(<span class="params"><span class="built_in">string</span> data</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">       socket.Send(System.Text.Encoding.UTF8.GetBytes(data));</span><br><span class="line">       <span class="comment">//Socket.Send 方法将数据发送到连接的 Socket。</span></span><br><span class="line">       <span class="comment">//buffer </span></span><br><span class="line">       <span class="comment">//Byte[]</span></span><br><span class="line">       <span class="comment">//类型 Byte 的数组，其中包含要发送的数据。</span></span><br><span class="line">       <span class="comment">//Encoding表示字符编码</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure> 这里写一下回调方法 <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReceiveCallback</span>(<span class="params">IAsyncResult ar</span>)<span class="comment">//接收数据回调</span></span></span><br><span class="line">   &#123;</span><br><span class="line">       Socket socket = (Socket)ar.AsyncState;<span class="comment">//获取当前的socket</span></span><br><span class="line">       <span class="built_in">int</span> length = socket.EndReceive(ar);<span class="comment">//获取接收到的数据长度</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">//错误示范：UIManager.Instance.connectText.text += System.Text.Encoding.UTF8.GetString(buffer, 0, length);//显示接收到的数据</span></span><br><span class="line">       <span class="comment">//原因：UIManager.Instance.connectText.text是在主线程中调用的，而socket.BeginReceive不会在Unity主线程中执行</span></span><br><span class="line">       <span class="comment">//下面是正确示范</span></span><br><span class="line">       GameManager.Instance.messageQueue.Enqueue(() =&gt;<span class="comment">//将接收到的数据放入消息队列中</span></span><br><span class="line">       &#123;</span><br><span class="line">           UIManager.Instance.connectText.text += System.Text.Encoding.UTF8.GetString(buffer, <span class="number">0</span>, length);<span class="comment">//显示接收到的数据</span></span><br><span class="line">       &#125;);</span><br><span class="line">       socket.BeginReceive(buffer, <span class="number">0</span>, buffer.Length, <span class="number">0</span>, ReceiveCallback, socket);<span class="comment">//再次接收数据</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure> 重要的知识点来了!<br />Unity里的UI组件或者是其他仅仅存活于Unity生命周期中的组件，只在Unity主线程内执行<br />由此引出了消息队列的妙用，请看GameManager.cs<br /><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Queue&lt;Action&gt; messageQueue = <span class="keyword">new</span> Queue&lt;Action&gt;();<span class="comment">//消息队列</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(messageQueue.Count&gt;<span class="number">0</span>)<span class="comment">//如果消息队列中有消息</span></span><br><span class="line">       &#123;</span><br><span class="line">           messageQueue<span class="comment">//消息队列</span></span><br><span class="line">           .Dequeue()<span class="comment">//从队列中取出消息</span></span><br><span class="line">           .Invoke();<span class="comment">//执行队列中的消息</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure> 到这里，我们的前端设计就基本完成了，来看看后端设计吧 ## 后端设计 后端设计就是服务器端的设计，这里我们使用C#的Socket类来实现<br /><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Net.Sockets;</span><br><span class="line"><span class="keyword">using</span> System.Net;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChattingServer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Socket socket;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        socket = <span class="keyword">new</span> Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);</span><br><span class="line">        socket.Bind(<span class="keyword">new</span> IPEndPoint(IPAddress.Any, <span class="number">10010</span>));<span class="comment">//IPAddress.Any代表本机上的所有IP地址；socket.Bind(EndPoint) 方法使 Socket 与一个本地终结点相关联。</span></span><br><span class="line">        socket.Listen(<span class="number">0</span>);<span class="comment">//监听任意多个客户端</span></span><br><span class="line">        socket.BeginAccept(AcceptCallback, socket);</span><br><span class="line">        System.Console.WriteLine(<span class="string">&quot;Server is running...&quot;</span>);</span><br><span class="line">        System.Console.ReadLine();<span class="comment">//阻塞主线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 还有我们需要用到的回调函数 <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AcceptCallback</span>(<span class="params">System.IAsyncResult ar</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       Socket socket = ar.AsyncState <span class="keyword">as</span> Socket;<span class="comment">//获取传入的socket</span></span><br><span class="line">       Socket client = socket.EndAccept(ar);<span class="comment">//获取连接的客户端socket</span></span><br><span class="line">       System.Console.WriteLine(<span class="string">&quot;Client connected&quot;</span>);</span><br><span class="line">       ClientInfo clientInfo = <span class="keyword">new</span> ClientInfo(client);<span class="comment">//创建客户端信息</span></span><br><span class="line">       clientList.Add(clientInfo);<span class="comment">//添加到客户端列表</span></span><br><span class="line">       client.BeginReceive(clientInfo.readBuff, <span class="number">0</span>, <span class="number">1024</span>, <span class="number">0</span>, ReceiveCallback, clientInfo);<span class="comment">//开始接收数据</span></span><br><span class="line">       socket.BeginAccept(AcceptCallback, socket);<span class="comment">//再次监听</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReceiveCallback</span>(<span class="params">System.IAsyncResult ar</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       ClientInfo info = ar.AsyncState <span class="keyword">as</span> ClientInfo;<span class="comment">//获取传入的客户端信息</span></span><br><span class="line">       <span class="built_in">int</span> count = info.socket.EndReceive(ar);<span class="comment">//获取接收到的数据长度</span></span><br><span class="line">       <span class="keyword">foreach</span> (ClientInfo c <span class="keyword">in</span> clientList)<span class="comment">//遍历客户端列表</span></span><br><span class="line">       &#123;</span><br><span class="line">           c.socket.Send(info.readBuff,<span class="number">0</span>,count,<span class="number">0</span>);<span class="comment">//转发给所有客户端</span></span><br><span class="line">       &#125;</span><br><span class="line">       info.socket.BeginReceive(info.readBuff, <span class="number">0</span>, <span class="number">1024</span>, <span class="number">0</span>, ReceiveCallback, info);<span class="comment">//再次接收数据</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure> 这里建立了一个 ClientInfo 类用于管理数据和客户端 socket. 非常方便 <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ClientInfo</span><span class="comment">//客户端信息</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">public</span> Socket socket;<span class="comment">//客户端socket</span></span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">byte</span>[] readBuff = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">1024</span>];<span class="comment">//接收缓冲区</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">ClientInfo</span>(<span class="params">Socket socket</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">this</span>.socket = socket;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure> 当然，聊天室不是一个人的网络备忘录，必然会出现多个客户端链接的情况，所以有必要new 一个 List 存储客户端信息。 <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;ClientInfo&gt; clientList = <span class="keyword">new</span> List&lt;ClientInfo&gt;();<span class="comment">//客户端列表</span></span><br></pre></td></tr></table></figure></p><table style="width:6%;"><colgroup><col style="width: 5%" /></colgroup><tbody><tr class="odd"><td>到这里，Jason网络聊天室的基本功能就实现了。</td></tr></tbody></table><p>本文作于2023-08-12，首发于个人博客<a href="https://rdququ.top/" class="uri">https://rdququ.top/</a></p>]]></content>
      
      
      <categories>
          
          <category> 记录向 </category>
          
          <category> Unity </category>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 服务端 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 网络编程 </tag>
            
            <tag> 聊天室 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>导入Qframework框架</title>
      <link href="/posts/3cab5535/"/>
      <url>/posts/3cab5535/</url>
      
        <content type="html"><![CDATA[<p>QFramework是凉鞋大大开发的一款开箱即用的 Unity 开发框架，其内置了 Res Kit、UI Kit、Audio 以及常用的工具库<br /><span id="more"></span> Qframework 官方地址如下 https://qframework.cn/qf<br />Qframework 官方教程如下 https://www.gamepixedu.com/my/course/50<br />## Unity如何导入Qframework 主体包地址： https://qframework.cn/qf/package/detail/17e600f8-c6fa-4fdf-a77e-843e28627e2f<br />下载获取Unitypackage,导入项目中即可<br />这个包里面是由三部分组成的 QFramework.cs,Toolkits 和教程示例文件<br />如果只关心 QFramework 的架构实现，那么不需要导入 Toolkits 内的内容<br />在Unity中按下 CTRL+E 可以快捷唤出 QFramework 设置</p><hr /><p>首发于2023-08-11</p><p>地址 ：https://rdququ.top/</p>]]></content>
      
      
      <categories>
          
          <category> 资料向 </category>
          
          <category> Unity </category>
          
          <category> 框架 </category>
          
          <category> QFramework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 环境配置 </tag>
            
            <tag> QFramework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服了你了‘hexo-asset-image’</title>
      <link href="/posts/1eafb1c0/"/>
      <url>/posts/1eafb1c0/</url>
      
        <content type="html"><![CDATA[<p>今天写了下“Unity环境配置和外部工具食用指南”给新人，结果插入图片（引用本地文件）的时候出问题了，博客上怎么也显示不出来。博主就去查，发现是hexo-asset-image这个插件的bug。这个链接是解决方案<a href="https://blog.csdn.net/xjm850552586/article/details/84101345" class="uri">https://blog.csdn.net/xjm850552586/article/details/84101345</a><br /><span id="more"></span><br />其实正常读取文件应该这么写： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img example.jpg This is an example image %&#125;</span><br></pre></td></tr></table></figure> 但是博主觉得麻烦，就打算抛弃hexo-asset-image了，转而投向hexo-renderer-marked的怀抱，直接下载他 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-marked</span><br></pre></td></tr></table></figure> 站点配置文件也改一下 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br><span class="line">marked:</span><br><span class="line">  prependRoot: true</span><br><span class="line">  postAsset: true</span><br></pre></td></tr></table></figure> 大功告成，图片正常显示了。<br />值得注意的是，markdown里链接本地图片是这么写的 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](folder/image.jpg)</span><br></pre></td></tr></table></figure> 但是由于hexo会把我们的图片和html文件放在一个文件夹，所以“folder/”还是删掉吧，但是这样在md编辑器里我们就预览不了图片了，真是有得必有失啊。（至少vscode是这样的）博主还是找找vscode有没有相关插件吧。</p><figure><img src="示例图.png" alt="示例图" /><figcaption aria-hidden="true">示例图</figcaption></figure><hr /><p>本文作于2023-08-07，首发于个人博客<a href="https://rdququ.top/" class="uri">https://rdququ.top/</a></p>]]></content>
      
      
      <categories>
          
          <category> 答疑向 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
            <tag> 坑 </tag>
            
            <tag> Blog </tag>
            
            <tag> markdown </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity环境配置和外部工具食用指南</title>
      <link href="/posts/a1059d05/"/>
      <url>/posts/a1059d05/</url>
      
        <content type="html"><![CDATA[<h2 id="怎么下载unity">怎么下载Unity</h2><p>Unity中国官网: https://unity.cn/<br />### 注册Unity ID 无论是选择用邮箱还是用手机号码，Unity都会要求你接受手机验证码，这时候部分号码可能会接收不到验证码，如果连续三次出现这种情况，不要犹豫，换个号码就行，不需要使用接码平台。后续的登录使用邮箱就可以了。 <span id="more"></span> ### 下载Unity Hub 点右上角的下载Unity,再点击页面中的绿色按钮“下载Unity Hub”，选择对应的版本即可。 ### 下载Unity 打开Hub,如果没有登录先登录。点击你的头像，再点击里面的管理许可证，拿到免费的个人版许可证。<br /><img src="许可证.png" title="许可证" alt="许可证" /><br />中文设置： <img src="Hub中文.png" title="Hub中文" alt="Hub中文" /> 在此之后点击左侧边栏的安装，选择2022.3.4f1c1安装即可，也可以根据个人喜好选择其他版本，过高或者过低的版本可能会有各种不适配的问题。(其实可以多装几个版本，如果你的磁盘空间够大的话)<br />安装的页面，除了最下面的简体中文语言包可以勾选，其他都没必要勾，以后要用可以再额外安装。 <img src="安装unity.png" title="安装unity" alt="安装unity" /></p><h2 id="怎么配置unity">怎么配置Unity</h2><h3 id="vs2022">VS2022</h3><p>学校里的课程教的使用vs2010啊，当然我们实际开发时不可能使用vs2010的。出于方便易上手考虑，先讲一下vs2022的Unity配置，非常简单，下载的时候勾选一下这个就行 <img src="vs2022.png" title="vs2022" alt="vs2022" /></p><h3 id="vscode">vscode</h3><p>vscode是很强大的文本编辑器，这里我们也介绍一下。主要下载这些插件： <img src="vscode插件1.png" title="vscode插件" alt="vscode插件" /> <img src="vscode插件2.png" title="vscode插件" alt="vscode插件" /> <img src="vscode插件3.png" title="vscode插件" alt="vscode插件" /><br />中文插件搜Chinese就行，不过多介绍</p><h3 id="配置unity">配置Unity</h3><p>先随便打开一个项目 看左上角的Edit，他下面有个Preferences，打开之后看图 <img src="Unity语言.png" title="Unity语言" alt="Unity语言" /> <img src="外部工具.png" title="外部工具" alt="外部工具" /> external script editor（就是第一个）选择你喜欢的就行（vs2022/vscode）</p><table style="width:6%;"><colgroup><col style="width: 5%" /></colgroup><tbody><tr class="odd"><td>Unity环境配置好了，开启你的游戏开发之旅吧</td></tr></tbody></table><p>本文作于2023-08-07，首发于个人博客<a href="https://rdququ.top/" class="uri">https://rdququ.top/</a></p>]]></content>
      
      
      <categories>
          
          <category> 资料向 </category>
          
          <category> 环境配置 </category>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 环境配置 </tag>
            
            <tag> vscode </tag>
            
            <tag> vs2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【制趣交流团】蛐蛐-南邮华夜《大战略游戏的叙事玩法设计》</title>
      <link href="/posts/363fd8a8/"/>
      <url>/posts/363fd8a8/</url>
      
        <content type="html"><![CDATA[<p>这个是博主2023年8月2号晚上8点到9点在吉比特制趣联盟的第22期制趣交流团上做的分享。主要分享了大战略游戏中独特的叙事玩法设计和一些叙事理论。<br /><span id="more"></span> #### 参考资料 - https://www.researchgate.net/publication/371984492_Managing_the_Plot_Structure_of_Character-based_Interactive_Narratives_in_Games - https://www.researchgate.net/publication/228361928_Authoring_emergent_narrative-based_games - https://www.researchgate.net/publication/254006015_A_narrative_theory_of_games 都是researchgate上面开源的文章，需要的可以自行下载。<br />下面放一下视频外链吧</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=231893217&bvid=BV198411d7wd&cid=1224927176&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><hr /><p>本文作于2023-08-06，首发于个人博客<a href="https://rdququ.top/" class="uri">https://rdququ.top/</a></p>]]></content>
      
      
      <categories>
          
          <category> 分享向 </category>
          
          <category> 游戏设计理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大战略 </tag>
            
            <tag> 游戏设计 </tag>
            
            <tag> 叙事 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可恶的百度推送bug</title>
      <link href="/posts/b0763a45/"/>
      <url>/posts/b0763a45/</url>
      
        <content type="html"><![CDATA[<p>事情是这样的，这天博主吃着盐水鸭改着代码，突然发现 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure> 报错了，以下是报错信息 <span id="more"></span> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FATAL Something&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html</span><br><span class="line">TypeError: Cannot read properties of undefined (reading &#x27;count&#x27;)</span><br><span class="line">    at module.exports (H:\Blog\node_modules\hexo-baidu-url-submit\lib\generator.js:4:41)</span><br><span class="line">    at Hexo.tryCatcher (H:\Blog\node_modules\bluebird\js\release\util.js:16:23)</span><br><span class="line">    at Hexo.&lt;anonymous&gt; (H:\Blog\node_modules\bluebird\js\release\method.js:15:34)</span><br><span class="line">    at H:\Blog\node_modules\hexo\lib\hexo\index.js:407:22</span><br><span class="line">    at tryCatcher (H:\Blog\node_modules\bluebird\js\release\util.js:16:23)</span><br><span class="line">    at MappingPromiseArray._promiseFulfilled (H:\Blog\node_modules\bluebird\js\release\map.js:68:38)</span><br><span class="line">    at PromiseArray._iterate (H:\Blog\node_modules\bluebird\js\release\promise_array.js:115:31)</span><br><span class="line">    at MappingPromiseArray.init (H:\Blog\node_modules\bluebird\js\release\promise_array.js:79:10)</span><br><span class="line">    at MappingPromiseArray._asyncInit (H:\Blog\node_modules\bluebird\js\release\map.js:37:10)</span><br><span class="line">    at _drainQueueStep (H:\Blog\node_modules\bluebird\js\release\async.js:97:12)</span><br><span class="line">    at _drainQueue (H:\Blog\node_modules\bluebird\js\release\async.js:86:9)</span><br><span class="line">    at Async._drainQueues (H:\Blog\node_modules\bluebird\js\release\async.js:102:5)</span><br><span class="line">    at Async.drainQueues [as _onImmediate] (H:\Blog\node_modules\bluebird\js\release\async.js:15:14)</span><br><span class="line">    at process.processImmediate (node:internal/timers:476:21)</span><br><span class="line"></span><br></pre></td></tr></table></figure> 一眼就看到里面显眼的 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(H:\Blog\node_modules\hexo-baidu-url-submit\lib\generator.js:4:41)</span><br></pre></td></tr></table></figure> 于是上网去搜，果然发现了和博主一样的倒霉蛋 链接在这里<a href="https://github.com/hexojs/hexo/issues/2402" class="uri">https://github.com/hexojs/hexo/issues/2402</a><br />看来确实是百度推送的插件有问题<br />于是博主一通操作 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm remove hexo-baidu-url-submit</span><br></pre></td></tr></table></figure> 问题解决。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g --debug</span><br></pre></td></tr></table></figure> 你定位问题的好帮手</p><hr /><p>首发于2023-08-06</p><p>地址 ：https://rdququ.top/</p>]]></content>
      
      
      <categories>
          
          <category> 答疑向 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 坑 </tag>
            
            <tag> Blog </tag>
            
            <tag> 百度推送 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unity协程（corounines）学习理解兼迭代器学习，异步多任务处理</title>
      <link href="/posts/65271aca/"/>
      <url>/posts/65271aca/</url>
      
        <content type="html"><![CDATA[<h2 id="一.协程学习的前置知识">一.协程学习的前置知识</h2><h3 id="迭代器">迭代器</h3><p>迭代器是一种用于简化循环结构的语法糖，它可以让我们通过一种更加简洁、优雅的方式来遍历一个集合或者执行一些需要多次迭代的操作。</p><p>在Unity中，迭代器的基本语法是使用yield return语句。yield return语句用于暂停迭代器的执行，并返回一个值或对象。</p><p>下面是一个使用迭代器的例子： <span id="more"></span> <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">MyIterator</span>()</span> &#123;</span><br><span class="line">    Debug.Log(<span class="string">&quot;Start&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1.0f</span></span>)</span>;</span><br><span class="line">    Debug.Log(<span class="string">&quot;1 second later&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">2.0f</span></span>)</span>;</span><br><span class="line">    Debug.Log(<span class="string">&quot;2 seconds later&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 二.协程的入口 协程必须以IEnumerator开始，并且方法中必须包含关键字yield return，下面我们给出一个协程和普通程序的对比： <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">PrintDebug</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//暂时挂起程序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintDebug</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 这时我们想要调用我们的协程就需要用到以下的代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StartCoroutine(PrintNum());</span><br></pre></td></tr></table></figure><h3 id="关键字yield-return">关键字yield return</h3><p>yield return的作用是将我们的程序暂时挂起，满足部分条件之后再执行</p><p>下面是一些例子： <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//下一帧以后执行后续代码</span></span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//这里可以不是零，甚至可以是任意数字，效果同上</span></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="title">StartCoroutine</span>(<span class="params">MyCoroutine(<span class="number">1</span></span>))</span>;<span class="comment">//等待协程MyCoroutine(1)完成</span></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1</span></span>)</span>; <span class="comment">// 暂停协程1秒钟,受到DeletaTime影响</span></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSecondsRealtime</span>(<span class="params"><span class="number">1</span></span>)</span>;<span class="comment">//不受到DeletaTime影响</span></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForFixedUpdate</span>()</span>; <span class="comment">// 等待下一个FixedUpdate消息</span></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForEndOfFrame</span>()</span>; <span class="comment">// 等待下一个渲染帧的结束</span></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitUntil</span>(<span class="params">(</span>)</span> =&gt; oneSecond&gt;<span class="number">1</span>);<span class="comment">//等到某判断条件为真时</span></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitWhile</span>(<span class="params">(</span>)</span> =&gt; oneSecond&gt;<span class="number">1</span>);<span class="comment">//等到某判断条件为假时</span></span><br><span class="line"></span><br><span class="line">AsyncOperation <span class="keyword">async</span> = SceneManager.LoadSceneAsync(<span class="string">&quot;SceneName&quot;</span>);<span class="comment">//暂停协程，异步场景加载</span></span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">async</span>; <span class="comment">// 等待场景加载完成</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">break</span>;<span class="comment">//直接终止，类似于return操作</span></span><br></pre></td></tr></table></figure> 不仅如此，你甚至能使用自定义的yield return，请看代码 <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyYieldInstruction</span> : <span class="title">CustomYieldInstruction</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> isFinished = <span class="literal">false</span>; <span class="comment">// 是否完成的标志位</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> keepWaiting &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> !isFinished; <span class="comment">// 当未完成时，协程继续等待</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Finish</span>()</span> &#123;</span><br><span class="line">        isFinished = <span class="literal">true</span>; <span class="comment">// 设置完成标志位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 众所周知，自定义yield return类型需要满足以下两个条件：</p><ul><li><p>继承自Unity的CustomYieldInstruction类。</p></li><li><p>实现keepWaiting属性，该属性的返回值控制协程是否继续等待。</p></li></ul><p>在上面的示例中，MyYieldInstruction类继承自CustomYieldInstruction类，并实现了keepWaiting属性和Finish方法。在MyYieldInstruction类中，我们使用isFinished变量表示自定义的操作是否完成。在keepWaiting属性中，当isFinished为false时，协程将继续等待；当isFinished为true时，协程将不再等待，继续执行后面的代码。</p><p>以下的代码会告诉你该如何使用前面我们自定义的yield return <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">MyCoroutine</span>()</span> &#123;</span><br><span class="line">    Debug.Log(<span class="string">&quot;Start&quot;</span>);</span><br><span class="line">    MyYieldInstruction myYield = <span class="keyword">new</span> MyYieldInstruction();</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> myYield;</span><br><span class="line">    Debug.Log(<span class="string">&quot;Finish&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">MyCoroutine coroutine = StartCoroutine(MyCoroutine());</span><br><span class="line">coroutine.Stop(); <span class="comment">// 可以通过Stop方法提前终止协程</span></span><br></pre></td></tr></table></figure> 值得注意的是，在使用自定义yield return类型时，需要特别注意协程的终止条件，以避免出现不可预期的结果。 ### StartCoroutine语句 <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StartCoroutine(方法)；</span><br><span class="line">StartCoroutine(方法名)；</span><br></pre></td></tr></table></figure> StartCoroutine的返回值类型是IEnumerator</p><p>注意：StartCoroutine语句只能在MonoBehaviour派生类的方法中使用，因为协程依赖于Unity的消息循环机制。 ## 三.协程的结束 <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StopCoroutine(方法)；</span><br><span class="line">StopAllCoroutine()；</span><br></pre></td></tr></table></figure> ## 四.迭代器与协程的区别 迭代器（Iterator）和协程（Coroutine）在Unity中都用于异步操作，但它们在实现和使用上有一些区别。</p><ol type="1"><li>实现方式不同</li></ol><p>迭代器是一种基于枚举器（Enumerator）实现的语法，通过yield return语句实现协程的暂停和恢复。在编写迭代器时，需要实现IEnumerator和IEnumerable接口，并实现MoveNext、Reset和Current等方法。</p><p>协程是一种基于IEnumerator实现的语法，通过StartCoroutine和yield return语句实现协程的启动和暂停。在编写协程时，需要定义一个返回值为IEnumerator类型的方法，并使用yield return语句来暂停协程的执行。</p><ol type="1"><li>使用方式不同</li></ol><p>迭代器通常用于实现可枚举类型的遍历，可以通过foreach语句进行遍历操作。在协程中，迭代器通常用于实现异步操作，例如延迟执行、动画效果等。</p><p>协程通常用于实现异步操作，可以通过StartCoroutine语句启动协程，并使用yield return语句实现协程的暂停和恢复。协程可以通过yield return语句实现延迟执行、分步执行、等待操作完成等功能。</p><ol type="1"><li>执行顺序不同</li></ol><p>迭代器的执行顺序是在同一线程中顺序执行，即在迭代器中的每个yield return语句执行完毕后，才会执行下一个yield return语句或方法的其他部分。</p><p>协程的执行顺序是异步的，即在协程执行过程中可以执行其他代码。协程的执行可以被暂停和恢复，可以实现延迟执行、动画效果、等待操作完成等功能。</p><hr /><p>本文作于2023-03-19，首发于CSDN <a href="https://blog.csdn.net/jubunihuan/article/details/129652810" class="uri">https://blog.csdn.net/jubunihuan/article/details/129652810</a></p>]]></content>
      
      
      <categories>
          
          <category> 资料向 </category>
          
          <category> 语法 </category>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> C# </tag>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156/"/>
      <url>/posts/4a17b156/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>. <span id="more"></span> ## Quick Start</p><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
