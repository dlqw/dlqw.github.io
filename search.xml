<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>服了你了‘hexo-asset-image’</title>
      <link href="/2023/08/07/%E6%9C%8D%E4%BA%86%E4%BD%A0%E4%BA%86%E2%80%98hexo-asset-image%E2%80%99/"/>
      <url>/2023/08/07/%E6%9C%8D%E4%BA%86%E4%BD%A0%E4%BA%86%E2%80%98hexo-asset-image%E2%80%99/</url>
      
        <content type="html"><![CDATA[<p>今天写了下“Unity环境配置和外部工具食用指南”给新人，结果插入图片（引用本地文件）的时候出问题了，博客上怎么也显示不出来。博主就去查，发现是hexo-asset-image这个插件的bug。这个链接是解决方案<a href="https://blog.csdn.net/xjm850552586/article/details/84101345">https://blog.csdn.net/xjm850552586/article/details/84101345</a><br> <span id="more"></span><br>其实正常读取文件应该这么写： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img example.jpg This is an example image %&#125;</span><br></pre></td></tr></table></figure><p>但是博主觉得麻烦，就打算抛弃hexo-asset-image了，转而投向hexo-renderer-marked的怀抱，直接下载他</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-marked</span><br></pre></td></tr></table></figure><p>站点配置文件也改一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br><span class="line">marked:</span><br><span class="line">  prependRoot: true</span><br><span class="line">  postAsset: true</span><br></pre></td></tr></table></figure><p>大功告成，图片正常显示了。<br>值得注意的是，markdown里链接本地图片是这么写的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](folder/image.jpg)</span><br></pre></td></tr></table></figure><p>但是由于hexo会把我们的图片和html文件放在一个文件夹，所以“folder&#x2F;”还是删掉吧，但是这样在md编辑器里我们就预览不了图片了，真是有得必有失啊。（至少vscode是这样的）博主还是找找vscode有没有相关插件吧。  </p><p><img src="/2023/08/07/%E6%9C%8D%E4%BA%86%E4%BD%A0%E4%BA%86%E2%80%98hexo-asset-image%E2%80%99/%E7%A4%BA%E4%BE%8B%E5%9B%BE.png" alt="示例图">  </p><hr><p>本文作于2023-08-07，首发于个人博客<a href="https://rdququ.top/">https://rdququ.top/</a></p>]]></content>
      
      
      <categories>
          
          <category> 答疑向 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
            <tag> 坑 </tag>
            
            <tag> Blog </tag>
            
            <tag> markdown </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity环境配置和外部工具食用指南</title>
      <link href="/2023/08/07/Unity%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%A4%96%E9%83%A8%E5%B7%A5%E5%85%B7%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2023/08/07/Unity%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%A4%96%E9%83%A8%E5%B7%A5%E5%85%B7%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="怎么下载Unity"><a href="#怎么下载Unity" class="headerlink" title="怎么下载Unity"></a>怎么下载Unity</h2><p>Unity中国官网: <a href="https://unity.cn/">https://unity.cn/</a>  </p><h3 id="注册Unity-ID"><a href="#注册Unity-ID" class="headerlink" title="注册Unity ID"></a>注册Unity ID</h3><p>无论是选择用邮箱还是用手机号码，Unity都会要求你接受手机验证码，这时候部分号码可能会接收不到验证码，如果连续三次出现这种情况，不要犹豫，换个号码就行，不需要使用接码平台。后续的登录使用邮箱就可以了。<br> <span id="more"></span></p><h3 id="下载Unity-Hub"><a href="#下载Unity-Hub" class="headerlink" title="下载Unity Hub"></a>下载Unity Hub</h3><p>点右上角的下载Unity,再点击页面中的绿色按钮“下载Unity Hub”，选择对应的版本即可。</p><h3 id="下载Unity"><a href="#下载Unity" class="headerlink" title="下载Unity"></a>下载Unity</h3><p>打开Hub,如果没有登录先登录。点击你的头像，再点击里面的管理许可证，拿到免费的个人版许可证。<br><img src="/2023/08/07/Unity%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%A4%96%E9%83%A8%E5%B7%A5%E5%85%B7%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/%E8%AE%B8%E5%8F%AF%E8%AF%81.png" alt="许可证" title="许可证"><br>中文设置：<br><img src="/2023/08/07/Unity%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%A4%96%E9%83%A8%E5%B7%A5%E5%85%B7%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/Hub%E4%B8%AD%E6%96%87.png" alt="Hub中文" title="Hub中文"><br>在此之后点击左侧边栏的安装，选择2022.3.4f1c1安装即可，也可以根据个人喜好选择其他版本，过高或者过低的版本可能会有各种不适配的问题。(其实可以多装几个版本，如果你的磁盘空间够大的话)<br>安装的页面，除了最下面的简体中文语言包可以勾选，其他都没必要勾，以后要用可以再额外安装。<br><img src="/2023/08/07/Unity%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%A4%96%E9%83%A8%E5%B7%A5%E5%85%B7%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/%E5%AE%89%E8%A3%85unity.png" alt="安装unity" title="安装unity"></p><h2 id="怎么配置Unity"><a href="#怎么配置Unity" class="headerlink" title="怎么配置Unity"></a>怎么配置Unity</h2><h3 id="VS2022"><a href="#VS2022" class="headerlink" title="VS2022"></a>VS2022</h3><p>学校里的课程教的使用vs2010啊，当然我们实际开发时不可能使用vs2010的。出于方便易上手考虑，先讲一下vs2022的Unity配置，非常简单，下载的时候勾选一下这个就行<br><img src="/2023/08/07/Unity%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%A4%96%E9%83%A8%E5%B7%A5%E5%85%B7%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/vs2022.png" alt="vs2022" title="vs2022"></p><h3 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h3><p>vscode是很强大的文本编辑器，这里我们也介绍一下。主要下载这些插件：<br><img src="/2023/08/07/Unity%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%A4%96%E9%83%A8%E5%B7%A5%E5%85%B7%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/vscode%E6%8F%92%E4%BB%B61.png" alt="vscode插件" title="vscode插件"><br><img src="/2023/08/07/Unity%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%A4%96%E9%83%A8%E5%B7%A5%E5%85%B7%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/vscode%E6%8F%92%E4%BB%B62.png" alt="vscode插件" title="vscode插件"><br><img src="/2023/08/07/Unity%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%A4%96%E9%83%A8%E5%B7%A5%E5%85%B7%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/vscode%E6%8F%92%E4%BB%B63.png" alt="vscode插件" title="vscode插件"><br>中文插件搜Chinese就行，不过多介绍</p><h3 id="配置Unity"><a href="#配置Unity" class="headerlink" title="配置Unity"></a>配置Unity</h3><p>先随便打开一个项目<br>看左上角的Edit，他下面有个Preferences，打开之后看图<br><img src="/2023/08/07/Unity%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%A4%96%E9%83%A8%E5%B7%A5%E5%85%B7%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/Unity%E8%AF%AD%E8%A8%80.png" alt="Unity语言" title="Unity语言"><br><img src="/2023/08/07/Unity%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%A4%96%E9%83%A8%E5%B7%A5%E5%85%B7%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/%E5%A4%96%E9%83%A8%E5%B7%A5%E5%85%B7.png" alt="外部工具" title="外部工具"><br>external script editor（就是第一个）选择你喜欢的就行（vs2022&#x2F;vscode） </p><hr><p>Unity环境配置好了，开启你的游戏开发之旅吧</p><hr><p>本文作于2023-08-07，首发于个人博客<a href="https://rdququ.top/">https://rdququ.top/</a></p>]]></content>
      
      
      <categories>
          
          <category> 资料向 </category>
          
          <category> 环境配置 </category>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 环境配置 </tag>
            
            <tag> vscode </tag>
            
            <tag> vs2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【制趣交流团】蛐蛐-南邮华夜《大战略游戏的叙事玩法设计》</title>
      <link href="/2023/08/06/%E3%80%90%E5%88%B6%E8%B6%A3%E4%BA%A4%E6%B5%81%E5%9B%A2%E3%80%91%E8%9B%90%E8%9B%90-%E5%8D%97%E9%82%AE%E5%8D%8E%E5%A4%9C%E3%80%8A%E5%A4%A7%E6%88%98%E7%95%A5%E6%B8%B8%E6%88%8F%E7%9A%84%E5%8F%99%E4%BA%8B%E7%8E%A9%E6%B3%95%E8%AE%BE%E8%AE%A1%E3%80%8B/"/>
      <url>/2023/08/06/%E3%80%90%E5%88%B6%E8%B6%A3%E4%BA%A4%E6%B5%81%E5%9B%A2%E3%80%91%E8%9B%90%E8%9B%90-%E5%8D%97%E9%82%AE%E5%8D%8E%E5%A4%9C%E3%80%8A%E5%A4%A7%E6%88%98%E7%95%A5%E6%B8%B8%E6%88%8F%E7%9A%84%E5%8F%99%E4%BA%8B%E7%8E%A9%E6%B3%95%E8%AE%BE%E8%AE%A1%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<p>这个是博主2023年8月2号晚上8点到9点在吉比特制趣联盟的第22期制趣交流团上做的分享。主要分享了大战略游戏中独特的叙事玩法设计和一些叙事理论。<br> <span id="more"></span></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://www.researchgate.net/publication/371984492_Managing_the_Plot_Structure_of_Character-based_Interactive_Narratives_in_Games">https://www.researchgate.net/publication/371984492_Managing_the_Plot_Structure_of_Character-based_Interactive_Narratives_in_Games</a></li><li><a href="https://www.researchgate.net/publication/228361928_Authoring_emergent_narrative-based_games">https://www.researchgate.net/publication/228361928_Authoring_emergent_narrative-based_games</a></li><li><a href="https://www.researchgate.net/publication/254006015_A_narrative_theory_of_games">https://www.researchgate.net/publication/254006015_A_narrative_theory_of_games</a><br>都是researchgate上面开源的文章，需要的可以自行下载。<br>下面放一下视频外链吧</li></ul><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=231893217&bvid=BV198411d7wd&cid=1224927176&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><hr><p>本文作于2023-08-06，首发于个人博客<a href="https://rdququ.top/">https://rdququ.top/</a></p>]]></content>
      
      
      <categories>
          
          <category> 分享向 </category>
          
          <category> 游戏设计理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大战略 </tag>
            
            <tag> 游戏设计 </tag>
            
            <tag> 叙事 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可恶的百度推送bug</title>
      <link href="/2023/08/06/%E5%8F%AF%E6%81%B6%E7%9A%84%E7%99%BE%E5%BA%A6%E6%8E%A8%E9%80%81bug/"/>
      <url>/2023/08/06/%E5%8F%AF%E6%81%B6%E7%9A%84%E7%99%BE%E5%BA%A6%E6%8E%A8%E9%80%81bug/</url>
      
        <content type="html"><![CDATA[<p>事情是这样的，这天博主吃着盐水鸭改着代码，突然发现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>报错了，以下是报错信息</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FATAL Something&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html</span><br><span class="line">TypeError: Cannot read properties of undefined (reading &#x27;count&#x27;)</span><br><span class="line">    at module.exports (H:\Blog\node_modules\hexo-baidu-url-submit\lib\generator.js:4:41)</span><br><span class="line">    at Hexo.tryCatcher (H:\Blog\node_modules\bluebird\js\release\util.js:16:23)</span><br><span class="line">    at Hexo.&lt;anonymous&gt; (H:\Blog\node_modules\bluebird\js\release\method.js:15:34)</span><br><span class="line">    at H:\Blog\node_modules\hexo\lib\hexo\index.js:407:22</span><br><span class="line">    at tryCatcher (H:\Blog\node_modules\bluebird\js\release\util.js:16:23)</span><br><span class="line">    at MappingPromiseArray._promiseFulfilled (H:\Blog\node_modules\bluebird\js\release\map.js:68:38)</span><br><span class="line">    at PromiseArray._iterate (H:\Blog\node_modules\bluebird\js\release\promise_array.js:115:31)</span><br><span class="line">    at MappingPromiseArray.init (H:\Blog\node_modules\bluebird\js\release\promise_array.js:79:10)</span><br><span class="line">    at MappingPromiseArray._asyncInit (H:\Blog\node_modules\bluebird\js\release\map.js:37:10)</span><br><span class="line">    at _drainQueueStep (H:\Blog\node_modules\bluebird\js\release\async.js:97:12)</span><br><span class="line">    at _drainQueue (H:\Blog\node_modules\bluebird\js\release\async.js:86:9)</span><br><span class="line">    at Async._drainQueues (H:\Blog\node_modules\bluebird\js\release\async.js:102:5)</span><br><span class="line">    at Async.drainQueues [as _onImmediate] (H:\Blog\node_modules\bluebird\js\release\async.js:15:14)</span><br><span class="line">    at process.processImmediate (node:internal/timers:476:21)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一眼就看到里面显眼的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(H:\Blog\node_modules\hexo-baidu-url-submit\lib\generator.js:4:41)</span><br></pre></td></tr></table></figure><p>于是上网去搜，果然发现了和博主一样的倒霉蛋<br>链接在这里<a href="https://github.com/hexojs/hexo/issues/2402">https://github.com/hexojs/hexo/issues/2402</a><br>看来确实是百度推送的插件有问题<br>于是博主一通操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm remove hexo-baidu-url-submit</span><br></pre></td></tr></table></figure><p>问题解决。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g --debug</span><br></pre></td></tr></table></figure><p>你定位问题的好帮手</p><hr><p>首发于2023-08-06 </p><p>地址 ：<a href="https://rdququ.top/">https://rdququ.top/</a></p>]]></content>
      
      
      <categories>
          
          <category> 答疑向 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 坑 </tag>
            
            <tag> Blog </tag>
            
            <tag> 百度推送 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unity协程（corounines）学习理解兼迭代器学习，异步多任务处理</title>
      <link href="/2023/08/05/unity%E5%8D%8F%E7%A8%8B%EF%BC%88corounines%EF%BC%89%E5%AD%A6%E4%B9%A0%E7%90%86%E8%A7%A3%E5%85%BC%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%8C%E5%BC%82%E6%AD%A5%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86/"/>
      <url>/2023/08/05/unity%E5%8D%8F%E7%A8%8B%EF%BC%88corounines%EF%BC%89%E5%AD%A6%E4%B9%A0%E7%90%86%E8%A7%A3%E5%85%BC%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%8C%E5%BC%82%E6%AD%A5%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="一-协程学习的前置知识"><a href="#一-协程学习的前置知识" class="headerlink" title="一.协程学习的前置知识"></a>一.协程学习的前置知识</h2><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器是一种用于简化循环结构的语法糖，它可以让我们通过一种更加简洁、优雅的方式来遍历一个集合或者执行一些需要多次迭代的操作。</p><p>在Unity中，迭代器的基本语法是使用yield return语句。yield return语句用于暂停迭代器的执行，并返回一个值或对象。</p><p>下面是一个使用迭代器的例子：<br> <span id="more"></span></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">MyIterator</span>()</span> &#123;</span><br><span class="line">    Debug.Log(<span class="string">&quot;Start&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1.0f</span></span>)</span>;</span><br><span class="line">    Debug.Log(<span class="string">&quot;1 second later&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">2.0f</span></span>)</span>;</span><br><span class="line">    Debug.Log(<span class="string">&quot;2 seconds later&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-协程的入口"><a href="#二-协程的入口" class="headerlink" title="二.协程的入口"></a>二.协程的入口</h2><p>协程必须以IEnumerator开始，并且方法中必须包含关键字yield return，下面我们给出一个协程和普通程序的对比：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">PrintDebug</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//暂时挂起程序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintDebug</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时我们想要调用我们的协程就需要用到以下的代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StartCoroutine(PrintNum());</span><br></pre></td></tr></table></figure><h3 id="关键字yield-return"><a href="#关键字yield-return" class="headerlink" title="关键字yield return"></a>关键字yield return</h3><p>yield return的作用是将我们的程序暂时挂起，满足部分条件之后再执行</p><p>下面是一些例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//下一帧以后执行后续代码</span></span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//这里可以不是零，甚至可以是任意数字，效果同上</span></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="title">StartCoroutine</span>(<span class="params">MyCoroutine(<span class="number">1</span></span>))</span>;<span class="comment">//等待协程MyCoroutine(1)完成</span></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1</span></span>)</span>; <span class="comment">// 暂停协程1秒钟,受到DeletaTime影响</span></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSecondsRealtime</span>(<span class="params"><span class="number">1</span></span>)</span>;<span class="comment">//不受到DeletaTime影响</span></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForFixedUpdate</span>()</span>; <span class="comment">// 等待下一个FixedUpdate消息</span></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForEndOfFrame</span>()</span>; <span class="comment">// 等待下一个渲染帧的结束</span></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitUntil</span>(<span class="params">(</span>)</span> =&gt; oneSecond&gt;<span class="number">1</span>);<span class="comment">//等到某判断条件为真时</span></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitWhile</span>(<span class="params">(</span>)</span> =&gt; oneSecond&gt;<span class="number">1</span>);<span class="comment">//等到某判断条件为假时</span></span><br><span class="line"></span><br><span class="line">AsyncOperation <span class="keyword">async</span> = SceneManager.LoadSceneAsync(<span class="string">&quot;SceneName&quot;</span>);<span class="comment">//暂停协程，异步场景加载</span></span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">async</span>; <span class="comment">// 等待场景加载完成</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">break</span>;<span class="comment">//直接终止，类似于return操作</span></span><br></pre></td></tr></table></figure><p>不仅如此，你甚至能使用自定义的yield return，请看代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyYieldInstruction</span> : <span class="title">CustomYieldInstruction</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> isFinished = <span class="literal">false</span>; <span class="comment">// 是否完成的标志位</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> keepWaiting &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> !isFinished; <span class="comment">// 当未完成时，协程继续等待</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Finish</span>()</span> &#123;</span><br><span class="line">        isFinished = <span class="literal">true</span>; <span class="comment">// 设置完成标志位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>众所周知，自定义yield return类型需要满足以下两个条件：</p><ul><li><p>继承自Unity的CustomYieldInstruction类。</p></li><li><p>实现keepWaiting属性，该属性的返回值控制协程是否继续等待。</p></li></ul><p>在上面的示例中，MyYieldInstruction类继承自CustomYieldInstruction类，并实现了keepWaiting属性和Finish方法。在MyYieldInstruction类中，我们使用isFinished变量表示自定义的操作是否完成。在keepWaiting属性中，当isFinished为false时，协程将继续等待；当isFinished为true时，协程将不再等待，继续执行后面的代码。</p><p>以下的代码会告诉你该如何使用前面我们自定义的yield return</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">MyCoroutine</span>()</span> &#123;</span><br><span class="line">    Debug.Log(<span class="string">&quot;Start&quot;</span>);</span><br><span class="line">    MyYieldInstruction myYield = <span class="keyword">new</span> MyYieldInstruction();</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> myYield;</span><br><span class="line">    Debug.Log(<span class="string">&quot;Finish&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">MyCoroutine coroutine = StartCoroutine(MyCoroutine());</span><br><span class="line">coroutine.Stop(); <span class="comment">// 可以通过Stop方法提前终止协程</span></span><br></pre></td></tr></table></figure><p>值得注意的是，在使用自定义yield return类型时，需要特别注意协程的终止条件，以避免出现不可预期的结果。</p><h3 id="StartCoroutine语句"><a href="#StartCoroutine语句" class="headerlink" title="StartCoroutine语句"></a>StartCoroutine语句</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StartCoroutine(方法)；</span><br><span class="line">StartCoroutine(方法名)；</span><br></pre></td></tr></table></figure><p>StartCoroutine的返回值类型是IEnumerator</p><p>注意：StartCoroutine语句只能在MonoBehaviour派生类的方法中使用，因为协程依赖于Unity的消息循环机制。</p><h2 id="三-协程的结束"><a href="#三-协程的结束" class="headerlink" title="三.协程的结束"></a>三.协程的结束</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StopCoroutine(方法)；</span><br><span class="line">StopAllCoroutine()；</span><br></pre></td></tr></table></figure><h2 id="四-迭代器与协程的区别"><a href="#四-迭代器与协程的区别" class="headerlink" title="四.迭代器与协程的区别"></a>四.迭代器与协程的区别</h2><p>迭代器（Iterator）和协程（Coroutine）在Unity中都用于异步操作，但它们在实现和使用上有一些区别。</p><ol><li>实现方式不同</li></ol><p>迭代器是一种基于枚举器（Enumerator）实现的语法，通过yield return语句实现协程的暂停和恢复。在编写迭代器时，需要实现IEnumerator和IEnumerable接口，并实现MoveNext、Reset和Current等方法。</p><p>协程是一种基于IEnumerator实现的语法，通过StartCoroutine和yield return语句实现协程的启动和暂停。在编写协程时，需要定义一个返回值为IEnumerator类型的方法，并使用yield return语句来暂停协程的执行。</p><ol><li>使用方式不同</li></ol><p>迭代器通常用于实现可枚举类型的遍历，可以通过foreach语句进行遍历操作。在协程中，迭代器通常用于实现异步操作，例如延迟执行、动画效果等。</p><p>协程通常用于实现异步操作，可以通过StartCoroutine语句启动协程，并使用yield return语句实现协程的暂停和恢复。协程可以通过yield return语句实现延迟执行、分步执行、等待操作完成等功能。</p><ol><li>执行顺序不同</li></ol><p>迭代器的执行顺序是在同一线程中顺序执行，即在迭代器中的每个yield return语句执行完毕后，才会执行下一个yield return语句或方法的其他部分。</p><p>协程的执行顺序是异步的，即在协程执行过程中可以执行其他代码。协程的执行可以被暂停和恢复，可以实现延迟执行、动画效果、等待操作完成等功能。</p><hr><p>本文作于2023-03-19，首发于CSDN<br><a href="https://blog.csdn.net/jubunihuan/article/details/129652810">https://blog.csdn.net/jubunihuan/article/details/129652810</a></p>]]></content>
      
      
      <categories>
          
          <category> 资料向 </category>
          
          <category> 语法 </category>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> C# </tag>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/08/04/hello-world/"/>
      <url>/2023/08/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
